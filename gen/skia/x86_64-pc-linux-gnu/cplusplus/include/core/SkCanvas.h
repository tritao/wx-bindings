// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#pragma once

#include "CppSharp.h"
#include "FastDelegates.h"
#include <include/core/SkCanvas.h>

namespace SkiaSharp
{
    class SkAutoCanvasRestore;
    class SkCanvas;
}

namespace SkiaSharp
{
    /// <summary>
    /// <para>SkCanvas provides an interface for drawing, and how the drawing is clipped and transformed.</para>
    /// <para>SkCanvas contains a stack of SkMatrix and clip values.</para>
    /// </summary>
    /// <remarks>
    /// <para>SkCanvas and SkPaint together provide the state to draw into SkSurface or SkBaseDevice.</para>
    /// <para>Each SkCanvas draw call transforms the geometry of the object by the concatenation of all</para>
    /// <para>SkMatrix values in the stack. The transformed geometry is clipped by the intersection</para>
    /// <para>of all of clip values in the stack. The SkCanvas draw calls use SkPaint to supply drawing</para>
    /// <para>state such as color, SkTypeface, text size, stroke width, SkShader and so on.</para>
    /// <para>To draw to a pixel-based destination, create raster surface or GPU surface.</para>
    /// <para>Request SkCanvas from SkSurface to obtain the interface to draw.</para>
    /// <para>SkCanvas generated by raster surface draws to memory visible to the CPU.</para>
    /// <para>SkCanvas generated by GPU surface uses Vulkan or OpenGL to draw to the GPU.</para>
    /// <para>To draw to a document, obtain SkCanvas from SVG canvas, document PDF, or SkPictureRecorder.</para>
    /// <para>SkDocument based SkCanvas and other SkCanvas subclasses reference SkBaseDevice describing the</para>
    /// <para>destination.</para>
    /// <para>SkCanvas can be constructed to draw to SkBitmap without first creating raster surface.</para>
    /// <para>This approach may be deprecated in the future.</para>
    /// </remarks>
    class SkCanvas
    {
    public:

        /// <summary>
        /// <para>SaveLayerFlags provides options that may be used in any combination in SaveLayerRec,</para>
        /// <para>defining how layer allocated by saveLayer() operates. It may be set to zero,</para>
        /// <para>kPreserveLCDText_SaveLayerFlag, kInitWithPrevious_SaveLayerFlag, or both flags.</para>
        /// </summary>
        enum SaveLayerFlagsSet : unsigned int
        {
            kPreserveLCDText_SaveLayerFlag = 2,
            /// <summary>initializes with previous contents</summary>
            kInitWithPrevious_SaveLayerFlag = 4,
            kMaskAgainstCoverage_EXPERIMENTAL_DONT_USE_SaveLayerFlag = 8,
            kF16ColorType = 16
        };

        /// <summary>
        /// <para>Selects if an array of points are drawn as discrete points, as lines, or as</para>
        /// <para>an open polygon.</para>
        /// </summary>
        enum PointMode : unsigned int
        {
            /// <summary>draw each point separately</summary>
            kPoints_PointMode = 0,
            /// <summary>draw each pair of points as a line segment</summary>
            kLines_PointMode = 1,
            /// <summary>draw the array of points as a open polygon</summary>
            kPolygon_PointMode = 2
        };

        /// <summary>
        /// <para>SrcRectConstraint controls the behavior at the edge of source SkRect,</para>
        /// <para>provided to drawImageRect(), trading off speed for precision.</para>
        /// </summary>
        /// <remarks>
        /// <para>SkFilterQuality in SkPaint may sample multiple pixels in the image. Source SkRect</para>
        /// <para>restricts the bounds of pixels that may be read. SkFilterQuality may slow down if</para>
        /// <para>it cannot read outside the bounds, when sampling near the edge of source SkRect.</para>
        /// <para>SrcRectConstraint specifies whether an SkImageFilter is allowed to read pixels</para>
        /// <para>outside source SkRect.</para>
        /// </remarks>
        enum SrcRectConstraint : unsigned int
        {
            /// <summary>sample only inside bounds; slower</summary>
            kStrict_SrcRectConstraint = 0,
            /// <summary>sample outside bounds; faster</summary>
            kFast_SrcRectConstraint = 1
        };

        /// <summary>Experimental. Controls anti-aliasing of each edge of images in an image-set.</summary>
        enum QuadAAFlags : unsigned int
        {
            kLeft_QuadAAFlag = 1,
            kTop_QuadAAFlag = 2,
            kRight_QuadAAFlag = 4,
            kBottom_QuadAAFlag = 8,
            kNone_QuadAAFlags = 0,
            kAll_QuadAAFlags = 15
        };

        /// <summary>SaveLayerRec contains the state used to create the layer.</summary>
        class SaveLayerRec
        {
        public:

            ::SkCanvas::SaveLayerRec* __Instance;

            SaveLayerRec(::SkCanvas::SaveLayerRec* instance, bool ownNativeInstance = false);

            /// <summary>Sets fBounds, fPaint, and fBackdrop to nullptr. Clears fSaveLayerFlags.</summary>
            /// <returns>empty SaveLayerRec</returns>
            SaveLayerRec();

            SaveLayerRec(const ::SkiaSharp::SkCanvas::SaveLayerRec& _0);

            ~SaveLayerRec();

            unsigned int get_fSaveLayerFlags();

            void set_fSaveLayerFlags(unsigned int value);

        protected:
            bool __ownsNativeInstance;
        };

        /// <summary>
        /// <para>SkCanvas::Lattice divides SkBitmap or SkImage into a rectangular grid.</para>
        /// <para>Grid entries on even columns and even rows are fixed; these entries are</para>
        /// <para>always drawn at their original size if the destination is large enough.</para>
        /// <para>If the destination side is too small to hold the fixed entries, all fixed</para>
        /// <para>entries are proportionately scaled down to fit.</para>
        /// <para>The grid entries not on even columns and rows are scaled to fit the</para>
        /// <para>remaining space, if any.</para>
        /// </summary>
        class Lattice
        {
        public:

            /// <summary>
            /// <para>Optional setting per rectangular grid entry to make it transparent,</para>
            /// <para>or to fill the grid entry with a color.</para>
            /// </summary>
            enum RectType : unsigned char
            {
                /// <summary>draws SkBitmap into lattice rectangle</summary>
                kDefault = 0,
                /// <summary>skips lattice rectangle by making it transparent</summary>
                kTransparent = 1,
                /// <summary>draws one of fColors into lattice rectangle</summary>
                kFixedColor = 2
            };

            ::SkCanvas::Lattice* __Instance;

            Lattice(::SkCanvas::Lattice* instance, bool ownNativeInstance = false);

            Lattice();

            Lattice(const ::SkiaSharp::SkCanvas::Lattice& _0);

            ~Lattice();

            const int* get_fXDivs();

            void set_fXDivs(const int* value);

            const int* get_fYDivs();

            void set_fYDivs(const int* value);

            const ::SkiaSharp::SkCanvas::Lattice::RectType* get_fRectTypes();

            void set_fRectTypes(const ::SkiaSharp::SkCanvas::Lattice::RectType* value);

            int get_fXCount();

            void set_fXCount(int value);

            int get_fYCount();

            void set_fYCount(int value);

            unsigned int* get_fColors();

            void set_fColors(unsigned int* value);

        protected:
            bool __ownsNativeInstance;
        };

        /// <summary>This is used by the experimental API below.</summary>
        class ImageSetEntry
        {
        public:

            ::SkCanvas::ImageSetEntry* __Instance;

            ImageSetEntry(::SkCanvas::ImageSetEntry* instance, bool ownNativeInstance = false);

            ImageSetEntry();

            ImageSetEntry(const ::SkiaSharp::SkCanvas::ImageSetEntry& _0);

            ~ImageSetEntry();

            int get_fMatrixIndex();

            void set_fMatrixIndex(int value);

            float get_fAlpha();

            void set_fAlpha(float value);

            unsigned int get_fAAFlags();

            void set_fAAFlags(unsigned int value);

            bool get_fHasClip();

            void set_fHasClip(bool value);

        protected:
            bool __ownsNativeInstance;
        };

        ::SkCanvas* __Instance;

        SkCanvas(::SkCanvas* instance, bool ownNativeInstance = false);

        /// <summary>
        /// <para>Creates an empty SkCanvas with no backing device or pixels, with</para>
        /// <para>a width and height of zero.</para>
        /// </summary>
        /// <returns>
        /// <para>empty SkCanvas</para>
        /// <para>example: https://fiddle.skia.org/c/_empty_constructor</para>
        /// </returns>
        SkCanvas();

        ~SkCanvas();

        /// <summary>Returns custom context that tracks the SkMatrix and clip.</summary>
        /// <returns>
        /// <para>context of custom allocation</para>
        /// <para>example: https://fiddle.skia.org/c/_accessTopRasterHandle</para>
        /// </returns>
        /// <remarks>
        /// <para>Use SkRasterHandleAllocator to blend Skia drawing with custom drawing, typically performed</para>
        /// <para>by the host platform user interface. The custom context returned is generated by</para>
        /// <para>SkRasterHandleAllocator::MakeCanvas, which creates a custom canvas with raster storage for</para>
        /// <para>the drawing destination.</para>
        /// </remarks>
        void* accessTopRasterHandle() const;

        /// <summary>
        /// <para>Returns the number of saved states, each containing: SkMatrix and clip.</para>
        /// <para>Equals the number of save() calls less the number of restore() calls plus one.</para>
        /// <para>The save count of a new canvas is one.</para>
        /// </summary>
        /// <returns>
        /// <para>depth of save state stack</para>
        /// <para>example: https://fiddle.skia.org/c/_getSaveCount</para>
        /// </returns>
        int getSaveCount() const;

        /// <summary>Returns true if clip is empty; that is, nothing will draw.</summary>
        /// <returns>
        /// <para>true if clip is empty</para>
        /// <para>example: https://fiddle.skia.org/c/_isClipEmpty</para>
        /// </returns>
        /// <remarks>
        /// <para>May do work when called; it should not be called</para>
        /// <para>more often than needed. However, once called, subsequent calls perform no</para>
        /// <para>work until clip changes.</para>
        /// </remarks>
        virtual bool isClipEmpty() const;

        /// <summary>
        /// <para>Returns true if clip is SkRect and not empty.</para>
        /// <para>Returns false if the clip is empty, or if it is not SkRect.</para>
        /// </summary>
        /// <returns>
        /// <para>true if clip is SkRect and not empty</para>
        /// <para>example: https://fiddle.skia.org/c/_isClipRect</para>
        /// </returns>
        virtual bool isClipRect() const;

        /// <summary>
        /// <para>Triggers the immediate execution of all pending draw operations.</para>
        /// <para>If SkCanvas is associated with GPU surface, resolves all pending GPU operations.</para>
        /// <para>If SkCanvas is associated with raster surface, has no effect; raster draw</para>
        /// <para>operations are never deferred.</para>
        /// </summary>
        void flush();

        /// <summary>
        /// <para>Saves SkMatrix and clip.</para>
        /// <para>Calling restore() discards changes to SkMatrix and clip,</para>
        /// <para>restoring the SkMatrix and clip to their state when save() was called.</para>
        /// </summary>
        /// <returns>
        /// <para>depth of saved stack</para>
        /// <para>example: https://fiddle.skia.org/c/_save</para>
        /// </returns>
        /// <remarks>
        /// <para>SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat(), setMatrix(),</para>
        /// <para>and resetMatrix(). Clip may be changed by clipRect(), clipRRect(), clipPath(), clipRegion().</para>
        /// <para>Saved SkCanvas state is put on a stack; multiple calls to save() should be balance</para>
        /// <para>by an equal number of calls to restore().</para>
        /// <para>Call restoreToCount() with result to restore this and subsequent saves.</para>
        /// </remarks>
        int save();

        /// <summary>Saves SkMatrix and clip, and allocates SkBitmap for subsequent drawing.</summary>
        /// <param name="layerRec">layer state</param>
        /// <returns>
        /// <para>depth of save state stack before this call was made.</para>
        /// <para>example: https://fiddle.skia.org/c/_saveLayer_3</para>
        /// </returns>
        /// <remarks>
        /// <para>Calling restore() discards changes to SkMatrix and clip,</para>
        /// <para>and blends SkBitmap with alpha opacity onto the prior layer.</para>
        /// <para>SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat(),</para>
        /// <para>setMatrix(), and resetMatrix(). Clip may be changed by clipRect(), clipRRect(),</para>
        /// <para>clipPath(), clipRegion().</para>
        /// <para>SaveLayerRec contains the state used to create the layer.</para>
        /// <para>Call restoreToCount() with returned value to restore this and subsequent saves.</para>
        /// </remarks>
        int saveLayer(const ::SkiaSharp::SkCanvas::SaveLayerRec& layerRec);

        /// <summary>
        /// <para>Removes changes to SkMatrix and clip since SkCanvas state was</para>
        /// <para>last saved. The state is removed from the stack.</para>
        /// </summary>
        /// <remarks>
        /// <para>Does nothing if the stack is empty.</para>
        /// <para>example: https://fiddle.skia.org/c/_restore</para>
        /// <para>example: https://fiddle.skia.org/c/_restore</para>
        /// </remarks>
        void restore();

        /// <summary>
        /// <para>Restores state to SkMatrix and clip values when save(), saveLayer(),</para>
        /// <para>saveLayerPreserveLCDTextRequests(), or saveLayerAlpha() returned saveCount.</para>
        /// </summary>
        /// <param name="saveCount">depth of state stack to restore</param>
        /// <remarks>
        /// <para>Does nothing if saveCount is greater than state stack count.</para>
        /// <para>Restores state to initial values if saveCount is less than or equal to one.</para>
        /// <para>example: https://fiddle.skia.org/c/_restoreToCount</para>
        /// </remarks>
        void restoreToCount(int saveCount);

        /// <summary>Translates SkMatrix by dx along the x-axis and dy along the y-axis.</summary>
        /// <param name="dx">distance to translate on x-axis</param>
        /// <param name="dy">distance to translate on y-axis</param>
        /// <remarks>
        /// <para>Mathematically, replaces SkMatrix with a translation matrix</para>
        /// <para>premultiplied with SkMatrix.</para>
        /// <para>This has the effect of moving the drawing by (dx, dy) before transforming</para>
        /// <para>the result with SkMatrix.</para>
        /// <para>example: https://fiddle.skia.org/c/_translate</para>
        /// </remarks>
        void translate(float dx, float dy);

        /// <summary>Scales SkMatrix by sx on the x-axis and sy on the y-axis.</summary>
        /// <param name="sx">amount to scale on x-axis</param>
        /// <param name="sy">amount to scale on y-axis</param>
        /// <remarks>
        /// <para>Mathematically, replaces SkMatrix with a scale matrix</para>
        /// <para>premultiplied with SkMatrix.</para>
        /// <para>This has the effect of scaling the drawing by (sx, sy) before transforming</para>
        /// <para>the result with SkMatrix.</para>
        /// <para>example: https://fiddle.skia.org/c/_scale</para>
        /// </remarks>
        void scale(float sx, float sy);

        /// <summary>Rotates SkMatrix by degrees. Positive degrees rotates clockwise.</summary>
        /// <param name="degrees">amount to rotate, in degrees</param>
        /// <remarks>
        /// <para>Mathematically, replaces SkMatrix with a rotation matrix</para>
        /// <para>premultiplied with SkMatrix.</para>
        /// <para>This has the effect of rotating the drawing by degrees before transforming</para>
        /// <para>the result with SkMatrix.</para>
        /// <para>example: https://fiddle.skia.org/c/_rotate</para>
        /// </remarks>
        void rotate(float degrees);

        /// <summary>
        /// <para>Rotates SkMatrix by degrees about a point at (px, py). Positive degrees rotates</para>
        /// <para>clockwise.</para>
        /// </summary>
        /// <param name="degrees">amount to rotate, in degrees</param>
        /// <param name="px">x-axis value of the point to rotate about</param>
        /// <param name="py">y-axis value of the point to rotate about</param>
        /// <remarks>
        /// <para>Mathematically, constructs a rotation matrix; premultiplies the rotation matrix by</para>
        /// <para>a translation matrix; then replaces SkMatrix with the resulting matrix</para>
        /// <para>premultiplied with SkMatrix.</para>
        /// <para>This has the effect of rotating the drawing about a given point before</para>
        /// <para>transforming the result with SkMatrix.</para>
        /// <para>example: https://fiddle.skia.org/c/_rotate_2</para>
        /// </remarks>
        void rotate(float degrees, float px, float py);

        /// <summary>
        /// <para>Skews SkMatrix by sx on the x-axis and sy on the y-axis. A positive value of sx</para>
        /// <para>skews the drawing right as y-axis values increase; a positive value of sy skews</para>
        /// <para>the drawing down as x-axis values increase.</para>
        /// </summary>
        /// <param name="sx">amount to skew on x-axis</param>
        /// <param name="sy">amount to skew on y-axis</param>
        /// <remarks>
        /// <para>Mathematically, replaces SkMatrix with a skew matrix premultiplied with SkMatrix.</para>
        /// <para>This has the effect of skewing the drawing by (sx, sy) before transforming</para>
        /// <para>the result with SkMatrix.</para>
        /// <para>example: https://fiddle.skia.org/c/_skew</para>
        /// </remarks>
        void skew(float sx, float sy);

        /// <summary>
        /// <para>Record a marker (provided by caller) for the current CTM. This does not change anything</para>
        /// <para>about the ctm or clip, but does &quot;name&quot; this matrix value, so it can be referenced by</para>
        /// <para>custom effects (who access it by specifying the same name).</para>
        /// </summary>
        /// <remarks>
        /// <para>Within a save frame, marking with the same name more than once just replaces the previous</para>
        /// <para>value. However, between save frames, marking with the same name does not lose the marker</para>
        /// <para>in the previous save frame. It is &quot;visible&quot; when the current save() is balanced with</para>
        /// <para>a restore().</para>
        /// </remarks>
        void markCTM(const char* name);

        /// <summary>
        /// <para>Sets SkMatrix to the identity matrix.</para>
        /// <para>Any prior matrix state is overwritten.</para>
        /// </summary>
        /// <remarks>example: https://fiddle.skia.org/c/_resetMatrix</remarks>
        void resetMatrix();

        /// <summary>
        /// <para>Fills clip with color color using SkBlendMode::kSrc.</para>
        /// <para>This has the effect of replacing all pixels contained by clip with color.</para>
        /// </summary>
        /// <param name="color">unpremultiplied ARGB</param>
        void clear(unsigned int color);

        /// <summary>
        /// <para>Makes SkCanvas contents undefined. Subsequent calls that read SkCanvas pixels,</para>
        /// <para>such as drawing with SkBlendMode, return undefined results. discard() does</para>
        /// <para>not change clip or SkMatrix.</para>
        /// </summary>
        /// <remarks>
        /// <para>discard() may do nothing, depending on the implementation of SkSurface or SkBaseDevice</para>
        /// <para>that created SkCanvas.</para>
        /// <para>discard() allows optimized performance on subsequent draws by removing</para>
        /// <para>cached data associated with SkSurface or SkBaseDevice.</para>
        /// <para>It is not necessary to call discard() once done with SkCanvas;</para>
        /// <para>any cached data is deleted when owning SkSurface or SkBaseDevice is deleted.</para>
        /// </remarks>
        void discard();

    protected:
        bool __ownsNativeInstance;
    };

    /// <summary>
    /// <para>Stack helper class calls SkCanvas::restoreToCount when SkAutoCanvasRestore</para>
    /// <para>goes out of scope. Use this to guarantee that the canvas is restored to a known</para>
    /// <para>state.</para>
    /// </summary>
    class SkAutoCanvasRestore
    {
    public:

        ::SkAutoCanvasRestore* __Instance;

        SkAutoCanvasRestore(::SkAutoCanvasRestore* instance, bool ownNativeInstance = false);

        /// <summary>Preserves SkCanvas::save() count. Optionally saves SkCanvas clip and SkCanvas matrix.</summary>
        /// <param name="canvas">SkCanvas to guard</param>
        /// <param name="doSave">call SkCanvas::save()</param>
        /// <returns>utility to restore SkCanvas state on destructor</returns>
        SkAutoCanvasRestore(::SkiaSharp::SkCanvas* canvas, bool doSave);

        ~SkAutoCanvasRestore();

        /// <summary>
        /// <para>Restores SkCanvas to saved state immediately. Subsequent calls and</para>
        /// <para>~SkAutoCanvasRestore() have no effect.</para>
        /// </summary>
        void restore();

    protected:
        bool __ownsNativeInstance;
    };
}
