// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace wxSharp
{
    public unsafe partial interface IwxObject : IDisposable
    {
        global::wxSharp.RefCounter GetRefData();

        void SetRefData(global::wxSharp.RefCounter data);

        void Ref(global::wxSharp.IwxObject clone);

        void UnRef();

        void UnShare();

        bool IsSameAs(global::wxSharp.IwxObject o);

        void Dispose();

        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerTowxObject { get; }
    }

    public unsafe partial class RefCounter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vptr_wxRefCounter;

            [FieldOffset(4)]
            internal int m_count;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxRefCounterC2Ev")]
            internal static extern void ctor(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxRefCounter11GetRefCountEv")]
            internal static extern int GetRefCount(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxRefCounter6IncRefEv")]
            internal static extern void IncRef(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxRefCounter6DecRefEv")]
            internal static extern void DecRef(global::System.IntPtr __instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::wxSharp.RefCounter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::wxSharp.RefCounter>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::wxSharp.RefCounter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::wxSharp.RefCounter(native.ToPointer(), skipVTables);
        }

        internal static global::wxSharp.RefCounter __CreateInstance(global::wxSharp.RefCounter.__Internal native, bool skipVTables = false)
        {
            return new global::wxSharp.RefCounter(native, skipVTables);
        }

        private static void* __CopyValue(global::wxSharp.RefCounter.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::wxSharp.RefCounter.__Internal));
            *(global::wxSharp.RefCounter.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RefCounter(global::wxSharp.RefCounter.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RefCounter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public RefCounter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::wxSharp.RefCounter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "wxSharp.RefCounter");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::wxSharp.RefCounter __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::wxSharp.RefCounter.__Internal*) __Instance)->vptr_wxRefCounter = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___dtorDelegate = (global::wxSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::wxSharp.Delegates.Action_IntPtr));
                ___dtorDelegate(__Instance);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int GetRefCount()
        {
            var __ret = __Internal.GetRefCount(__Instance);
            return __ret;
        }

        public void IncRef()
        {
            __Internal.IncRef(__Instance);
        }

        public void DecRef()
        {
            __Internal.DecRef(__Instance);
        }

        #region Virtual table interop

        // virtual ~wxRefCounter() { }
        private static global::wxSharp.Delegates.Action_IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr __instance)
        {
            if (!NativeToManagedMap.ContainsKey(__instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::wxSharp.RefCounter) NativeToManagedMap[__instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(4 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + -8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -8);
                    *(void**) (vfptr0 + -4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -4);
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 4) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(4 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + -8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -8);
                    *(void**) (vfptr0 + -4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -4);
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 4) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class Object : global::wxSharp.IwxObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vptr_wxObject;

            [FieldOffset(4)]
            internal global::System.IntPtr m_refData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxObjectC2Ev")]
            internal static extern void ctor(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxObjectC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr __instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK8wxObject10GetRefDataEv")]
            internal static extern global::System.IntPtr GetRefData(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxObject10SetRefDataEP12wxRefCounter")]
            internal static extern void SetRefData(global::System.IntPtr __instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxObject3RefERKS_")]
            internal static extern void Ref(global::System.IntPtr __instance, global::System.IntPtr clone);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxObject5UnRefEv")]
            internal static extern void UnRef(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxObject7UnShareEv")]
            internal static extern void UnShare(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK8wxObject8IsSameAsERKS_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSameAs(global::System.IntPtr __instance, global::System.IntPtr o);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxObject14AllocExclusiveEv")]
            internal static extern void AllocExclusive(global::System.IntPtr __instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::wxSharp.IwxObject> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::wxSharp.IwxObject>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::wxSharp.Object __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::wxSharp.Object(native.ToPointer(), skipVTables);
        }

        internal static global::wxSharp.Object __CreateInstance(global::wxSharp.Object.__Internal native, bool skipVTables = false)
        {
            return new global::wxSharp.Object(native, skipVTables);
        }

        private static void* __CopyValue(global::wxSharp.Object.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::wxSharp.Object.__Internal));
            global::wxSharp.Object.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Object(global::wxSharp.Object.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Object(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public Object()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::wxSharp.Object.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "wxSharp.Object");
        }

        public Object(global::wxSharp.IwxObject other)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::wxSharp.Object.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__PointerToObject;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "wxSharp.Object");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::wxSharp.IwxObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::wxSharp.Object.__Internal*) __Instance)->vptr_wxObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___dtorDelegate = (global::wxSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::wxSharp.Delegates.Action_IntPtr));
                ___dtorDelegate(__Instance);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::wxSharp.RefCounter GetRefData()
        {
            var __ret = __Internal.GetRefData(__Instance);
            global::wxSharp.RefCounter __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::wxSharp.RefCounter.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::wxSharp.RefCounter) global::wxSharp.RefCounter.NativeToManagedMap[__ret];
            else global::wxSharp.RefCounter.NativeToManagedMap[__ret] = __result0 = (global::wxSharp.RefCounter) global::wxSharp.RefCounter.__CreateInstance(__ret);
            return __result0;
        }

        public void SetRefData(global::wxSharp.RefCounter data)
        {
            var __arg0 = ReferenceEquals(data, null) ? global::System.IntPtr.Zero : data.__Instance;
            __Internal.SetRefData(__Instance, __arg0);
        }

        public void Ref(global::wxSharp.IwxObject clone)
        {
            if (ReferenceEquals(clone, null))
                throw new global::System.ArgumentNullException("clone", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = clone.__PointerToObject;
            __Internal.Ref(__Instance, __arg0);
        }

        public void UnRef()
        {
            __Internal.UnRef(__Instance);
        }

        public void UnShare()
        {
            __Internal.UnShare(__Instance);
        }

        public bool IsSameAs(global::wxSharp.IwxObject o)
        {
            if (ReferenceEquals(o, null))
                throw new global::System.ArgumentNullException("o", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = o.__PointerToObject;
            var __ret = __Internal.IsSameAs(__Instance, __arg0);
            return __ret;
        }

        protected void AllocExclusive()
        {
            __Internal.AllocExclusive(__Instance);
        }

        protected virtual global::wxSharp.RefCounter CreateRefData()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
            var ___CreateRefDataDelegate = (global::wxSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::wxSharp.Delegates.Func_IntPtr_IntPtr));
            var __ret = ___CreateRefDataDelegate(__Instance);
            global::wxSharp.RefCounter __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::wxSharp.RefCounter.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::wxSharp.RefCounter) global::wxSharp.RefCounter.NativeToManagedMap[__ret];
            else global::wxSharp.RefCounter.NativeToManagedMap[__ret] = __result0 = (global::wxSharp.RefCounter) global::wxSharp.RefCounter.__CreateInstance(__ret);
            return __result0;
        }

        protected virtual global::wxSharp.RefCounter CloneRefData(global::wxSharp.RefCounter data)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 4);
            var ___CloneRefDataDelegate = (global::wxSharp.Delegates.Func_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::wxSharp.Delegates.Func_IntPtr_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(data, null) ? global::System.IntPtr.Zero : data.__Instance;
            var __ret = ___CloneRefDataDelegate(__Instance, __arg0);
            global::wxSharp.RefCounter __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::wxSharp.RefCounter.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::wxSharp.RefCounter) global::wxSharp.RefCounter.NativeToManagedMap[__ret];
            else global::wxSharp.RefCounter.NativeToManagedMap[__ret] = __result0 = (global::wxSharp.RefCounter) global::wxSharp.RefCounter.__CreateInstance(__ret);
            return __result0;
        }

        protected global::wxSharp.RefCounter m_refData
        {
            get
            {
                global::wxSharp.RefCounter __result0;
                if (((global::wxSharp.Object.__Internal*) __Instance)->m_refData == IntPtr.Zero) __result0 = null;
                else if (global::wxSharp.RefCounter.NativeToManagedMap.ContainsKey(((global::wxSharp.Object.__Internal*) __Instance)->m_refData))
                    __result0 = (global::wxSharp.RefCounter) global::wxSharp.RefCounter.NativeToManagedMap[((global::wxSharp.Object.__Internal*) __Instance)->m_refData];
                else global::wxSharp.RefCounter.NativeToManagedMap[((global::wxSharp.Object.__Internal*) __Instance)->m_refData] = __result0 = (global::wxSharp.RefCounter) global::wxSharp.RefCounter.__CreateInstance(((global::wxSharp.Object.__Internal*) __Instance)->m_refData);
                return __result0;
            }

            set
            {
                ((global::wxSharp.Object.__Internal*)__Instance)->m_refData = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::System.IntPtr __PointerTowxObject
        {
            get
            {
                return __Instance + 0;
            }
        }

        #region Virtual table interop

        // virtual ~wxObject() { UnRef(); }
        private static global::wxSharp.Delegates.Action_IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr __instance)
        {
            if (!NativeToManagedMap.ContainsKey(__instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::wxSharp.Object) NativeToManagedMap[__instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // wxObjectRefData *CreateRefData() const
        private static global::wxSharp.Delegates.Func_IntPtr_IntPtr _CreateRefDataDelegateInstance;

        private static global::System.IntPtr _CreateRefDataDelegateHook(global::System.IntPtr __instance)
        {
            if (!NativeToManagedMap.ContainsKey(__instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::wxSharp.Object) NativeToManagedMap[__instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.CreateRefData();
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // wxObjectRefData *CloneRefData(const wxObjectRefData *data) const
        private static global::wxSharp.Delegates.Func_IntPtr_IntPtr_IntPtr _CloneRefDataDelegateInstance;

        private static global::System.IntPtr _CloneRefDataDelegateHook(global::System.IntPtr __instance, global::System.IntPtr data)
        {
            if (!NativeToManagedMap.ContainsKey(__instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::wxSharp.Object) NativeToManagedMap[__instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::wxSharp.RefCounter __result0;
            if (data == IntPtr.Zero) __result0 = null;
            else if (global::wxSharp.RefCounter.NativeToManagedMap.ContainsKey(data))
                __result0 = (global::wxSharp.RefCounter) global::wxSharp.RefCounter.NativeToManagedMap[data];
            else __result0 = (global::wxSharp.RefCounter) global::wxSharp.RefCounter.__CreateInstance(data, skipVTables: true);
            var __ret = __target.CloneRefData(__result0);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CreateRefDataDelegateInstance += _CreateRefDataDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CreateRefDataDelegateInstance).ToPointer();
                _CloneRefDataDelegateInstance += _CloneRefDataDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_CloneRefDataDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(7 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + -8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -8);
                    *(void**) (vfptr0 + -4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -4);
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 4);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 12) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 12);
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(7 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + -8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -8);
                    *(void**) (vfptr0 + -4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -4);
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 4);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 12) = _Thunks[1];
                    *(void**) (vfptr0 + 16) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}
