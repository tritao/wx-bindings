// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <wxsharp/brush.h>
#include <node/node_api.h>
#include <assert.h>
#include <stdio.h>
#include "NAPIHelpers.h"

extern napi_ref ctor_wxSharp_Color_Color;

static napi_value register_enum_wxSharp_BrushStyle(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // INVALID
    napi_value i_0;
    status = napi_create_int32(env, -1, &i_0);
    assert(status == napi_ok);

    // SOLID
    napi_value i_1;
    status = napi_create_int32(env, 100, &i_1);
    assert(status == napi_ok);

    // TRANSPARENT
    napi_value i_2;
    status = napi_create_int32(env, 106, &i_2);
    assert(status == napi_ok);

    // STIPPLE_MASK_OPAQUE
    napi_value i_3;
    status = napi_create_int32(env, 107, &i_3);
    assert(status == napi_ok);

    // STIPPLE_MASK
    napi_value i_4;
    status = napi_create_int32(env, 108, &i_4);
    assert(status == napi_ok);

    // STIPPLE
    napi_value i_5;
    status = napi_create_int32(env, 110, &i_5);
    assert(status == napi_ok);

    // BDIAGONAL_HATCH
    napi_value i_6;
    status = napi_create_int32(env, 111, &i_6);
    assert(status == napi_ok);

    // CROSSDIAG_HATCH
    napi_value i_7;
    status = napi_create_int32(env, 112, &i_7);
    assert(status == napi_ok);

    // FDIAGONAL_HATCH
    napi_value i_8;
    status = napi_create_int32(env, 113, &i_8);
    assert(status == napi_ok);

    // CROSS_HATCH
    napi_value i_9;
    status = napi_create_int32(env, 114, &i_9);
    assert(status == napi_ok);

    // HORIZONTAL_HATCH
    napi_value i_10;
    status = napi_create_int32(env, 115, &i_10);
    assert(status == napi_ok);

    // VERTICAL_HATCH
    napi_value i_11;
    status = napi_create_int32(env, 116, &i_11);
    assert(status == napi_ok);

    // FIRST_HATCH
    napi_value i_12;
    status = napi_create_int32(env, 111, &i_12);
    assert(status == napi_ok);

    // LAST_HATCH
    napi_value i_13;
    status = napi_create_int32(env, 116, &i_13);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "INVALID", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "SOLID", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "TRANSPARENT", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "STIPPLE_MASK_OPAQUE", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr },
        { "STIPPLE_MASK", nullptr, nullptr, nullptr, nullptr, i_4, attributes, nullptr },
        { "STIPPLE", nullptr, nullptr, nullptr, nullptr, i_5, attributes, nullptr },
        { "BDIAGONAL_HATCH", nullptr, nullptr, nullptr, nullptr, i_6, attributes, nullptr },
        { "CROSSDIAG_HATCH", nullptr, nullptr, nullptr, nullptr, i_7, attributes, nullptr },
        { "FDIAGONAL_HATCH", nullptr, nullptr, nullptr, nullptr, i_8, attributes, nullptr },
        { "CROSS_HATCH", nullptr, nullptr, nullptr, nullptr, i_9, attributes, nullptr },
        { "HORIZONTAL_HATCH", nullptr, nullptr, nullptr, nullptr, i_10, attributes, nullptr },
        { "VERTICAL_HATCH", nullptr, nullptr, nullptr, nullptr, i_11, attributes, nullptr },
        { "FIRST_HATCH", nullptr, nullptr, nullptr, nullptr, i_12, attributes, nullptr },
        { "LAST_HATCH", nullptr, nullptr, nullptr, nullptr, i_13, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static void dtor_wxSharp_Brush_Brush(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_Brush_Brush;

// wxSharp::Brush::Brush
static napi_value callback_method_wxSharp_Brush_Brush(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Brush* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // Brush()
overload0:
    {
        instance = new wxSharp::Brush();
    }

    // Brush(const ::wxSharp::Color& colour, ::wxSharp::BrushStyle style)
overload1:
    {
        wxSharp::Color* colour_instance;
        status = napi_unwrap(env, _this, (void**) &colour_instance);
        auto &__arg0 = *colour_instance;

        int32_t style;
        status = napi_get_value_int32(env, args[1], &style);
        auto __arg1 = (::wxSharp::BrushStyle)style;

        instance = new wxSharp::Brush(__arg0, __arg1);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_Brush_Brush, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::Brush::Brush: %lu\n", argc);
    return _this;
}

// wxSharp::Brush::operator==
static napi_value callback_method_wxSharp_Brush_operator_EqualEqual(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Brush* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool operator==(const ::wxSharp::Brush& brush) const
overload0:
    {
        wxSharp::Brush* brush_instance;
        status = napi_unwrap(env, _this, (void**) &brush_instance);
        auto &__arg0 = *brush_instance;

        bool __ret = instance->operator==(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Brush::operator==: %lu\n", argc);
    return _this;
}

// wxSharp::Brush::operator!=
static napi_value callback_method_wxSharp_Brush_operator_ExclaimEqual(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Brush* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool operator!=(const ::wxSharp::Brush& brush) const
overload0:
    {
        wxSharp::Brush* brush_instance;
        status = napi_unwrap(env, _this, (void**) &brush_instance);
        auto &__arg0 = *brush_instance;

        bool __ret = instance->operator!=(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Brush::operator!=: %lu\n", argc);
    return _this;
}

// wxSharp::Brush::SetColour
static napi_value callback_method_wxSharp_Brush_SetColour(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Brush* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetColour(unsigned char r, unsigned char g, unsigned char b)
overload0:
    {
        uint32_t r;
        status = napi_get_value_uint32(env, args[0], &r);
        auto __arg0 = r;

        uint32_t g;
        status = napi_get_value_uint32(env, args[1], &g);
        auto __arg1 = g;

        uint32_t b;
        status = napi_get_value_uint32(env, args[2], &b);
        auto __arg2 = b;

        instance->SetColour(__arg0, __arg1, __arg2);
    }
    printf("wxSharp::Brush::SetColour: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_Brush(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "operator==", nullptr, callback_method_wxSharp_Brush_operator_EqualEqual, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "operator!=", nullptr, callback_method_wxSharp_Brush_operator_ExclaimEqual, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetColour", nullptr, callback_method_wxSharp_Brush_SetColour, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "Brush", NAPI_AUTO_LENGTH, callback_method_wxSharp_Brush_Brush, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_Brush_Brush);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_BrushList_BrushList(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_BrushList_BrushList;

// wxSharp::BrushList::BrushList
static napi_value callback_method_wxSharp_BrushList_BrushList(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::BrushList* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // BrushList(const ::wxSharp::BrushList& _0)
overload0:
    {
        wxSharp::BrushList* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::BrushList(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_BrushList_BrushList, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::BrushList::BrushList: %lu\n", argc);
    return _this;
}

// wxSharp::BrushList::FindOrCreateBrush
static napi_value callback_method_wxSharp_BrushList_FindOrCreateBrush(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::BrushList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Brush* FindOrCreateBrush(const ::wxSharp::Color& colour, ::wxSharp::BrushStyle style)
overload0:
    {
        wxSharp::Color* colour_instance;
        status = napi_unwrap(env, _this, (void**) &colour_instance);
        auto &__arg0 = *colour_instance;

        int32_t style;
        status = napi_get_value_int32(env, args[1], &style);
        auto __arg1 = (::wxSharp::BrushStyle)style;

        ::wxSharp::Brush* __ret = instance->FindOrCreateBrush(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Brush_Brush, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::BrushList::FindOrCreateBrush: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_BrushList(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "FindOrCreateBrush", nullptr, callback_method_wxSharp_BrushList_FindOrCreateBrush, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "BrushList", NAPI_AUTO_LENGTH, callback_method_wxSharp_BrushList_BrushList, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_BrushList_BrushList);
    assert(status == napi_ok);

    return constructor;
}

void register_wxsharp_brush(napi_env env, napi_value exports)
{
    napi_value value;

    value = register_enum_wxSharp_BrushStyle(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "BrushStyle", value));

    value = register_class_wxSharp_Brush(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Brush", value));

    value = register_class_wxSharp_BrushList(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "BrushList", value));
}
