// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <wxsharp/colour.h>
#include <node/node_api.h>
#include <assert.h>
#include <stdio.h>
#include "NAPIHelpers.h"

static napi_value register_enum_wxSharp_C2S(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // C2S_NAME
    napi_value i_0;
    status = napi_create_uint32(env, 1, &i_0);
    assert(status == napi_ok);

    // C2S_CSS_SYNTAX
    napi_value i_1;
    status = napi_create_uint32(env, 2, &i_1);
    assert(status == napi_ok);

    // C2S_HTML_SYNTAX
    napi_value i_2;
    status = napi_create_uint32(env, 4, &i_2);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "C2S_NAME", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "C2S_CSS_SYNTAX", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "C2S_HTML_SYNTAX", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static void dtor_wxSharp_Color_Color(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_Color_Color;

// wxSharp::Color::Color
static napi_value callback_method_wxSharp_Color_Color(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Color* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload1;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload2;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload3;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload4;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // Color()
overload0:
    {
        instance = new wxSharp::Color();
    }

    // Color(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha)
overload1:
    {
        uint32_t red;
        status = napi_get_value_uint32(env, args[0], &red);
        auto __arg0 = red;

        uint32_t green;
        status = napi_get_value_uint32(env, args[1], &green);
        auto __arg1 = green;

        uint32_t blue;
        status = napi_get_value_uint32(env, args[2], &blue);
        auto __arg2 = blue;

        uint32_t alpha;
        status = napi_get_value_uint32(env, args[3], &alpha);
        auto __arg3 = alpha;

        instance = new wxSharp::Color(__arg0, __arg1, __arg2, __arg3);
    }

    // Color(unsigned long colRGB)
overload2:
    {
        uint32_t colRGB;
        status = napi_get_value_uint32(env, args[0], &colRGB);
        auto __arg0 = colRGB;

        instance = new wxSharp::Color(__arg0);
    }

    // Color(const char* colourName)
overload3:
    {
        size_t _colourName_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_colourName_size);

        char* colourName = (char*) malloc(_colourName_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_colourName_size);
        assert(status == napi_ok);
        auto __arg0 = colourName;

        instance = new wxSharp::Color(__arg0);
    }

    // Color(const wchar_t* colourName)
overload4:
    {
        size_t _colourName_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_colourName_size);

        char* colourName = (char*) malloc(_colourName_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_colourName_size);
        assert(status == napi_ok);
        auto __arg0 = colourName;

        instance = new wxSharp::Color(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_Color_Color, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::Color::Color: %lu\n", argc);
    return _this;
}

// wxSharp::Color::operator==
static napi_value callback_method_wxSharp_Color_operator_EqualEqual(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Color* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool operator==(const ::wxSharp::Color& col) const
overload0:
    {
        wxSharp::Color* col_instance;
        status = napi_unwrap(env, _this, (void**) &col_instance);
        auto &__arg0 = *col_instance;

        bool __ret = instance->operator==(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Color::operator==: %lu\n", argc);
    return _this;
}

// wxSharp::Color::operator!=
static napi_value callback_method_wxSharp_Color_operator_ExclaimEqual(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Color* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool operator!=(const ::wxSharp::Color& col) const
overload0:
    {
        wxSharp::Color* col_instance;
        status = napi_unwrap(env, _this, (void**) &col_instance);
        auto &__arg0 = *col_instance;

        bool __ret = instance->operator!=(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Color::operator!=: %lu\n", argc);
    return _this;
}

// wxSharp::Color::Set
static napi_value callback_method_wxSharp_Color_Set(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Color* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void Set(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha)
overload0:
    {
        uint32_t red;
        status = napi_get_value_uint32(env, args[0], &red);
        auto __arg0 = red;

        uint32_t green;
        status = napi_get_value_uint32(env, args[1], &green);
        auto __arg1 = green;

        uint32_t blue;
        status = napi_get_value_uint32(env, args[2], &blue);
        auto __arg2 = blue;

        uint32_t alpha;
        status = napi_get_value_uint32(env, args[3], &alpha);
        auto __arg3 = alpha;

        instance->Set(__arg0, __arg1, __arg2, __arg3);
    }

    // bool Set(const char* str)
overload1:
    {
        size_t _str_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_str_size);

        char* str = (char*) malloc(_str_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_str_size);
        assert(status == napi_ok);
        auto __arg0 = str;

        bool __ret = instance->Set(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // void Set(unsigned long colRGB)
overload2:
    {
        uint32_t colRGB;
        status = napi_get_value_uint32(env, args[0], &colRGB);
        auto __arg0 = colRGB;

        instance->Set(__arg0);
    }
    printf("wxSharp::Color::Set: %lu\n", argc);
    return _this;
}

// wxSharp::Color::GetAsString
static napi_value callback_method_wxSharp_Color_GetAsString(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Color* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // char* GetAsString(long flags) const
overload0:
    {
        int32_t flags;
        status = napi_get_value_int32(env, args[0], &flags);
        auto __arg0 = flags;

        const char* __ret = instance->GetAsString(__arg0);

        napi_value __result;
        status = napi_create_string_latin1(env, __ret, NAPI_AUTO_LENGTH, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Color::GetAsString: %lu\n", argc);
    return _this;
}

// wxSharp::Color::ChangeLightness
static napi_value callback_method_wxSharp_Color_ChangeLightness(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Color* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Color ChangeLightness(int ialpha) const
overload0:
    {
        int32_t ialpha;
        status = napi_get_value_int32(env, args[0], &ialpha);
        auto __arg0 = ialpha;

        ::wxSharp::Color __ret = instance->ChangeLightness(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Color_Color, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Color::ChangeLightness: %lu\n", argc);
    return _this;
}

// wxSharp::Color::AlphaBlend
static napi_value callback_method_wxSharp_Color_AlphaBlend(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Color* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_NUMBER(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // unsigned char AlphaBlend(unsigned char fg, unsigned char bg, double alpha)
overload0:
    {
        uint32_t fg;
        status = napi_get_value_uint32(env, args[0], &fg);
        auto __arg0 = fg;

        uint32_t bg;
        status = napi_get_value_uint32(env, args[1], &bg);
        auto __arg1 = bg;

        double alpha;
        status = napi_get_value_double(env, args[2], &alpha);
        auto __arg2 = alpha;

        unsigned char __ret = ::wxSharp::Color::AlphaBlend(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_create_uint32(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Color::AlphaBlend: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_Color(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "operator==", nullptr, callback_method_wxSharp_Color_operator_EqualEqual, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "operator!=", nullptr, callback_method_wxSharp_Color_operator_ExclaimEqual, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Set", nullptr, callback_method_wxSharp_Color_Set, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "GetAsString", nullptr, callback_method_wxSharp_Color_GetAsString, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ChangeLightness", nullptr, callback_method_wxSharp_Color_ChangeLightness, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "AlphaBlend", nullptr, callback_method_wxSharp_Color_AlphaBlend, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes | napi_static), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "Color", NAPI_AUTO_LENGTH, callback_method_wxSharp_Color_Color, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_Color_Color);
    assert(status == napi_ok);

    return constructor;
}

void register_wxsharp_colour(napi_env env, napi_value exports)
{
    napi_value value;

    value = register_enum_wxSharp_C2S(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "C2S", value));

    value = register_class_wxSharp_Color(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Color", value));
}
