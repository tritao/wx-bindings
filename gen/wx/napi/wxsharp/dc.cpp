// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <wxsharp/dc.h>
#include <node/node_api.h>
#include <assert.h>
#include <stdio.h>
#include "NAPIHelpers.h"

extern napi_ref ctor_wxSharp_GraphicsContext_GraphicsContext;
extern napi_ref ctor_wxSharp_GraphicsPath_GraphicsPath;
extern napi_ref ctor_wxSharp_GraphicsMatrix_GraphicsMatrix;
extern napi_ref ctor_wxSharp_GraphicsPen_GraphicsPen;
extern napi_ref ctor_wxSharp_GraphicsBrush_GraphicsBrush;
extern napi_ref ctor_wxSharp_GraphicsFont_GraphicsFont;
extern napi_ref ctor_wxSharp_GraphicsBitmap_GraphicsBitmap;
extern napi_ref ctor_wxSharp_Event_Event;
extern napi_ref ctor_wxSharp_Point_Point;
extern napi_ref ctor_wxSharp_Rect_Rect;
extern napi_ref ctor_wxSharp_Color_Color;
extern napi_ref ctor_wxSharp_SizerItem_SizerItem;
extern napi_ref ctor_wxSharp_Size_Size;
extern napi_ref ctor_wxSharp_Window_Window;
extern napi_ref ctor_wxSharp_EvtHandler_EvtHandler;
extern napi_ref ctor_wxSharp_VisualAttributes_VisualAttributes;

static napi_value register_enum_wxSharp_RasterOperationMode(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // CLEAR
    napi_value i_0;
    status = napi_create_uint32(env, 0, &i_0);
    assert(status == napi_ok);

    // XOR
    napi_value i_1;
    status = napi_create_uint32(env, 1, &i_1);
    assert(status == napi_ok);

    // INVERT
    napi_value i_2;
    status = napi_create_uint32(env, 2, &i_2);
    assert(status == napi_ok);

    // OR_REVERSE
    napi_value i_3;
    status = napi_create_uint32(env, 3, &i_3);
    assert(status == napi_ok);

    // AND_REVERSE
    napi_value i_4;
    status = napi_create_uint32(env, 4, &i_4);
    assert(status == napi_ok);

    // COPY
    napi_value i_5;
    status = napi_create_uint32(env, 5, &i_5);
    assert(status == napi_ok);

    // AND
    napi_value i_6;
    status = napi_create_uint32(env, 6, &i_6);
    assert(status == napi_ok);

    // AND_INVERT
    napi_value i_7;
    status = napi_create_uint32(env, 7, &i_7);
    assert(status == napi_ok);

    // NO_OP
    napi_value i_8;
    status = napi_create_uint32(env, 8, &i_8);
    assert(status == napi_ok);

    // NOR
    napi_value i_9;
    status = napi_create_uint32(env, 9, &i_9);
    assert(status == napi_ok);

    // EQUIV
    napi_value i_10;
    status = napi_create_uint32(env, 10, &i_10);
    assert(status == napi_ok);

    // SRC_INVERT
    napi_value i_11;
    status = napi_create_uint32(env, 11, &i_11);
    assert(status == napi_ok);

    // OR_INVERT
    napi_value i_12;
    status = napi_create_uint32(env, 12, &i_12);
    assert(status == napi_ok);

    // NAND
    napi_value i_13;
    status = napi_create_uint32(env, 13, &i_13);
    assert(status == napi_ok);

    // OR
    napi_value i_14;
    status = napi_create_uint32(env, 14, &i_14);
    assert(status == napi_ok);

    // SET
    napi_value i_15;
    status = napi_create_uint32(env, 15, &i_15);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "CLEAR", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "XOR", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "INVERT", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "OR_REVERSE", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr },
        { "AND_REVERSE", nullptr, nullptr, nullptr, nullptr, i_4, attributes, nullptr },
        { "COPY", nullptr, nullptr, nullptr, nullptr, i_5, attributes, nullptr },
        { "AND", nullptr, nullptr, nullptr, nullptr, i_6, attributes, nullptr },
        { "AND_INVERT", nullptr, nullptr, nullptr, nullptr, i_7, attributes, nullptr },
        { "NO_OP", nullptr, nullptr, nullptr, nullptr, i_8, attributes, nullptr },
        { "NOR", nullptr, nullptr, nullptr, nullptr, i_9, attributes, nullptr },
        { "EQUIV", nullptr, nullptr, nullptr, nullptr, i_10, attributes, nullptr },
        { "SRC_INVERT", nullptr, nullptr, nullptr, nullptr, i_11, attributes, nullptr },
        { "OR_INVERT", nullptr, nullptr, nullptr, nullptr, i_12, attributes, nullptr },
        { "NAND", nullptr, nullptr, nullptr, nullptr, i_13, attributes, nullptr },
        { "OR", nullptr, nullptr, nullptr, nullptr, i_14, attributes, nullptr },
        { "SET", nullptr, nullptr, nullptr, nullptr, i_15, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_MappingMode(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // MM_TEXT
    napi_value i_0;
    status = napi_create_uint32(env, 1, &i_0);
    assert(status == napi_ok);

    // MM_METRIC
    napi_value i_1;
    status = napi_create_uint32(env, 2, &i_1);
    assert(status == napi_ok);

    // MM_LOMETRIC
    napi_value i_2;
    status = napi_create_uint32(env, 3, &i_2);
    assert(status == napi_ok);

    // MM_TWIPS
    napi_value i_3;
    status = napi_create_uint32(env, 4, &i_3);
    assert(status == napi_ok);

    // MM_POINTS
    napi_value i_4;
    status = napi_create_uint32(env, 5, &i_4);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "MM_TEXT", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "MM_METRIC", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "MM_LOMETRIC", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "MM_TWIPS", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr },
        { "MM_POINTS", nullptr, nullptr, nullptr, nullptr, i_4, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_FloodFillStyle(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // FLOOD_SURFACE
    napi_value i_0;
    status = napi_create_uint32(env, 1, &i_0);
    assert(status == napi_ok);

    // FLOOD_BORDER
    napi_value i_1;
    status = napi_create_uint32(env, 2, &i_1);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "FLOOD_SURFACE", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "FLOOD_BORDER", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static void dtor_wxSharp_FontMetrics_FontMetrics(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_FontMetrics_FontMetrics;

// wxSharp::FontMetrics::FontMetrics
static napi_value callback_method_wxSharp_FontMetrics_FontMetrics(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FontMetrics* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // FontMetrics()
overload0:
    {
        instance = new wxSharp::FontMetrics();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_FontMetrics_FontMetrics, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::FontMetrics::FontMetrics: %lu\n", argc);
    return _this;
}

// wxSharp::FontMetrics::set_height
static napi_value callback_method_wxSharp_FontMetrics_set_height(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FontMetrics* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_height(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_height(__arg0);
    }
    printf("wxSharp::FontMetrics::set_height: %lu\n", argc);
    return _this;
}

// wxSharp::FontMetrics::set_ascent
static napi_value callback_method_wxSharp_FontMetrics_set_ascent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FontMetrics* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_ascent(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_ascent(__arg0);
    }
    printf("wxSharp::FontMetrics::set_ascent: %lu\n", argc);
    return _this;
}

// wxSharp::FontMetrics::set_descent
static napi_value callback_method_wxSharp_FontMetrics_set_descent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FontMetrics* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_descent(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_descent(__arg0);
    }
    printf("wxSharp::FontMetrics::set_descent: %lu\n", argc);
    return _this;
}

// wxSharp::FontMetrics::set_internalLeading
static napi_value callback_method_wxSharp_FontMetrics_set_internalLeading(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FontMetrics* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_internalLeading(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_internalLeading(__arg0);
    }
    printf("wxSharp::FontMetrics::set_internalLeading: %lu\n", argc);
    return _this;
}

// wxSharp::FontMetrics::set_externalLeading
static napi_value callback_method_wxSharp_FontMetrics_set_externalLeading(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FontMetrics* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_externalLeading(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_externalLeading(__arg0);
    }
    printf("wxSharp::FontMetrics::set_externalLeading: %lu\n", argc);
    return _this;
}

// wxSharp::FontMetrics::set_averageWidth
static napi_value callback_method_wxSharp_FontMetrics_set_averageWidth(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FontMetrics* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_averageWidth(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_averageWidth(__arg0);
    }
    printf("wxSharp::FontMetrics::set_averageWidth: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_FontMetrics(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "set_height", nullptr, callback_method_wxSharp_FontMetrics_set_height, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_ascent", nullptr, callback_method_wxSharp_FontMetrics_set_ascent, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_descent", nullptr, callback_method_wxSharp_FontMetrics_set_descent, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_internalLeading", nullptr, callback_method_wxSharp_FontMetrics_set_internalLeading, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_externalLeading", nullptr, callback_method_wxSharp_FontMetrics_set_externalLeading, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_averageWidth", nullptr, callback_method_wxSharp_FontMetrics_set_averageWidth, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "FontMetrics", NAPI_AUTO_LENGTH, callback_method_wxSharp_FontMetrics_FontMetrics, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_FontMetrics_FontMetrics);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_DC_DC(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_DC_DC;

// wxSharp::DC::DC
static napi_value callback_method_wxSharp_DC_DC(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // DC
overload0:
    {
        wxSharp::DC* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::DC(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_DC_DC, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::DC::DC: %lu\n", argc);
    return _this;
}

// wxSharp::DC::CopyAttributes
static napi_value callback_method_wxSharp_DC_CopyAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void CopyAttributes(const ::wxSharp::DC& dc)
overload0:
    {
        wxSharp::DC* dc_instance;
        status = napi_unwrap(env, _this, (void**) &dc_instance);
        auto &__arg0 = *dc_instance;

        instance->CopyAttributes(__arg0);
    }
    printf("wxSharp::DC::CopyAttributes: %lu\n", argc);
    return _this;
}

// wxSharp::DC::CanDrawBitmap
static napi_value callback_method_wxSharp_DC_CanDrawBitmap(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    bool __ret = instance->CanDrawBitmap();

    napi_value __result;
    status = napi_get_boolean(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;
    printf("wxSharp::DC::CanDrawBitmap: %lu\n", argc);
    return _this;
}

// wxSharp::DC::CanGetTextExtent
static napi_value callback_method_wxSharp_DC_CanGetTextExtent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    bool __ret = instance->CanGetTextExtent();

    napi_value __result;
    status = napi_get_boolean(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;
    printf("wxSharp::DC::CanGetTextExtent: %lu\n", argc);
    return _this;
}

// wxSharp::DC::StartDoc
static napi_value callback_method_wxSharp_DC_StartDoc(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool StartDoc(const char* message)
overload0:
    {
        size_t _message_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_message_size);

        char* message = (char*) malloc(_message_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_message_size);
        assert(status == napi_ok);
        auto __arg0 = message;

        bool __ret = instance->StartDoc(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::StartDoc: %lu\n", argc);
    return _this;
}

// wxSharp::DC::EndDoc
static napi_value callback_method_wxSharp_DC_EndDoc(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->EndDoc();
    printf("wxSharp::DC::EndDoc: %lu\n", argc);
    return _this;
}

// wxSharp::DC::StartPage
static napi_value callback_method_wxSharp_DC_StartPage(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->StartPage();
    printf("wxSharp::DC::StartPage: %lu\n", argc);
    return _this;
}

// wxSharp::DC::EndPage
static napi_value callback_method_wxSharp_DC_EndPage(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->EndPage();
    printf("wxSharp::DC::EndPage: %lu\n", argc);
    return _this;
}

// wxSharp::DC::CalcBoundingBox
static napi_value callback_method_wxSharp_DC_CalcBoundingBox(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void CalcBoundingBox(int x, int y)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        instance->CalcBoundingBox(__arg0, __arg1);
    }
    printf("wxSharp::DC::CalcBoundingBox: %lu\n", argc);
    return _this;
}

// wxSharp::DC::ResetBoundingBox
static napi_value callback_method_wxSharp_DC_ResetBoundingBox(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->ResetBoundingBox();
    printf("wxSharp::DC::ResetBoundingBox: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetPen
static napi_value callback_method_wxSharp_DC_SetPen(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetPen(const ::wxSharp::Pen& pen)
overload0:
    {
        wxSharp::Pen* pen_instance;
        status = napi_unwrap(env, _this, (void**) &pen_instance);
        auto &__arg0 = *pen_instance;

        instance->SetPen(__arg0);
    }
    printf("wxSharp::DC::SetPen: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetBrush
static napi_value callback_method_wxSharp_DC_SetBrush(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetBrush(const ::wxSharp::Brush& brush)
overload0:
    {
        wxSharp::Brush* brush_instance;
        status = napi_unwrap(env, _this, (void**) &brush_instance);
        auto &__arg0 = *brush_instance;

        instance->SetBrush(__arg0);
    }
    printf("wxSharp::DC::SetBrush: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetBackground
static napi_value callback_method_wxSharp_DC_SetBackground(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetBackground(const ::wxSharp::Brush& brush)
overload0:
    {
        wxSharp::Brush* brush_instance;
        status = napi_unwrap(env, _this, (void**) &brush_instance);
        auto &__arg0 = *brush_instance;

        instance->SetBackground(__arg0);
    }
    printf("wxSharp::DC::SetBackground: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetTextForeground
static napi_value callback_method_wxSharp_DC_SetTextForeground(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetTextForeground(const ::wxSharp::Color& colour)
overload0:
    {
        wxSharp::Color* colour_instance;
        status = napi_unwrap(env, _this, (void**) &colour_instance);
        auto &__arg0 = *colour_instance;

        instance->SetTextForeground(__arg0);
    }
    printf("wxSharp::DC::SetTextForeground: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetTextBackground
static napi_value callback_method_wxSharp_DC_SetTextBackground(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetTextBackground(const ::wxSharp::Color& colour)
overload0:
    {
        wxSharp::Color* colour_instance;
        status = napi_unwrap(env, _this, (void**) &colour_instance);
        auto &__arg0 = *colour_instance;

        instance->SetTextBackground(__arg0);
    }
    printf("wxSharp::DC::SetTextBackground: %lu\n", argc);
    return _this;
}

// wxSharp::DC::GetMultiLineTextExtent
static napi_value callback_method_wxSharp_DC_GetMultiLineTextExtent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Size GetMultiLineTextExtent(const char* string) const
overload0:
    {
        size_t _string_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_string_size);

        char* string = (char*) malloc(_string_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_string_size);
        assert(status == napi_ok);
        auto __arg0 = string;

        ::wxSharp::Size __ret = instance->GetMultiLineTextExtent(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Size_Size, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::DC::GetMultiLineTextExtent: %lu\n", argc);
    return _this;
}

// wxSharp::DC::Clear
static napi_value callback_method_wxSharp_DC_Clear(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->Clear();
    printf("wxSharp::DC::Clear: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetClippingRegion
static napi_value callback_method_wxSharp_DC_SetClippingRegion(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetClippingRegion(int x, int y, int width, int height)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        int32_t width;
        status = napi_get_value_int32(env, args[2], &width);
        auto __arg2 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[3], &height);
        auto __arg3 = height;

        instance->SetClippingRegion(__arg0, __arg1, __arg2, __arg3);
    }

    // void SetClippingRegion(const ::wxSharp::Point& pt, const ::wxSharp::Size& sz)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg1 = *sz_instance;

        instance->SetClippingRegion(__arg0, __arg1);
    }

    // void SetClippingRegion(const ::wxSharp::Rect& rect)
overload2:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        instance->SetClippingRegion(__arg0);
    }
    printf("wxSharp::DC::SetClippingRegion: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DestroyClippingRegion
static napi_value callback_method_wxSharp_DC_DestroyClippingRegion(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->DestroyClippingRegion();
    printf("wxSharp::DC::DestroyClippingRegion: %lu\n", argc);
    return _this;
}

// wxSharp::DC::GetClippingBox
static napi_value callback_method_wxSharp_DC_GetClippingBox(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool GetClippingBox(::wxSharp::Rect& rect) const
overload0:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        bool __ret = instance->GetClippingBox(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::GetClippingBox: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DeviceToLogicalX
static napi_value callback_method_wxSharp_DC_DeviceToLogicalX(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // int DeviceToLogicalX(int x) const
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int __ret = instance->DeviceToLogicalX(__arg0);

        napi_value __result;
        status = napi_create_int32(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::DeviceToLogicalX: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DeviceToLogicalY
static napi_value callback_method_wxSharp_DC_DeviceToLogicalY(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // int DeviceToLogicalY(int y) const
overload0:
    {
        int32_t y;
        status = napi_get_value_int32(env, args[0], &y);
        auto __arg0 = y;

        int __ret = instance->DeviceToLogicalY(__arg0);

        napi_value __result;
        status = napi_create_int32(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::DeviceToLogicalY: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DeviceToLogicalXRel
static napi_value callback_method_wxSharp_DC_DeviceToLogicalXRel(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // int DeviceToLogicalXRel(int x) const
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int __ret = instance->DeviceToLogicalXRel(__arg0);

        napi_value __result;
        status = napi_create_int32(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::DeviceToLogicalXRel: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DeviceToLogicalYRel
static napi_value callback_method_wxSharp_DC_DeviceToLogicalYRel(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // int DeviceToLogicalYRel(int y) const
overload0:
    {
        int32_t y;
        status = napi_get_value_int32(env, args[0], &y);
        auto __arg0 = y;

        int __ret = instance->DeviceToLogicalYRel(__arg0);

        napi_value __result;
        status = napi_create_int32(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::DeviceToLogicalYRel: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DeviceToLogical
static napi_value callback_method_wxSharp_DC_DeviceToLogical(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Point DeviceToLogical(const ::wxSharp::Point& pt) const
overload0:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        ::wxSharp::Point __ret = instance->DeviceToLogical(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Point_Point, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::Point DeviceToLogical(int x, int y) const
overload1:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        ::wxSharp::Point __ret = instance->DeviceToLogical(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Point_Point, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::DC::DeviceToLogical: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DeviceToLogicalRel
static napi_value callback_method_wxSharp_DC_DeviceToLogicalRel(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Size DeviceToLogicalRel(const ::wxSharp::Size& dim) const
overload0:
    {
        wxSharp::Size* dim_instance;
        status = napi_unwrap(env, _this, (void**) &dim_instance);
        auto &__arg0 = *dim_instance;

        ::wxSharp::Size __ret = instance->DeviceToLogicalRel(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Size_Size, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::Size DeviceToLogicalRel(int x, int y) const
overload1:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        ::wxSharp::Size __ret = instance->DeviceToLogicalRel(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Size_Size, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::DC::DeviceToLogicalRel: %lu\n", argc);
    return _this;
}

// wxSharp::DC::LogicalToDeviceX
static napi_value callback_method_wxSharp_DC_LogicalToDeviceX(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // int LogicalToDeviceX(int x) const
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int __ret = instance->LogicalToDeviceX(__arg0);

        napi_value __result;
        status = napi_create_int32(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::LogicalToDeviceX: %lu\n", argc);
    return _this;
}

// wxSharp::DC::LogicalToDeviceY
static napi_value callback_method_wxSharp_DC_LogicalToDeviceY(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // int LogicalToDeviceY(int y) const
overload0:
    {
        int32_t y;
        status = napi_get_value_int32(env, args[0], &y);
        auto __arg0 = y;

        int __ret = instance->LogicalToDeviceY(__arg0);

        napi_value __result;
        status = napi_create_int32(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::LogicalToDeviceY: %lu\n", argc);
    return _this;
}

// wxSharp::DC::LogicalToDeviceXRel
static napi_value callback_method_wxSharp_DC_LogicalToDeviceXRel(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // int LogicalToDeviceXRel(int x) const
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int __ret = instance->LogicalToDeviceXRel(__arg0);

        napi_value __result;
        status = napi_create_int32(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::LogicalToDeviceXRel: %lu\n", argc);
    return _this;
}

// wxSharp::DC::LogicalToDeviceYRel
static napi_value callback_method_wxSharp_DC_LogicalToDeviceYRel(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // int LogicalToDeviceYRel(int y) const
overload0:
    {
        int32_t y;
        status = napi_get_value_int32(env, args[0], &y);
        auto __arg0 = y;

        int __ret = instance->LogicalToDeviceYRel(__arg0);

        napi_value __result;
        status = napi_create_int32(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::LogicalToDeviceYRel: %lu\n", argc);
    return _this;
}

// wxSharp::DC::LogicalToDevice
static napi_value callback_method_wxSharp_DC_LogicalToDevice(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Point LogicalToDevice(const ::wxSharp::Point& pt) const
overload0:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        ::wxSharp::Point __ret = instance->LogicalToDevice(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Point_Point, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::Point LogicalToDevice(int x, int y) const
overload1:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        ::wxSharp::Point __ret = instance->LogicalToDevice(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Point_Point, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::DC::LogicalToDevice: %lu\n", argc);
    return _this;
}

// wxSharp::DC::LogicalToDeviceRel
static napi_value callback_method_wxSharp_DC_LogicalToDeviceRel(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Size LogicalToDeviceRel(const ::wxSharp::Size& dim) const
overload0:
    {
        wxSharp::Size* dim_instance;
        status = napi_unwrap(env, _this, (void**) &dim_instance);
        auto &__arg0 = *dim_instance;

        ::wxSharp::Size __ret = instance->LogicalToDeviceRel(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Size_Size, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::Size LogicalToDeviceRel(int x, int y) const
overload1:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        ::wxSharp::Size __ret = instance->LogicalToDeviceRel(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Size_Size, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::DC::LogicalToDeviceRel: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetUserScale
static napi_value callback_method_wxSharp_DC_SetUserScale(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_NUMBER(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NUMBER(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetUserScale(double x, double y)
overload0:
    {
        double x;
        status = napi_get_value_double(env, args[0], &x);
        auto __arg0 = x;

        double y;
        status = napi_get_value_double(env, args[1], &y);
        auto __arg1 = y;

        instance->SetUserScale(__arg0, __arg1);
    }
    printf("wxSharp::DC::SetUserScale: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetLogicalScale
static napi_value callback_method_wxSharp_DC_SetLogicalScale(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_NUMBER(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NUMBER(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetLogicalScale(double x, double y)
overload0:
    {
        double x;
        status = napi_get_value_double(env, args[0], &x);
        auto __arg0 = x;

        double y;
        status = napi_get_value_double(env, args[1], &y);
        auto __arg1 = y;

        instance->SetLogicalScale(__arg0, __arg1);
    }
    printf("wxSharp::DC::SetLogicalScale: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetLogicalOrigin
static napi_value callback_method_wxSharp_DC_SetLogicalOrigin(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetLogicalOrigin(int x, int y)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        instance->SetLogicalOrigin(__arg0, __arg1);
    }
    printf("wxSharp::DC::SetLogicalOrigin: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetDeviceOrigin
static napi_value callback_method_wxSharp_DC_SetDeviceOrigin(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetDeviceOrigin(int x, int y)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        instance->SetDeviceOrigin(__arg0, __arg1);
    }
    printf("wxSharp::DC::SetDeviceOrigin: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetAxisOrientation
static napi_value callback_method_wxSharp_DC_SetAxisOrientation(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_BOOL(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetAxisOrientation(bool xLeftRight, bool yBottomUp)
overload0:
    {
        bool xLeftRight;
        status = napi_get_value_bool(env, args[0], &xLeftRight);
        auto __arg0 = (bool)xLeftRight;

        bool yBottomUp;
        status = napi_get_value_bool(env, args[1], &yBottomUp);
        auto __arg1 = (bool)yBottomUp;

        instance->SetAxisOrientation(__arg0, __arg1);
    }
    printf("wxSharp::DC::SetAxisOrientation: %lu\n", argc);
    return _this;
}

// wxSharp::DC::CanUseTransformMatrix
static napi_value callback_method_wxSharp_DC_CanUseTransformMatrix(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    bool __ret = instance->CanUseTransformMatrix();

    napi_value __result;
    status = napi_get_boolean(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;
    printf("wxSharp::DC::CanUseTransformMatrix: %lu\n", argc);
    return _this;
}

// wxSharp::DC::ResetTransformMatrix
static napi_value callback_method_wxSharp_DC_ResetTransformMatrix(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->ResetTransformMatrix();
    printf("wxSharp::DC::ResetTransformMatrix: %lu\n", argc);
    return _this;
}

// wxSharp::DC::SetDeviceLocalOrigin
static napi_value callback_method_wxSharp_DC_SetDeviceLocalOrigin(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetDeviceLocalOrigin(int x, int y)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        instance->SetDeviceLocalOrigin(__arg0, __arg1);
    }
    printf("wxSharp::DC::SetDeviceLocalOrigin: %lu\n", argc);
    return _this;
}

// wxSharp::DC::FloodFill
static napi_value callback_method_wxSharp_DC_FloodFill(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 3 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck4;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[2]))
        goto typecheck5;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload0;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool FloodFill(int x, int y, const ::wxSharp::Color& col, ::wxSharp::FloodFillStyle style)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        wxSharp::Color* col_instance;
        status = napi_unwrap(env, _this, (void**) &col_instance);
        auto &__arg2 = *col_instance;

        int32_t style;
        status = napi_get_value_int32(env, args[3], &style);
        auto __arg3 = (::wxSharp::FloodFillStyle)style;

        bool __ret = instance->FloodFill(__arg0, __arg1, __arg2, __arg3);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool FloodFill(const ::wxSharp::Point& pt, const ::wxSharp::Color& col, ::wxSharp::FloodFillStyle style)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        wxSharp::Color* col_instance;
        status = napi_unwrap(env, _this, (void**) &col_instance);
        auto &__arg1 = *col_instance;

        int32_t style;
        status = napi_get_value_int32(env, args[2], &style);
        auto __arg2 = (::wxSharp::FloodFillStyle)style;

        bool __ret = instance->FloodFill(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::FloodFill: %lu\n", argc);
    return _this;
}

// wxSharp::DC::GradientFillConcentric
static napi_value callback_method_wxSharp_DC_GradientFillConcentric(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 3 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void GradientFillConcentric(const ::wxSharp::Rect& rect, const ::wxSharp::Color& initialColour, const ::wxSharp::Color& destColour)
overload0:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        wxSharp::Color* initialColour_instance;
        status = napi_unwrap(env, _this, (void**) &initialColour_instance);
        auto &__arg1 = *initialColour_instance;

        wxSharp::Color* destColour_instance;
        status = napi_unwrap(env, _this, (void**) &destColour_instance);
        auto &__arg2 = *destColour_instance;

        instance->GradientFillConcentric(__arg0, __arg1, __arg2);
    }

    // void GradientFillConcentric(const ::wxSharp::Rect& rect, const ::wxSharp::Color& initialColour, const ::wxSharp::Color& destColour, const ::wxSharp::Point& circleCenter)
overload1:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        wxSharp::Color* initialColour_instance;
        status = napi_unwrap(env, _this, (void**) &initialColour_instance);
        auto &__arg1 = *initialColour_instance;

        wxSharp::Color* destColour_instance;
        status = napi_unwrap(env, _this, (void**) &destColour_instance);
        auto &__arg2 = *destColour_instance;

        wxSharp::Point* circleCenter_instance;
        status = napi_unwrap(env, _this, (void**) &circleCenter_instance);
        auto &__arg3 = *circleCenter_instance;

        instance->GradientFillConcentric(__arg0, __arg1, __arg2, __arg3);
    }
    printf("wxSharp::DC::GradientFillConcentric: %lu\n", argc);
    return _this;
}

// wxSharp::DC::GradientFillLinear
static napi_value callback_method_wxSharp_DC_GradientFillLinear(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 4 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void GradientFillLinear(const ::wxSharp::Rect& rect, const ::wxSharp::Color& initialColour, const ::wxSharp::Color& destColour, ::wxSharp::Direction nDirection)
overload0:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        wxSharp::Color* initialColour_instance;
        status = napi_unwrap(env, _this, (void**) &initialColour_instance);
        auto &__arg1 = *initialColour_instance;

        wxSharp::Color* destColour_instance;
        status = napi_unwrap(env, _this, (void**) &destColour_instance);
        auto &__arg2 = *destColour_instance;

        int32_t nDirection;
        status = napi_get_value_int32(env, args[3], &nDirection);
        auto __arg3 = (::wxSharp::Direction)nDirection;

        instance->GradientFillLinear(__arg0, __arg1, __arg2, __arg3);
    }
    printf("wxSharp::DC::GradientFillLinear: %lu\n", argc);
    return _this;
}

// wxSharp::DC::GetPixel
static napi_value callback_method_wxSharp_DC_GetPixel(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool GetPixel(int x, int y, ::wxSharp::Color* col) const
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        wxSharp::Color* col_instance;
        status = napi_unwrap(env, _this, (void**) &col_instance);
        auto __arg2 = col_instance;

        bool __ret = instance->GetPixel(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool GetPixel(const ::wxSharp::Point& pt, ::wxSharp::Color* col) const
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        wxSharp::Color* col_instance;
        status = napi_unwrap(env, _this, (void**) &col_instance);
        auto __arg1 = col_instance;

        bool __ret = instance->GetPixel(__arg0, __arg1);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::GetPixel: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawLine
static napi_value callback_method_wxSharp_DC_DrawLine(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawLine(int x1, int y1, int x2, int y2)
overload0:
    {
        int32_t x1;
        status = napi_get_value_int32(env, args[0], &x1);
        auto __arg0 = x1;

        int32_t y1;
        status = napi_get_value_int32(env, args[1], &y1);
        auto __arg1 = y1;

        int32_t x2;
        status = napi_get_value_int32(env, args[2], &x2);
        auto __arg2 = x2;

        int32_t y2;
        status = napi_get_value_int32(env, args[3], &y2);
        auto __arg3 = y2;

        instance->DrawLine(__arg0, __arg1, __arg2, __arg3);
    }

    // void DrawLine(const ::wxSharp::Point& pt1, const ::wxSharp::Point& pt2)
overload1:
    {
        wxSharp::Point* pt1_instance;
        status = napi_unwrap(env, _this, (void**) &pt1_instance);
        auto &__arg0 = *pt1_instance;

        wxSharp::Point* pt2_instance;
        status = napi_unwrap(env, _this, (void**) &pt2_instance);
        auto &__arg1 = *pt2_instance;

        instance->DrawLine(__arg0, __arg1);
    }
    printf("wxSharp::DC::DrawLine: %lu\n", argc);
    return _this;
}

// wxSharp::DC::CrossHair
static napi_value callback_method_wxSharp_DC_CrossHair(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void CrossHair(int x, int y)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        instance->CrossHair(__arg0, __arg1);
    }

    // void CrossHair(const ::wxSharp::Point& pt)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        instance->CrossHair(__arg0);
    }
    printf("wxSharp::DC::CrossHair: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawArc
static napi_value callback_method_wxSharp_DC_DrawArc(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 3 || argc > 6)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck4;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck5;

    goto error;

typecheck4:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck6;

    goto error;

typecheck6:
    if (NAPI_IS_INT32(types[4], args[4]))
        goto typecheck7;

    goto error;

typecheck7:
    if (NAPI_IS_INT32(types[5], args[5]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawArc(int x1, int y1, int x2, int y2, int xc, int yc)
overload0:
    {
        int32_t x1;
        status = napi_get_value_int32(env, args[0], &x1);
        auto __arg0 = x1;

        int32_t y1;
        status = napi_get_value_int32(env, args[1], &y1);
        auto __arg1 = y1;

        int32_t x2;
        status = napi_get_value_int32(env, args[2], &x2);
        auto __arg2 = x2;

        int32_t y2;
        status = napi_get_value_int32(env, args[3], &y2);
        auto __arg3 = y2;

        int32_t xc;
        status = napi_get_value_int32(env, args[4], &xc);
        auto __arg4 = xc;

        int32_t yc;
        status = napi_get_value_int32(env, args[5], &yc);
        auto __arg5 = yc;

        instance->DrawArc(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
    }

    // void DrawArc(const ::wxSharp::Point& pt1, const ::wxSharp::Point& pt2, const ::wxSharp::Point& centre)
overload1:
    {
        wxSharp::Point* pt1_instance;
        status = napi_unwrap(env, _this, (void**) &pt1_instance);
        auto &__arg0 = *pt1_instance;

        wxSharp::Point* pt2_instance;
        status = napi_unwrap(env, _this, (void**) &pt2_instance);
        auto &__arg1 = *pt2_instance;

        wxSharp::Point* centre_instance;
        status = napi_unwrap(env, _this, (void**) &centre_instance);
        auto &__arg2 = *centre_instance;

        instance->DrawArc(__arg0, __arg1, __arg2);
    }
    printf("wxSharp::DC::DrawArc: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawCheckMark
static napi_value callback_method_wxSharp_DC_DrawCheckMark(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawCheckMark(int x, int y, int width, int height)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        int32_t width;
        status = napi_get_value_int32(env, args[2], &width);
        auto __arg2 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[3], &height);
        auto __arg3 = height;

        instance->DrawCheckMark(__arg0, __arg1, __arg2, __arg3);
    }

    // void DrawCheckMark(const ::wxSharp::Rect& rect)
overload1:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        instance->DrawCheckMark(__arg0);
    }
    printf("wxSharp::DC::DrawCheckMark: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawEllipticArc
static napi_value callback_method_wxSharp_DC_DrawEllipticArc(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 4 || argc > 6)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck4;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck5;

    goto error;

typecheck4:
    if (NAPI_IS_NUMBER(types[2]))
        goto typecheck6;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck7;

    goto error;

typecheck6:
    if (NAPI_IS_NUMBER(types[3]))
        goto overload0;

    goto error;

typecheck7:
    if (NAPI_IS_NUMBER(types[4]))
        goto typecheck8;

    goto error;

typecheck8:
    if (NAPI_IS_NUMBER(types[5]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawEllipticArc(int x, int y, int w, int h, double sa, double ea)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        int32_t w;
        status = napi_get_value_int32(env, args[2], &w);
        auto __arg2 = w;

        int32_t h;
        status = napi_get_value_int32(env, args[3], &h);
        auto __arg3 = h;

        double sa;
        status = napi_get_value_double(env, args[4], &sa);
        auto __arg4 = sa;

        double ea;
        status = napi_get_value_double(env, args[5], &ea);
        auto __arg5 = ea;

        instance->DrawEllipticArc(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
    }

    // void DrawEllipticArc(const ::wxSharp::Point& pt, const ::wxSharp::Size& sz, double sa, double ea)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg1 = *sz_instance;

        double sa;
        status = napi_get_value_double(env, args[2], &sa);
        auto __arg2 = sa;

        double ea;
        status = napi_get_value_double(env, args[3], &ea);
        auto __arg3 = ea;

        instance->DrawEllipticArc(__arg0, __arg1, __arg2, __arg3);
    }
    printf("wxSharp::DC::DrawEllipticArc: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawPoint
static napi_value callback_method_wxSharp_DC_DrawPoint(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawPoint(int x, int y)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        instance->DrawPoint(__arg0, __arg1);
    }

    // void DrawPoint(const ::wxSharp::Point& pt)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        instance->DrawPoint(__arg0);
    }
    printf("wxSharp::DC::DrawPoint: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawLines
static napi_value callback_method_wxSharp_DC_DrawLines(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 4 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_ARRAY(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawLines(int n, ::wxSharp::Point points[], int xoffset, int yoffset)
overload0:
    {
        int32_t n;
        status = napi_get_value_int32(env, args[0], &n);
        auto __arg0 = n;

        auto __arg1 = nullptr;
        int32_t xoffset;
        status = napi_get_value_int32(env, args[2], &xoffset);
        auto __arg2 = xoffset;

        int32_t yoffset;
        status = napi_get_value_int32(env, args[3], &yoffset);
        auto __arg3 = yoffset;

        instance->DrawLines(__arg0, __arg1, __arg2, __arg3);
    }
    printf("wxSharp::DC::DrawLines: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawPolygon
static napi_value callback_method_wxSharp_DC_DrawPolygon(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 5 || argc > 5)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_ARRAY(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[4], args[4]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawPolygon(int n, ::wxSharp::Point points[], int xoffset, int yoffset, ::wxSharp::PolygonFillMode fillStyle)
overload0:
    {
        int32_t n;
        status = napi_get_value_int32(env, args[0], &n);
        auto __arg0 = n;

        auto __arg1 = nullptr;
        int32_t xoffset;
        status = napi_get_value_int32(env, args[2], &xoffset);
        auto __arg2 = xoffset;

        int32_t yoffset;
        status = napi_get_value_int32(env, args[3], &yoffset);
        auto __arg3 = yoffset;

        int32_t fillStyle;
        status = napi_get_value_int32(env, args[4], &fillStyle);
        auto __arg4 = (::wxSharp::PolygonFillMode)fillStyle;

        instance->DrawPolygon(__arg0, __arg1, __arg2, __arg3, __arg4);
    }
    printf("wxSharp::DC::DrawPolygon: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawPolyPolygon
static napi_value callback_method_wxSharp_DC_DrawPolyPolygon(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 6 || argc > 6)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_ARRAY(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_ARRAY(types[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[4], args[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[5], args[5]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawPolyPolygon(int n, int count[], ::wxSharp::Point points[], int xoffset, int yoffset, ::wxSharp::PolygonFillMode fillStyle)
overload0:
    {
        int32_t n;
        status = napi_get_value_int32(env, args[0], &n);
        auto __arg0 = n;

        auto __arg1 = nullptr;
        auto __arg2 = nullptr;
        int32_t xoffset;
        status = napi_get_value_int32(env, args[3], &xoffset);
        auto __arg3 = xoffset;

        int32_t yoffset;
        status = napi_get_value_int32(env, args[4], &yoffset);
        auto __arg4 = yoffset;

        int32_t fillStyle;
        status = napi_get_value_int32(env, args[5], &fillStyle);
        auto __arg5 = (::wxSharp::PolygonFillMode)fillStyle;

        instance->DrawPolyPolygon(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
    }
    printf("wxSharp::DC::DrawPolyPolygon: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawRectangle
static napi_value callback_method_wxSharp_DC_DrawRectangle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawRectangle(int x, int y, int width, int height)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        int32_t width;
        status = napi_get_value_int32(env, args[2], &width);
        auto __arg2 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[3], &height);
        auto __arg3 = height;

        instance->DrawRectangle(__arg0, __arg1, __arg2, __arg3);
    }

    // void DrawRectangle(const ::wxSharp::Point& pt, const ::wxSharp::Size& sz)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg1 = *sz_instance;

        instance->DrawRectangle(__arg0, __arg1);
    }

    // void DrawRectangle(const ::wxSharp::Rect& rect)
overload2:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        instance->DrawRectangle(__arg0);
    }
    printf("wxSharp::DC::DrawRectangle: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawRoundedRectangle
static napi_value callback_method_wxSharp_DC_DrawRoundedRectangle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 5)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck3;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck4;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck5;

    goto error;

typecheck3:
    if (NAPI_IS_NUMBER(types[1]))
        goto overload0;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck6;

    goto error;

typecheck5:
    if (NAPI_IS_NUMBER(types[2]))
        goto overload1;

    goto error;

typecheck6:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck7;

    goto error;

typecheck7:
    if (NAPI_IS_NUMBER(types[4]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawRoundedRectangle(int x, int y, int width, int height, double radius)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        int32_t width;
        status = napi_get_value_int32(env, args[2], &width);
        auto __arg2 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[3], &height);
        auto __arg3 = height;

        double radius;
        status = napi_get_value_double(env, args[4], &radius);
        auto __arg4 = radius;

        instance->DrawRoundedRectangle(__arg0, __arg1, __arg2, __arg3, __arg4);
    }

    // void DrawRoundedRectangle(const ::wxSharp::Point& pt, const ::wxSharp::Size& sz, double radius)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg1 = *sz_instance;

        double radius;
        status = napi_get_value_double(env, args[2], &radius);
        auto __arg2 = radius;

        instance->DrawRoundedRectangle(__arg0, __arg1, __arg2);
    }

    // void DrawRoundedRectangle(const ::wxSharp::Rect& r, double radius)
overload2:
    {
        wxSharp::Rect* r_instance;
        status = napi_unwrap(env, _this, (void**) &r_instance);
        auto &__arg0 = *r_instance;

        double radius;
        status = napi_get_value_double(env, args[1], &radius);
        auto __arg1 = radius;

        instance->DrawRoundedRectangle(__arg0, __arg1);
    }
    printf("wxSharp::DC::DrawRoundedRectangle: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawCircle
static napi_value callback_method_wxSharp_DC_DrawCircle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawCircle(int x, int y, int radius)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        int32_t radius;
        status = napi_get_value_int32(env, args[2], &radius);
        auto __arg2 = radius;

        instance->DrawCircle(__arg0, __arg1, __arg2);
    }

    // void DrawCircle(const ::wxSharp::Point& pt, int radius)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        int32_t radius;
        status = napi_get_value_int32(env, args[1], &radius);
        auto __arg1 = radius;

        instance->DrawCircle(__arg0, __arg1);
    }
    printf("wxSharp::DC::DrawCircle: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawEllipse
static napi_value callback_method_wxSharp_DC_DrawEllipse(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawEllipse(int x, int y, int width, int height)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        int32_t width;
        status = napi_get_value_int32(env, args[2], &width);
        auto __arg2 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[3], &height);
        auto __arg3 = height;

        instance->DrawEllipse(__arg0, __arg1, __arg2, __arg3);
    }

    // void DrawEllipse(const ::wxSharp::Point& pt, const ::wxSharp::Size& sz)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg1 = *sz_instance;

        instance->DrawEllipse(__arg0, __arg1);
    }

    // void DrawEllipse(const ::wxSharp::Rect& rect)
overload2:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        instance->DrawEllipse(__arg0);
    }
    printf("wxSharp::DC::DrawEllipse: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawText
static napi_value callback_method_wxSharp_DC_DrawText(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawText(const char* text, int x, int y)
overload0:
    {
        size_t _text_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);

        char* text = (char*) malloc(_text_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);
        assert(status == napi_ok);
        auto __arg0 = text;

        int32_t x;
        status = napi_get_value_int32(env, args[1], &x);
        auto __arg1 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[2], &y);
        auto __arg2 = y;

        instance->DrawText(__arg0, __arg1, __arg2);
    }

    // void DrawText(const char* text, const ::wxSharp::Point& pt)
overload1:
    {
        size_t _text_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);

        char* text = (char*) malloc(_text_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);
        assert(status == napi_ok);
        auto __arg0 = text;

        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg1 = *pt_instance;

        instance->DrawText(__arg0, __arg1);
    }
    printf("wxSharp::DC::DrawText: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawRotatedText
static napi_value callback_method_wxSharp_DC_DrawRotatedText(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 3 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck4;

    goto error;

typecheck3:
    if (NAPI_IS_NUMBER(types[2]))
        goto overload0;

    goto error;

typecheck4:
    if (NAPI_IS_NUMBER(types[3]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawRotatedText(const char* text, int x, int y, double angle)
overload0:
    {
        size_t _text_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);

        char* text = (char*) malloc(_text_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);
        assert(status == napi_ok);
        auto __arg0 = text;

        int32_t x;
        status = napi_get_value_int32(env, args[1], &x);
        auto __arg1 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[2], &y);
        auto __arg2 = y;

        double angle;
        status = napi_get_value_double(env, args[3], &angle);
        auto __arg3 = angle;

        instance->DrawRotatedText(__arg0, __arg1, __arg2, __arg3);
    }

    // void DrawRotatedText(const char* text, const ::wxSharp::Point& pt, double angle)
overload1:
    {
        size_t _text_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);

        char* text = (char*) malloc(_text_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);
        assert(status == napi_ok);
        auto __arg0 = text;

        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg1 = *pt_instance;

        double angle;
        status = napi_get_value_double(env, args[2], &angle);
        auto __arg2 = angle;

        instance->DrawRotatedText(__arg0, __arg1, __arg2);
    }
    printf("wxSharp::DC::DrawRotatedText: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawLabel
static napi_value callback_method_wxSharp_DC_DrawLabel(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 4 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawLabel(const char* text, const ::wxSharp::Rect& rect, int alignment, int indexAccel)
overload0:
    {
        size_t _text_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);

        char* text = (char*) malloc(_text_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);
        assert(status == napi_ok);
        auto __arg0 = text;

        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg1 = *rect_instance;

        int32_t alignment;
        status = napi_get_value_int32(env, args[2], &alignment);
        auto __arg2 = alignment;

        int32_t indexAccel;
        status = napi_get_value_int32(env, args[3], &indexAccel);
        auto __arg3 = indexAccel;

        instance->DrawLabel(__arg0, __arg1, __arg2, __arg3);
    }
    printf("wxSharp::DC::DrawLabel: %lu\n", argc);
    return _this;
}

// wxSharp::DC::Blit
static napi_value callback_method_wxSharp_DC_Blit(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 7 || argc > 11)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck4;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck5;

    goto error;

typecheck4:
    if (NAPI_IS_OBJECT(types[2]))
        goto typecheck6;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck7;

    goto error;

typecheck6:
    if (NAPI_IS_OBJECT(types[3]))
        goto typecheck8;

    goto error;

typecheck7:
    if (NAPI_IS_OBJECT(types[4]))
        goto typecheck9;

    goto error;

typecheck8:
    if (NAPI_IS_INT32(types[4], args[4]))
        goto typecheck10;

    goto error;

typecheck9:
    if (NAPI_IS_INT32(types[5], args[5]))
        goto typecheck11;

    goto error;

typecheck10:
    if (NAPI_IS_BOOL(types[5]))
        goto typecheck12;

    goto error;

typecheck11:
    if (NAPI_IS_INT32(types[6], args[6]))
        goto typecheck13;

    goto error;

typecheck12:
    if (NAPI_IS_OBJECT(types[6]))
        goto overload0;

    goto error;

typecheck13:
    if (NAPI_IS_INT32(types[7], args[7]))
        goto typecheck14;

    goto error;

typecheck14:
    if (NAPI_IS_BOOL(types[8]))
        goto typecheck15;

    goto error;

typecheck15:
    if (NAPI_IS_INT32(types[9], args[9]))
        goto typecheck16;

    goto error;

typecheck16:
    if (NAPI_IS_INT32(types[10], args[10]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Blit(int xdest, int ydest, int width, int height, ::wxSharp::DC* source, int xsrc, int ysrc, ::wxSharp::RasterOperationMode rop, bool useMask, int xsrcMask, int ysrcMask)
overload0:
    {
        int32_t xdest;
        status = napi_get_value_int32(env, args[0], &xdest);
        auto __arg0 = xdest;

        int32_t ydest;
        status = napi_get_value_int32(env, args[1], &ydest);
        auto __arg1 = ydest;

        int32_t width;
        status = napi_get_value_int32(env, args[2], &width);
        auto __arg2 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[3], &height);
        auto __arg3 = height;

        wxSharp::DC* source_instance;
        status = napi_unwrap(env, _this, (void**) &source_instance);
        auto __arg4 = source_instance;

        int32_t xsrc;
        status = napi_get_value_int32(env, args[5], &xsrc);
        auto __arg5 = xsrc;

        int32_t ysrc;
        status = napi_get_value_int32(env, args[6], &ysrc);
        auto __arg6 = ysrc;

        int32_t rop;
        status = napi_get_value_int32(env, args[7], &rop);
        auto __arg7 = (::wxSharp::RasterOperationMode)rop;

        bool useMask;
        status = napi_get_value_bool(env, args[8], &useMask);
        auto __arg8 = (bool)useMask;

        int32_t xsrcMask;
        status = napi_get_value_int32(env, args[9], &xsrcMask);
        auto __arg9 = xsrcMask;

        int32_t ysrcMask;
        status = napi_get_value_int32(env, args[10], &ysrcMask);
        auto __arg10 = ysrcMask;

        bool __ret = instance->Blit(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7, __arg8, __arg9, __arg10);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Blit(const ::wxSharp::Point& destPt, const ::wxSharp::Size& sz, ::wxSharp::DC* source, const ::wxSharp::Point& srcPt, ::wxSharp::RasterOperationMode rop, bool useMask, const ::wxSharp::Point& srcPtMask)
overload1:
    {
        wxSharp::Point* destPt_instance;
        status = napi_unwrap(env, _this, (void**) &destPt_instance);
        auto &__arg0 = *destPt_instance;

        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg1 = *sz_instance;

        wxSharp::DC* source_instance;
        status = napi_unwrap(env, _this, (void**) &source_instance);
        auto __arg2 = source_instance;

        wxSharp::Point* srcPt_instance;
        status = napi_unwrap(env, _this, (void**) &srcPt_instance);
        auto &__arg3 = *srcPt_instance;

        int32_t rop;
        status = napi_get_value_int32(env, args[4], &rop);
        auto __arg4 = (::wxSharp::RasterOperationMode)rop;

        bool useMask;
        status = napi_get_value_bool(env, args[5], &useMask);
        auto __arg5 = (bool)useMask;

        wxSharp::Point* srcPtMask_instance;
        status = napi_unwrap(env, _this, (void**) &srcPtMask_instance);
        auto &__arg6 = *srcPtMask_instance;

        bool __ret = instance->Blit(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::Blit: %lu\n", argc);
    return _this;
}

// wxSharp::DC::StretchBlit
static napi_value callback_method_wxSharp_DC_StretchBlit(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 8 || argc > 13)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck4;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck5;

    goto error;

typecheck4:
    if (NAPI_IS_OBJECT(types[2]))
        goto typecheck6;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck7;

    goto error;

typecheck6:
    if (NAPI_IS_OBJECT(types[3]))
        goto typecheck8;

    goto error;

typecheck7:
    if (NAPI_IS_OBJECT(types[4]))
        goto typecheck9;

    goto error;

typecheck8:
    if (NAPI_IS_OBJECT(types[4]))
        goto typecheck10;

    goto error;

typecheck9:
    if (NAPI_IS_INT32(types[5], args[5]))
        goto typecheck11;

    goto error;

typecheck10:
    if (NAPI_IS_INT32(types[5], args[5]))
        goto typecheck12;

    goto error;

typecheck11:
    if (NAPI_IS_INT32(types[6], args[6]))
        goto typecheck13;

    goto error;

typecheck12:
    if (NAPI_IS_BOOL(types[6]))
        goto typecheck14;

    goto error;

typecheck13:
    if (NAPI_IS_INT32(types[7], args[7]))
        goto typecheck15;

    goto error;

typecheck14:
    if (NAPI_IS_OBJECT(types[7]))
        goto overload0;

    goto error;

typecheck15:
    if (NAPI_IS_INT32(types[8], args[8]))
        goto typecheck16;

    goto error;

typecheck16:
    if (NAPI_IS_INT32(types[9], args[9]))
        goto typecheck17;

    goto error;

typecheck17:
    if (NAPI_IS_BOOL(types[10]))
        goto typecheck18;

    goto error;

typecheck18:
    if (NAPI_IS_INT32(types[11], args[11]))
        goto typecheck19;

    goto error;

typecheck19:
    if (NAPI_IS_INT32(types[12], args[12]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool StretchBlit(int dstX, int dstY, int dstWidth, int dstHeight, ::wxSharp::DC* source, int srcX, int srcY, int srcWidth, int srcHeight, ::wxSharp::RasterOperationMode rop, bool useMask, int srcMaskX, int srcMaskY)
overload0:
    {
        int32_t dstX;
        status = napi_get_value_int32(env, args[0], &dstX);
        auto __arg0 = dstX;

        int32_t dstY;
        status = napi_get_value_int32(env, args[1], &dstY);
        auto __arg1 = dstY;

        int32_t dstWidth;
        status = napi_get_value_int32(env, args[2], &dstWidth);
        auto __arg2 = dstWidth;

        int32_t dstHeight;
        status = napi_get_value_int32(env, args[3], &dstHeight);
        auto __arg3 = dstHeight;

        wxSharp::DC* source_instance;
        status = napi_unwrap(env, _this, (void**) &source_instance);
        auto __arg4 = source_instance;

        int32_t srcX;
        status = napi_get_value_int32(env, args[5], &srcX);
        auto __arg5 = srcX;

        int32_t srcY;
        status = napi_get_value_int32(env, args[6], &srcY);
        auto __arg6 = srcY;

        int32_t srcWidth;
        status = napi_get_value_int32(env, args[7], &srcWidth);
        auto __arg7 = srcWidth;

        int32_t srcHeight;
        status = napi_get_value_int32(env, args[8], &srcHeight);
        auto __arg8 = srcHeight;

        int32_t rop;
        status = napi_get_value_int32(env, args[9], &rop);
        auto __arg9 = (::wxSharp::RasterOperationMode)rop;

        bool useMask;
        status = napi_get_value_bool(env, args[10], &useMask);
        auto __arg10 = (bool)useMask;

        int32_t srcMaskX;
        status = napi_get_value_int32(env, args[11], &srcMaskX);
        auto __arg11 = srcMaskX;

        int32_t srcMaskY;
        status = napi_get_value_int32(env, args[12], &srcMaskY);
        auto __arg12 = srcMaskY;

        bool __ret = instance->StretchBlit(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7, __arg8, __arg9, __arg10, __arg11, __arg12);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool StretchBlit(const ::wxSharp::Point& dstPt, const ::wxSharp::Size& dstSize, ::wxSharp::DC* source, const ::wxSharp::Point& srcPt, const ::wxSharp::Size& srcSize, ::wxSharp::RasterOperationMode rop, bool useMask, const ::wxSharp::Point& srcMaskPt)
overload1:
    {
        wxSharp::Point* dstPt_instance;
        status = napi_unwrap(env, _this, (void**) &dstPt_instance);
        auto &__arg0 = *dstPt_instance;

        wxSharp::Size* dstSize_instance;
        status = napi_unwrap(env, _this, (void**) &dstSize_instance);
        auto &__arg1 = *dstSize_instance;

        wxSharp::DC* source_instance;
        status = napi_unwrap(env, _this, (void**) &source_instance);
        auto __arg2 = source_instance;

        wxSharp::Point* srcPt_instance;
        status = napi_unwrap(env, _this, (void**) &srcPt_instance);
        auto &__arg3 = *srcPt_instance;

        wxSharp::Size* srcSize_instance;
        status = napi_unwrap(env, _this, (void**) &srcSize_instance);
        auto &__arg4 = *srcSize_instance;

        int32_t rop;
        status = napi_get_value_int32(env, args[5], &rop);
        auto __arg5 = (::wxSharp::RasterOperationMode)rop;

        bool useMask;
        status = napi_get_value_bool(env, args[6], &useMask);
        auto __arg6 = (bool)useMask;

        wxSharp::Point* srcMaskPt_instance;
        status = napi_unwrap(env, _this, (void**) &srcMaskPt_instance);
        auto &__arg7 = *srcMaskPt_instance;

        bool __ret = instance->StretchBlit(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::DC::StretchBlit: %lu\n", argc);
    return _this;
}

// wxSharp::DC::DrawSpline
static napi_value callback_method_wxSharp_DC_DrawSpline(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 6)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DC* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    if (NAPI_IS_ARRAY(types[1]))
        goto overload0;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[4], args[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[5], args[5]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DrawSpline(int x1, int y1, int x2, int y2, int x3, int y3)
overload0:
    {
        int32_t x1;
        status = napi_get_value_int32(env, args[0], &x1);
        auto __arg0 = x1;

        int32_t y1;
        status = napi_get_value_int32(env, args[1], &y1);
        auto __arg1 = y1;

        int32_t x2;
        status = napi_get_value_int32(env, args[2], &x2);
        auto __arg2 = x2;

        int32_t y2;
        status = napi_get_value_int32(env, args[3], &y2);
        auto __arg3 = y2;

        int32_t x3;
        status = napi_get_value_int32(env, args[4], &x3);
        auto __arg4 = x3;

        int32_t y3;
        status = napi_get_value_int32(env, args[5], &y3);
        auto __arg5 = y3;

        instance->DrawSpline(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
    }

    // void DrawSpline(int n, ::wxSharp::Point points[])
overload1:
    {
        int32_t n;
        status = napi_get_value_int32(env, args[0], &n);
        auto __arg0 = n;

        auto __arg1 = nullptr;
        instance->DrawSpline(__arg0, __arg1);
    }
    printf("wxSharp::DC::DrawSpline: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_DC(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "CopyAttributes", nullptr, callback_method_wxSharp_DC_CopyAttributes, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "CanDrawBitmap", nullptr, callback_method_wxSharp_DC_CanDrawBitmap, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "CanGetTextExtent", nullptr, callback_method_wxSharp_DC_CanGetTextExtent, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "StartDoc", nullptr, callback_method_wxSharp_DC_StartDoc, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "EndDoc", nullptr, callback_method_wxSharp_DC_EndDoc, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "StartPage", nullptr, callback_method_wxSharp_DC_StartPage, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "EndPage", nullptr, callback_method_wxSharp_DC_EndPage, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "CalcBoundingBox", nullptr, callback_method_wxSharp_DC_CalcBoundingBox, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ResetBoundingBox", nullptr, callback_method_wxSharp_DC_ResetBoundingBox, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetPen", nullptr, callback_method_wxSharp_DC_SetPen, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetBrush", nullptr, callback_method_wxSharp_DC_SetBrush, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetBackground", nullptr, callback_method_wxSharp_DC_SetBackground, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetTextForeground", nullptr, callback_method_wxSharp_DC_SetTextForeground, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetTextBackground", nullptr, callback_method_wxSharp_DC_SetTextBackground, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "GetMultiLineTextExtent", nullptr, callback_method_wxSharp_DC_GetMultiLineTextExtent, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clear", nullptr, callback_method_wxSharp_DC_Clear, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetClippingRegion", nullptr, callback_method_wxSharp_DC_SetClippingRegion, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DestroyClippingRegion", nullptr, callback_method_wxSharp_DC_DestroyClippingRegion, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "GetClippingBox", nullptr, callback_method_wxSharp_DC_GetClippingBox, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DeviceToLogicalX", nullptr, callback_method_wxSharp_DC_DeviceToLogicalX, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DeviceToLogicalY", nullptr, callback_method_wxSharp_DC_DeviceToLogicalY, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DeviceToLogicalXRel", nullptr, callback_method_wxSharp_DC_DeviceToLogicalXRel, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DeviceToLogicalYRel", nullptr, callback_method_wxSharp_DC_DeviceToLogicalYRel, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DeviceToLogical", nullptr, callback_method_wxSharp_DC_DeviceToLogical, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DeviceToLogicalRel", nullptr, callback_method_wxSharp_DC_DeviceToLogicalRel, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "LogicalToDeviceX", nullptr, callback_method_wxSharp_DC_LogicalToDeviceX, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "LogicalToDeviceY", nullptr, callback_method_wxSharp_DC_LogicalToDeviceY, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "LogicalToDeviceXRel", nullptr, callback_method_wxSharp_DC_LogicalToDeviceXRel, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "LogicalToDeviceYRel", nullptr, callback_method_wxSharp_DC_LogicalToDeviceYRel, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "LogicalToDevice", nullptr, callback_method_wxSharp_DC_LogicalToDevice, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "LogicalToDeviceRel", nullptr, callback_method_wxSharp_DC_LogicalToDeviceRel, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetUserScale", nullptr, callback_method_wxSharp_DC_SetUserScale, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetLogicalScale", nullptr, callback_method_wxSharp_DC_SetLogicalScale, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetLogicalOrigin", nullptr, callback_method_wxSharp_DC_SetLogicalOrigin, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetDeviceOrigin", nullptr, callback_method_wxSharp_DC_SetDeviceOrigin, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetAxisOrientation", nullptr, callback_method_wxSharp_DC_SetAxisOrientation, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "CanUseTransformMatrix", nullptr, callback_method_wxSharp_DC_CanUseTransformMatrix, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ResetTransformMatrix", nullptr, callback_method_wxSharp_DC_ResetTransformMatrix, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetDeviceLocalOrigin", nullptr, callback_method_wxSharp_DC_SetDeviceLocalOrigin, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "FloodFill", nullptr, callback_method_wxSharp_DC_FloodFill, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "GradientFillConcentric", nullptr, callback_method_wxSharp_DC_GradientFillConcentric, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "GradientFillLinear", nullptr, callback_method_wxSharp_DC_GradientFillLinear, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "GetPixel", nullptr, callback_method_wxSharp_DC_GetPixel, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawLine", nullptr, callback_method_wxSharp_DC_DrawLine, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "CrossHair", nullptr, callback_method_wxSharp_DC_CrossHair, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawArc", nullptr, callback_method_wxSharp_DC_DrawArc, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawCheckMark", nullptr, callback_method_wxSharp_DC_DrawCheckMark, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawEllipticArc", nullptr, callback_method_wxSharp_DC_DrawEllipticArc, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawPoint", nullptr, callback_method_wxSharp_DC_DrawPoint, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawLines", nullptr, callback_method_wxSharp_DC_DrawLines, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawPolygon", nullptr, callback_method_wxSharp_DC_DrawPolygon, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawPolyPolygon", nullptr, callback_method_wxSharp_DC_DrawPolyPolygon, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawRectangle", nullptr, callback_method_wxSharp_DC_DrawRectangle, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawRoundedRectangle", nullptr, callback_method_wxSharp_DC_DrawRoundedRectangle, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawCircle", nullptr, callback_method_wxSharp_DC_DrawCircle, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawEllipse", nullptr, callback_method_wxSharp_DC_DrawEllipse, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawText", nullptr, callback_method_wxSharp_DC_DrawText, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawRotatedText", nullptr, callback_method_wxSharp_DC_DrawRotatedText, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawLabel", nullptr, callback_method_wxSharp_DC_DrawLabel, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Blit", nullptr, callback_method_wxSharp_DC_Blit, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "StretchBlit", nullptr, callback_method_wxSharp_DC_StretchBlit, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DrawSpline", nullptr, callback_method_wxSharp_DC_DrawSpline, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "DC", NAPI_AUTO_LENGTH, callback_method_wxSharp_DC_DC, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_DC_DC);
    assert(status == napi_ok);

    return constructor;
}

void register_wxsharp_dc(napi_env env, napi_value exports)
{
    napi_value value;

    value = register_enum_wxSharp_RasterOperationMode(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "RasterOperationMode", value));

    value = register_enum_wxSharp_MappingMode(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "MappingMode", value));

    value = register_enum_wxSharp_FloodFillStyle(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "FloodFillStyle", value));

    value = register_class_wxSharp_FontMetrics(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "FontMetrics", value));

    value = register_class_wxSharp_DC(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "DC", value));
}
