// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <wxsharp/event.h>
#include <node/node_api.h>
#include <assert.h>
#include <stdio.h>
#include "NAPIHelpers.h"

extern napi_ref ctor_wxSharp_Point_Point;
extern napi_ref ctor_wxSharp_Rect_Rect;
extern napi_ref ctor_wxSharp_GraphicsContext_GraphicsContext;
extern napi_ref ctor_wxSharp_GraphicsPath_GraphicsPath;
extern napi_ref ctor_wxSharp_GraphicsMatrix_GraphicsMatrix;
extern napi_ref ctor_wxSharp_GraphicsPen_GraphicsPen;
extern napi_ref ctor_wxSharp_GraphicsBrush_GraphicsBrush;
extern napi_ref ctor_wxSharp_GraphicsFont_GraphicsFont;
extern napi_ref ctor_wxSharp_GraphicsBitmap_GraphicsBitmap;
extern napi_ref ctor_wxSharp_Color_Color;
extern napi_ref ctor_wxSharp_SizerItem_SizerItem;
extern napi_ref ctor_wxSharp_Size_Size;
extern napi_ref ctor_wxSharp_Window_Window;
extern napi_ref ctor_wxSharp_VisualAttributes_VisualAttributes;

static napi_value register_enum_wxSharp_EventCategory(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // UI
    napi_value i_0;
    status = napi_create_uint32(env, 1, &i_0);
    assert(status == napi_ok);

    // USER_INPUT
    napi_value i_1;
    status = napi_create_uint32(env, 2, &i_1);
    assert(status == napi_ok);

    // SOCKET
    napi_value i_2;
    status = napi_create_uint32(env, 4, &i_2);
    assert(status == napi_ok);

    // TIMER
    napi_value i_3;
    status = napi_create_uint32(env, 8, &i_3);
    assert(status == napi_ok);

    // THREAD
    napi_value i_4;
    status = napi_create_uint32(env, 16, &i_4);
    assert(status == napi_ok);

    // UNKNOWN
    napi_value i_5;
    status = napi_create_uint32(env, 32, &i_5);
    assert(status == napi_ok);

    // CLIPBOARD
    napi_value i_6;
    status = napi_create_uint32(env, 64, &i_6);
    assert(status == napi_ok);

    // NATIVE_EVENTS
    napi_value i_7;
    status = napi_create_uint32(env, 3, &i_7);
    assert(status == napi_ok);

    // ALL
    napi_value i_8;
    status = napi_create_uint32(env, 127, &i_8);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "UI", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "USER_INPUT", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "SOCKET", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "TIMER", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr },
        { "THREAD", nullptr, nullptr, nullptr, nullptr, i_4, attributes, nullptr },
        { "UNKNOWN", nullptr, nullptr, nullptr, nullptr, i_5, attributes, nullptr },
        { "CLIPBOARD", nullptr, nullptr, nullptr, nullptr, i_6, attributes, nullptr },
        { "NATIVE_EVENTS", nullptr, nullptr, nullptr, nullptr, i_7, attributes, nullptr },
        { "ALL", nullptr, nullptr, nullptr, nullptr, i_8, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_IdleMode(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // PROCESS_ALL
    napi_value i_0;
    status = napi_create_uint32(env, 0, &i_0);
    assert(status == napi_ok);

    // PROCESS_SPECIFIED
    napi_value i_1;
    status = napi_create_uint32(env, 1, &i_1);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "PROCESS_ALL", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "PROCESS_SPECIFIED", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_MouseWheelAxis(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // VERTICAL
    napi_value i_0;
    status = napi_create_uint32(env, 0, &i_0);
    assert(status == napi_ok);

    // HORIZONTAL
    napi_value i_1;
    status = napi_create_uint32(env, 1, &i_1);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "VERTICAL", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "HORIZONTAL", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_UpdateUIMode(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // PROCESS_ALL
    napi_value i_0;
    status = napi_create_uint32(env, 0, &i_0);
    assert(status == napi_ok);

    // PROCESS_SPECIFIED
    napi_value i_1;
    status = napi_create_uint32(env, 1, &i_1);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "PROCESS_ALL", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "PROCESS_SPECIFIED", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_EventPropagation(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // NONE
    napi_value i_0;
    status = napi_create_uint32(env, 0, &i_0);
    assert(status == napi_ok);

    // MAX
    napi_value i_1;
    status = napi_create_uint32(env, 2147483647, &i_1);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "NONE", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "MAX", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_JoystickButton(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // BUTTON_ANY
    napi_value i_0;
    status = napi_create_int32(env, -1, &i_0);
    assert(status == napi_ok);

    // BUTTON1
    napi_value i_1;
    status = napi_create_int32(env, 1, &i_1);
    assert(status == napi_ok);

    // BUTTON2
    napi_value i_2;
    status = napi_create_int32(env, 2, &i_2);
    assert(status == napi_ok);

    // BUTTON3
    napi_value i_3;
    status = napi_create_int32(env, 4, &i_3);
    assert(status == napi_ok);

    // BUTTON4
    napi_value i_4;
    status = napi_create_int32(env, 8, &i_4);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "BUTTON_ANY", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "BUTTON1", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "BUTTON2", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "BUTTON3", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr },
        { "BUTTON4", nullptr, nullptr, nullptr, nullptr, i_4, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_JoystickId(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // JOYSTICK1
    napi_value i_0;
    status = napi_create_uint32(env, 0, &i_0);
    assert(status == napi_ok);

    // JOYSTICK2
    napi_value i_1;
    status = napi_create_uint32(env, 1, &i_1);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "JOYSTICK1", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "JOYSTICK2", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_KeyCategoryFlags(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // CATEGORY_ARROW
    napi_value i_0;
    status = napi_create_uint32(env, 1, &i_0);
    assert(status == napi_ok);

    // CATEGORY_PAGING
    napi_value i_1;
    status = napi_create_uint32(env, 2, &i_1);
    assert(status == napi_ok);

    // CATEGORY_JUMP
    napi_value i_2;
    status = napi_create_uint32(env, 4, &i_2);
    assert(status == napi_ok);

    // CATEGORY_TAB
    napi_value i_3;
    status = napi_create_uint32(env, 8, &i_3);
    assert(status == napi_ok);

    // CATEGORY_CUT
    napi_value i_4;
    status = napi_create_uint32(env, 16, &i_4);
    assert(status == napi_ok);

    // CATEGORY_NAVIGATION
    napi_value i_5;
    status = napi_create_uint32(env, 7, &i_5);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "CATEGORY_ARROW", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "CATEGORY_PAGING", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "CATEGORY_JUMP", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "CATEGORY_TAB", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr },
        { "CATEGORY_CUT", nullptr, nullptr, nullptr, nullptr, i_4, attributes, nullptr },
        { "CATEGORY_NAVIGATION", nullptr, nullptr, nullptr, nullptr, i_5, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static void dtor_wxSharp_Event_Event(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_Event_Event;

// wxSharp::Event::Event
static napi_value callback_method_wxSharp_Event_Event(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Event* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // Event(int winid, int commandType)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        int32_t commandType;
        status = napi_get_value_int32(env, args[1], &commandType);
        auto __arg1 = commandType;

        instance = new wxSharp::Event(__arg0, __arg1);
    }

    // Event
overload1:
    {
        wxSharp::Event* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::Event(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_Event_Event, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::Event::Event: %lu\n", argc);
    return _this;
}

// wxSharp::Event::Skip
static napi_value callback_method_wxSharp_Event_Skip(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Event* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void Skip(bool skip)
overload0:
    {
        bool skip;
        status = napi_get_value_bool(env, args[0], &skip);
        auto __arg0 = (bool)skip;

        instance->Skip(__arg0);
    }
    printf("wxSharp::Event::Skip: %lu\n", argc);
    return _this;
}

// wxSharp::Event::Clone
static napi_value callback_method_wxSharp_Event_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::Event* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::Event::Clone: %lu\n", argc);
    return _this;
}

// wxSharp::Event::ShouldPropagate
static napi_value callback_method_wxSharp_Event_ShouldPropagate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::Event* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    bool __ret = instance->ShouldPropagate();

    napi_value __result;
    status = napi_get_boolean(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;
    printf("wxSharp::Event::ShouldPropagate: %lu\n", argc);
    return _this;
}

// wxSharp::Event::ResumePropagation
static napi_value callback_method_wxSharp_Event_ResumePropagation(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Event* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void ResumePropagation(int propagationLevel)
overload0:
    {
        int32_t propagationLevel;
        status = napi_get_value_int32(env, args[0], &propagationLevel);
        auto __arg0 = propagationLevel;

        instance->ResumePropagation(__arg0);
    }
    printf("wxSharp::Event::ResumePropagation: %lu\n", argc);
    return _this;
}

// wxSharp::Event::WasProcessed
static napi_value callback_method_wxSharp_Event_WasProcessed(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::Event* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    bool __ret = instance->WasProcessed();

    napi_value __result;
    status = napi_get_boolean(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;
    printf("wxSharp::Event::WasProcessed: %lu\n", argc);
    return _this;
}

// wxSharp::Event::SetWillBeProcessedAgain
static napi_value callback_method_wxSharp_Event_SetWillBeProcessedAgain(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::Event* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->SetWillBeProcessedAgain();
    printf("wxSharp::Event::SetWillBeProcessedAgain: %lu\n", argc);
    return _this;
}

// wxSharp::Event::ShouldProcessOnlyIn
static napi_value callback_method_wxSharp_Event_ShouldProcessOnlyIn(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Event* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ShouldProcessOnlyIn(::wxSharp::EvtHandler* h) const
overload0:
    {
        wxSharp::EvtHandler* h_instance;
        status = napi_unwrap(env, _this, (void**) &h_instance);
        auto __arg0 = h_instance;

        bool __ret = instance->ShouldProcessOnlyIn(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Event::ShouldProcessOnlyIn: %lu\n", argc);
    return _this;
}

// wxSharp::Event::DidntHonourProcessOnlyIn
static napi_value callback_method_wxSharp_Event_DidntHonourProcessOnlyIn(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::Event* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->DidntHonourProcessOnlyIn();
    printf("wxSharp::Event::DidntHonourProcessOnlyIn: %lu\n", argc);
    return _this;
}

// wxSharp::Event::set_m_callbackUserData
static napi_value callback_method_wxSharp_Event_set_m_callbackUserData(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Event* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_callbackUserData(::wxSharp::Object* value)
overload0:
    {
        wxSharp::Object* value_instance;
        status = napi_unwrap(env, _this, (void**) &value_instance);
        auto __arg0 = value_instance;

        instance->set_m_callbackUserData(__arg0);
    }
    printf("wxSharp::Event::set_m_callbackUserData: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_Event(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Skip", nullptr, callback_method_wxSharp_Event_Skip, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_Event_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ShouldPropagate", nullptr, callback_method_wxSharp_Event_ShouldPropagate, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ResumePropagation", nullptr, callback_method_wxSharp_Event_ResumePropagation, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "WasProcessed", nullptr, callback_method_wxSharp_Event_WasProcessed, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetWillBeProcessedAgain", nullptr, callback_method_wxSharp_Event_SetWillBeProcessedAgain, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ShouldProcessOnlyIn", nullptr, callback_method_wxSharp_Event_ShouldProcessOnlyIn, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DidntHonourProcessOnlyIn", nullptr, callback_method_wxSharp_Event_DidntHonourProcessOnlyIn, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_callbackUserData", nullptr, callback_method_wxSharp_Event_set_m_callbackUserData, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "Event", NAPI_AUTO_LENGTH, callback_method_wxSharp_Event_Event, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_Event_Event);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_PropagateOnce_PropagateOnce(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_PropagateOnce_PropagateOnce;

// wxSharp::PropagateOnce::PropagateOnce
static napi_value callback_method_wxSharp_PropagateOnce_PropagateOnce(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::PropagateOnce* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // PropagateOnce(::wxSharp::Event& event, ::wxSharp::EvtHandler* handler)
overload0:
    {
        wxSharp::Event* event_instance;
        status = napi_unwrap(env, _this, (void**) &event_instance);
        auto &__arg0 = *event_instance;

        wxSharp::EvtHandler* handler_instance;
        status = napi_unwrap(env, _this, (void**) &handler_instance);
        auto __arg1 = handler_instance;

        instance = new wxSharp::PropagateOnce(__arg0, __arg1);
    }

    // PropagateOnce
overload1:
    {
        wxSharp::PropagateOnce* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::PropagateOnce(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_PropagateOnce_PropagateOnce, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::PropagateOnce::PropagateOnce: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_PropagateOnce(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }

    };

    napi_value constructor;
    status = napi_define_class(env, "PropagateOnce", NAPI_AUTO_LENGTH, callback_method_wxSharp_PropagateOnce_PropagateOnce, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_PropagateOnce_PropagateOnce);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_IdleEvent_IdleEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_IdleEvent_IdleEvent;

// wxSharp::IdleEvent::IdleEvent
static napi_value callback_method_wxSharp_IdleEvent_IdleEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::IdleEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // IdleEvent()
overload0:
    {
        instance = new wxSharp::IdleEvent();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_IdleEvent_IdleEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::IdleEvent::IdleEvent: %lu\n", argc);
    return _this;
}

// wxSharp::IdleEvent::RequestMore
static napi_value callback_method_wxSharp_IdleEvent_RequestMore(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::IdleEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void RequestMore(bool needMore)
overload0:
    {
        bool needMore;
        status = napi_get_value_bool(env, args[0], &needMore);
        auto __arg0 = (bool)needMore;

        instance->RequestMore(__arg0);
    }
    printf("wxSharp::IdleEvent::RequestMore: %lu\n", argc);
    return _this;
}

// wxSharp::IdleEvent::Clone
static napi_value callback_method_wxSharp_IdleEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::IdleEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::IdleEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_IdleEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "RequestMore", nullptr, callback_method_wxSharp_IdleEvent_RequestMore, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_IdleEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "IdleEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_IdleEvent_IdleEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_IdleEvent_IdleEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_ThreadEvent_ThreadEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_ThreadEvent_ThreadEvent;

// wxSharp::ThreadEvent::ThreadEvent
static napi_value callback_method_wxSharp_ThreadEvent_ThreadEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ThreadEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ThreadEvent(int eventType, int id)
overload0:
    {
        int32_t eventType;
        status = napi_get_value_int32(env, args[0], &eventType);
        auto __arg0 = eventType;

        int32_t id;
        status = napi_get_value_int32(env, args[1], &id);
        auto __arg1 = id;

        instance = new wxSharp::ThreadEvent(__arg0, __arg1);
    }

    // ThreadEvent
overload1:
    {
        wxSharp::ThreadEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::ThreadEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_ThreadEvent_ThreadEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::ThreadEvent::ThreadEvent: %lu\n", argc);
    return _this;
}

// wxSharp::ThreadEvent::Clone
static napi_value callback_method_wxSharp_ThreadEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::ThreadEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::ThreadEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_ThreadEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_ThreadEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "ThreadEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_ThreadEvent_ThreadEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_ThreadEvent_ThreadEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_AsyncMethodCallEvent_AsyncMethodCallEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_AsyncMethodCallEvent_AsyncMethodCallEvent;

// wxSharp::AsyncMethodCallEvent::AsyncMethodCallEvent
static napi_value callback_method_wxSharp_AsyncMethodCallEvent_AsyncMethodCallEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::AsyncMethodCallEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // AsyncMethodCallEvent(::wxSharp::Object* object)
overload0:
    {
        wxSharp::Object* object_instance;
        status = napi_unwrap(env, _this, (void**) &object_instance);
        auto __arg0 = object_instance;

        instance = new wxSharp::AsyncMethodCallEvent(__arg0);
    }

    // AsyncMethodCallEvent
overload1:
    {
        wxSharp::AsyncMethodCallEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::AsyncMethodCallEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_AsyncMethodCallEvent_AsyncMethodCallEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::AsyncMethodCallEvent::AsyncMethodCallEvent: %lu\n", argc);
    return _this;
}

// wxSharp::AsyncMethodCallEvent::Execute
static napi_value callback_method_wxSharp_AsyncMethodCallEvent_Execute(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::AsyncMethodCallEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->Execute();
    printf("wxSharp::AsyncMethodCallEvent::Execute: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_AsyncMethodCallEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Execute", nullptr, callback_method_wxSharp_AsyncMethodCallEvent_Execute, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "AsyncMethodCallEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_AsyncMethodCallEvent_AsyncMethodCallEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_AsyncMethodCallEvent_AsyncMethodCallEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_CommandEvent_CommandEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_CommandEvent_CommandEvent;

// wxSharp::CommandEvent::CommandEvent
static napi_value callback_method_wxSharp_CommandEvent_CommandEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::CommandEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // CommandEvent(int commandType, int winid)
overload0:
    {
        int32_t commandType;
        status = napi_get_value_int32(env, args[0], &commandType);
        auto __arg0 = commandType;

        int32_t winid;
        status = napi_get_value_int32(env, args[1], &winid);
        auto __arg1 = winid;

        instance = new wxSharp::CommandEvent(__arg0, __arg1);
    }

    // CommandEvent
overload1:
    {
        wxSharp::CommandEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::CommandEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_CommandEvent_CommandEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::CommandEvent::CommandEvent: %lu\n", argc);
    return _this;
}

// wxSharp::CommandEvent::Clone
static napi_value callback_method_wxSharp_CommandEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::CommandEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::CommandEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_CommandEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_CommandEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "CommandEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_CommandEvent_CommandEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_CommandEvent_CommandEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_NotifyEvent_NotifyEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_NotifyEvent_NotifyEvent;

// wxSharp::NotifyEvent::NotifyEvent
static napi_value callback_method_wxSharp_NotifyEvent_NotifyEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::NotifyEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // NotifyEvent(int commandType, int winid)
overload0:
    {
        int32_t commandType;
        status = napi_get_value_int32(env, args[0], &commandType);
        auto __arg0 = commandType;

        int32_t winid;
        status = napi_get_value_int32(env, args[1], &winid);
        auto __arg1 = winid;

        instance = new wxSharp::NotifyEvent(__arg0, __arg1);
    }

    // NotifyEvent
overload1:
    {
        wxSharp::NotifyEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::NotifyEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_NotifyEvent_NotifyEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::NotifyEvent::NotifyEvent: %lu\n", argc);
    return _this;
}

// wxSharp::NotifyEvent::Veto
static napi_value callback_method_wxSharp_NotifyEvent_Veto(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::NotifyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->Veto();
    printf("wxSharp::NotifyEvent::Veto: %lu\n", argc);
    return _this;
}

// wxSharp::NotifyEvent::Allow
static napi_value callback_method_wxSharp_NotifyEvent_Allow(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::NotifyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->Allow();
    printf("wxSharp::NotifyEvent::Allow: %lu\n", argc);
    return _this;
}

// wxSharp::NotifyEvent::Clone
static napi_value callback_method_wxSharp_NotifyEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::NotifyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::NotifyEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_NotifyEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Veto", nullptr, callback_method_wxSharp_NotifyEvent_Veto, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Allow", nullptr, callback_method_wxSharp_NotifyEvent_Allow, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_NotifyEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NotifyEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_NotifyEvent_NotifyEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_NotifyEvent_NotifyEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_ScrollEvent_ScrollEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_ScrollEvent_ScrollEvent;

// wxSharp::ScrollEvent::ScrollEvent
static napi_value callback_method_wxSharp_ScrollEvent_ScrollEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ScrollEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ScrollEvent(int commandType, int winid, int pos, int orient)
overload0:
    {
        int32_t commandType;
        status = napi_get_value_int32(env, args[0], &commandType);
        auto __arg0 = commandType;

        int32_t winid;
        status = napi_get_value_int32(env, args[1], &winid);
        auto __arg1 = winid;

        int32_t pos;
        status = napi_get_value_int32(env, args[2], &pos);
        auto __arg2 = pos;

        int32_t orient;
        status = napi_get_value_int32(env, args[3], &orient);
        auto __arg3 = orient;

        instance = new wxSharp::ScrollEvent(__arg0, __arg1, __arg2, __arg3);
    }

    // ScrollEvent
overload1:
    {
        wxSharp::ScrollEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::ScrollEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_ScrollEvent_ScrollEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::ScrollEvent::ScrollEvent: %lu\n", argc);
    return _this;
}

// wxSharp::ScrollEvent::Clone
static napi_value callback_method_wxSharp_ScrollEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::ScrollEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::ScrollEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_ScrollEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_ScrollEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "ScrollEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_ScrollEvent_ScrollEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_ScrollEvent_ScrollEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_ScrollWinEvent_ScrollWinEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_ScrollWinEvent_ScrollWinEvent;

// wxSharp::ScrollWinEvent::ScrollWinEvent
static napi_value callback_method_wxSharp_ScrollWinEvent_ScrollWinEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ScrollWinEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ScrollWinEvent(int commandType, int pos, int orient)
overload0:
    {
        int32_t commandType;
        status = napi_get_value_int32(env, args[0], &commandType);
        auto __arg0 = commandType;

        int32_t pos;
        status = napi_get_value_int32(env, args[1], &pos);
        auto __arg1 = pos;

        int32_t orient;
        status = napi_get_value_int32(env, args[2], &orient);
        auto __arg2 = orient;

        instance = new wxSharp::ScrollWinEvent(__arg0, __arg1, __arg2);
    }

    // ScrollWinEvent
overload1:
    {
        wxSharp::ScrollWinEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::ScrollWinEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_ScrollWinEvent_ScrollWinEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::ScrollWinEvent::ScrollWinEvent: %lu\n", argc);
    return _this;
}

// wxSharp::ScrollWinEvent::Clone
static napi_value callback_method_wxSharp_ScrollWinEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::ScrollWinEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::ScrollWinEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_ScrollWinEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_ScrollWinEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "ScrollWinEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_ScrollWinEvent_ScrollWinEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_ScrollWinEvent_ScrollWinEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_MouseEvent_MouseEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_MouseEvent_MouseEvent;

// wxSharp::MouseEvent::MouseEvent
static napi_value callback_method_wxSharp_MouseEvent_MouseEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // MouseEvent(int mouseType)
overload0:
    {
        int32_t mouseType;
        status = napi_get_value_int32(env, args[0], &mouseType);
        auto __arg0 = mouseType;

        instance = new wxSharp::MouseEvent(__arg0);
    }

    // MouseEvent
overload1:
    {
        wxSharp::MouseEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::MouseEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_MouseEvent_MouseEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::MouseEvent::MouseEvent: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::ButtonDown
static napi_value callback_method_wxSharp_MouseEvent_ButtonDown(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ButtonDown(int but) const
overload0:
    {
        int32_t but;
        status = napi_get_value_int32(env, args[0], &but);
        auto __arg0 = but;

        bool __ret = instance->ButtonDown(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::MouseEvent::ButtonDown: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::ButtonDClick
static napi_value callback_method_wxSharp_MouseEvent_ButtonDClick(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ButtonDClick(int but) const
overload0:
    {
        int32_t but;
        status = napi_get_value_int32(env, args[0], &but);
        auto __arg0 = but;

        bool __ret = instance->ButtonDClick(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::MouseEvent::ButtonDClick: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::ButtonUp
static napi_value callback_method_wxSharp_MouseEvent_ButtonUp(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ButtonUp(int but) const
overload0:
    {
        int32_t but;
        status = napi_get_value_int32(env, args[0], &but);
        auto __arg0 = but;

        bool __ret = instance->ButtonUp(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::MouseEvent::ButtonUp: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::Button
static napi_value callback_method_wxSharp_MouseEvent_Button(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Button(int but) const
overload0:
    {
        int32_t but;
        status = napi_get_value_int32(env, args[0], &but);
        auto __arg0 = but;

        bool __ret = instance->Button(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::MouseEvent::Button: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::RightDown
static napi_value callback_method_wxSharp_MouseEvent_RightDown(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    bool __ret = instance->RightDown();

    napi_value __result;
    status = napi_get_boolean(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;
    printf("wxSharp::MouseEvent::RightDown: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::RightUp
static napi_value callback_method_wxSharp_MouseEvent_RightUp(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    bool __ret = instance->RightUp();

    napi_value __result;
    status = napi_get_boolean(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;
    printf("wxSharp::MouseEvent::RightUp: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::RightDClick
static napi_value callback_method_wxSharp_MouseEvent_RightDClick(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    bool __ret = instance->RightDClick();

    napi_value __result;
    status = napi_get_boolean(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;
    printf("wxSharp::MouseEvent::RightDClick: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::Magnify
static napi_value callback_method_wxSharp_MouseEvent_Magnify(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    bool __ret = instance->Magnify();

    napi_value __result;
    status = napi_get_boolean(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;
    printf("wxSharp::MouseEvent::Magnify: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::GetLogicalPosition
static napi_value callback_method_wxSharp_MouseEvent_GetLogicalPosition(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Point GetLogicalPosition(const ::wxSharp::DC& dc) const
overload0:
    {
        wxSharp::DC* dc_instance;
        status = napi_unwrap(env, _this, (void**) &dc_instance);
        auto &__arg0 = *dc_instance;

        ::wxSharp::Point __ret = instance->GetLogicalPosition(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Point_Point, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::MouseEvent::GetLogicalPosition: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::Clone
static napi_value callback_method_wxSharp_MouseEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::MouseEvent::Clone: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::set_m_clickCount
static napi_value callback_method_wxSharp_MouseEvent_set_m_clickCount(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_clickCount(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_m_clickCount(__arg0);
    }
    printf("wxSharp::MouseEvent::set_m_clickCount: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::set_m_wheelAxis
static napi_value callback_method_wxSharp_MouseEvent_set_m_wheelAxis(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_wheelAxis(::wxSharp::MouseWheelAxis value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = (::wxSharp::MouseWheelAxis)value;

        instance->set_m_wheelAxis(__arg0);
    }
    printf("wxSharp::MouseEvent::set_m_wheelAxis: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::set_m_wheelRotation
static napi_value callback_method_wxSharp_MouseEvent_set_m_wheelRotation(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_wheelRotation(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_m_wheelRotation(__arg0);
    }
    printf("wxSharp::MouseEvent::set_m_wheelRotation: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::set_m_wheelDelta
static napi_value callback_method_wxSharp_MouseEvent_set_m_wheelDelta(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_wheelDelta(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_m_wheelDelta(__arg0);
    }
    printf("wxSharp::MouseEvent::set_m_wheelDelta: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::set_m_wheelInverted
static napi_value callback_method_wxSharp_MouseEvent_set_m_wheelInverted(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_wheelInverted(bool value)
overload0:
    {
        bool value;
        status = napi_get_value_bool(env, args[0], &value);
        auto __arg0 = (bool)value;

        instance->set_m_wheelInverted(__arg0);
    }
    printf("wxSharp::MouseEvent::set_m_wheelInverted: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::set_m_linesPerAction
static napi_value callback_method_wxSharp_MouseEvent_set_m_linesPerAction(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_linesPerAction(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_m_linesPerAction(__arg0);
    }
    printf("wxSharp::MouseEvent::set_m_linesPerAction: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::set_m_columnsPerAction
static napi_value callback_method_wxSharp_MouseEvent_set_m_columnsPerAction(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_columnsPerAction(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_m_columnsPerAction(__arg0);
    }
    printf("wxSharp::MouseEvent::set_m_columnsPerAction: %lu\n", argc);
    return _this;
}

// wxSharp::MouseEvent::set_m_magnification
static napi_value callback_method_wxSharp_MouseEvent_set_m_magnification(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_NUMBER(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_magnification(float value)
overload0:
    {
        double value;
        status = napi_get_value_double(env, args[0], &value);
        auto __arg0 = (float)value;

        instance->set_m_magnification(__arg0);
    }
    printf("wxSharp::MouseEvent::set_m_magnification: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_MouseEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "ButtonDown", nullptr, callback_method_wxSharp_MouseEvent_ButtonDown, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ButtonDClick", nullptr, callback_method_wxSharp_MouseEvent_ButtonDClick, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ButtonUp", nullptr, callback_method_wxSharp_MouseEvent_ButtonUp, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Button", nullptr, callback_method_wxSharp_MouseEvent_Button, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "RightDown", nullptr, callback_method_wxSharp_MouseEvent_RightDown, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "RightUp", nullptr, callback_method_wxSharp_MouseEvent_RightUp, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "RightDClick", nullptr, callback_method_wxSharp_MouseEvent_RightDClick, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Magnify", nullptr, callback_method_wxSharp_MouseEvent_Magnify, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "GetLogicalPosition", nullptr, callback_method_wxSharp_MouseEvent_GetLogicalPosition, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_MouseEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_clickCount", nullptr, callback_method_wxSharp_MouseEvent_set_m_clickCount, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_wheelAxis", nullptr, callback_method_wxSharp_MouseEvent_set_m_wheelAxis, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_wheelRotation", nullptr, callback_method_wxSharp_MouseEvent_set_m_wheelRotation, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_wheelDelta", nullptr, callback_method_wxSharp_MouseEvent_set_m_wheelDelta, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_wheelInverted", nullptr, callback_method_wxSharp_MouseEvent_set_m_wheelInverted, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_linesPerAction", nullptr, callback_method_wxSharp_MouseEvent_set_m_linesPerAction, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_columnsPerAction", nullptr, callback_method_wxSharp_MouseEvent_set_m_columnsPerAction, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_magnification", nullptr, callback_method_wxSharp_MouseEvent_set_m_magnification, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "MouseEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_MouseEvent_MouseEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_MouseEvent_MouseEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_SetCursorEvent_SetCursorEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_SetCursorEvent_SetCursorEvent;

// wxSharp::SetCursorEvent::SetCursorEvent
static napi_value callback_method_wxSharp_SetCursorEvent_SetCursorEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SetCursorEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // SetCursorEvent(int x, int y)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        instance = new wxSharp::SetCursorEvent(__arg0, __arg1);
    }

    // SetCursorEvent
overload1:
    {
        wxSharp::SetCursorEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::SetCursorEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_SetCursorEvent_SetCursorEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::SetCursorEvent::SetCursorEvent: %lu\n", argc);
    return _this;
}

// wxSharp::SetCursorEvent::Clone
static napi_value callback_method_wxSharp_SetCursorEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::SetCursorEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::SetCursorEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_SetCursorEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_SetCursorEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "SetCursorEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_SetCursorEvent_SetCursorEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_SetCursorEvent_SetCursorEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_GestureEvent_GestureEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_GestureEvent_GestureEvent;

// wxSharp::GestureEvent::GestureEvent
static napi_value callback_method_wxSharp_GestureEvent_GestureEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::GestureEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // GestureEvent(int winid, int type)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        int32_t type;
        status = napi_get_value_int32(env, args[1], &type);
        auto __arg1 = type;

        instance = new wxSharp::GestureEvent(__arg0, __arg1);
    }

    // GestureEvent
overload1:
    {
        wxSharp::GestureEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::GestureEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_GestureEvent_GestureEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::GestureEvent::GestureEvent: %lu\n", argc);
    return _this;
}

// wxSharp::GestureEvent::SetPosition
static napi_value callback_method_wxSharp_GestureEvent_SetPosition(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::GestureEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetPosition(const ::wxSharp::Point& pos)
overload0:
    {
        wxSharp::Point* pos_instance;
        status = napi_unwrap(env, _this, (void**) &pos_instance);
        auto &__arg0 = *pos_instance;

        instance->SetPosition(__arg0);
    }
    printf("wxSharp::GestureEvent::SetPosition: %lu\n", argc);
    return _this;
}

// wxSharp::GestureEvent::SetGestureStart
static napi_value callback_method_wxSharp_GestureEvent_SetGestureStart(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::GestureEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetGestureStart(bool isStart)
overload0:
    {
        bool isStart;
        status = napi_get_value_bool(env, args[0], &isStart);
        auto __arg0 = (bool)isStart;

        instance->SetGestureStart(__arg0);
    }
    printf("wxSharp::GestureEvent::SetGestureStart: %lu\n", argc);
    return _this;
}

// wxSharp::GestureEvent::SetGestureEnd
static napi_value callback_method_wxSharp_GestureEvent_SetGestureEnd(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::GestureEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetGestureEnd(bool isEnd)
overload0:
    {
        bool isEnd;
        status = napi_get_value_bool(env, args[0], &isEnd);
        auto __arg0 = (bool)isEnd;

        instance->SetGestureEnd(__arg0);
    }
    printf("wxSharp::GestureEvent::SetGestureEnd: %lu\n", argc);
    return _this;
}

// wxSharp::GestureEvent::Clone
static napi_value callback_method_wxSharp_GestureEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::GestureEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::GestureEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_GestureEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "SetPosition", nullptr, callback_method_wxSharp_GestureEvent_SetPosition, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetGestureStart", nullptr, callback_method_wxSharp_GestureEvent_SetGestureStart, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetGestureEnd", nullptr, callback_method_wxSharp_GestureEvent_SetGestureEnd, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_GestureEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "GestureEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_GestureEvent_GestureEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_GestureEvent_GestureEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_PanGestureEvent_PanGestureEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_PanGestureEvent_PanGestureEvent;

// wxSharp::PanGestureEvent::PanGestureEvent
static napi_value callback_method_wxSharp_PanGestureEvent_PanGestureEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::PanGestureEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // PanGestureEvent(int winid)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        instance = new wxSharp::PanGestureEvent(__arg0);
    }

    // PanGestureEvent
overload1:
    {
        wxSharp::PanGestureEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::PanGestureEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_PanGestureEvent_PanGestureEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::PanGestureEvent::PanGestureEvent: %lu\n", argc);
    return _this;
}

// wxSharp::PanGestureEvent::Clone
static napi_value callback_method_wxSharp_PanGestureEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::PanGestureEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::PanGestureEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_PanGestureEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_PanGestureEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "PanGestureEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_PanGestureEvent_PanGestureEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_PanGestureEvent_PanGestureEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_ZoomGestureEvent_ZoomGestureEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_ZoomGestureEvent_ZoomGestureEvent;

// wxSharp::ZoomGestureEvent::ZoomGestureEvent
static napi_value callback_method_wxSharp_ZoomGestureEvent_ZoomGestureEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ZoomGestureEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ZoomGestureEvent(int winid)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        instance = new wxSharp::ZoomGestureEvent(__arg0);
    }

    // ZoomGestureEvent
overload1:
    {
        wxSharp::ZoomGestureEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::ZoomGestureEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_ZoomGestureEvent_ZoomGestureEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::ZoomGestureEvent::ZoomGestureEvent: %lu\n", argc);
    return _this;
}

// wxSharp::ZoomGestureEvent::Clone
static napi_value callback_method_wxSharp_ZoomGestureEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::ZoomGestureEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::ZoomGestureEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_ZoomGestureEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_ZoomGestureEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "ZoomGestureEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_ZoomGestureEvent_ZoomGestureEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_ZoomGestureEvent_ZoomGestureEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_RotateGestureEvent_RotateGestureEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_RotateGestureEvent_RotateGestureEvent;

// wxSharp::RotateGestureEvent::RotateGestureEvent
static napi_value callback_method_wxSharp_RotateGestureEvent_RotateGestureEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::RotateGestureEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // RotateGestureEvent(int winid)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        instance = new wxSharp::RotateGestureEvent(__arg0);
    }

    // RotateGestureEvent
overload1:
    {
        wxSharp::RotateGestureEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::RotateGestureEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_RotateGestureEvent_RotateGestureEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::RotateGestureEvent::RotateGestureEvent: %lu\n", argc);
    return _this;
}

// wxSharp::RotateGestureEvent::Clone
static napi_value callback_method_wxSharp_RotateGestureEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::RotateGestureEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::RotateGestureEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_RotateGestureEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_RotateGestureEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "RotateGestureEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_RotateGestureEvent_RotateGestureEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_RotateGestureEvent_RotateGestureEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_TwoFingerTapEvent_TwoFingerTapEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_TwoFingerTapEvent_TwoFingerTapEvent;

// wxSharp::TwoFingerTapEvent::TwoFingerTapEvent
static napi_value callback_method_wxSharp_TwoFingerTapEvent_TwoFingerTapEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::TwoFingerTapEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // TwoFingerTapEvent(int winid)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        instance = new wxSharp::TwoFingerTapEvent(__arg0);
    }

    // TwoFingerTapEvent
overload1:
    {
        wxSharp::TwoFingerTapEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::TwoFingerTapEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_TwoFingerTapEvent_TwoFingerTapEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::TwoFingerTapEvent::TwoFingerTapEvent: %lu\n", argc);
    return _this;
}

// wxSharp::TwoFingerTapEvent::Clone
static napi_value callback_method_wxSharp_TwoFingerTapEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::TwoFingerTapEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::TwoFingerTapEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_TwoFingerTapEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_TwoFingerTapEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "TwoFingerTapEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_TwoFingerTapEvent_TwoFingerTapEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_TwoFingerTapEvent_TwoFingerTapEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_LongPressEvent_LongPressEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_LongPressEvent_LongPressEvent;

// wxSharp::LongPressEvent::LongPressEvent
static napi_value callback_method_wxSharp_LongPressEvent_LongPressEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::LongPressEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // LongPressEvent(int winid)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        instance = new wxSharp::LongPressEvent(__arg0);
    }

    // LongPressEvent
overload1:
    {
        wxSharp::LongPressEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::LongPressEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_LongPressEvent_LongPressEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::LongPressEvent::LongPressEvent: %lu\n", argc);
    return _this;
}

// wxSharp::LongPressEvent::Clone
static napi_value callback_method_wxSharp_LongPressEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::LongPressEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::LongPressEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_LongPressEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_LongPressEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "LongPressEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_LongPressEvent_LongPressEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_LongPressEvent_LongPressEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_PressAndTapEvent_PressAndTapEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_PressAndTapEvent_PressAndTapEvent;

// wxSharp::PressAndTapEvent::PressAndTapEvent
static napi_value callback_method_wxSharp_PressAndTapEvent_PressAndTapEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::PressAndTapEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // PressAndTapEvent(int winid)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        instance = new wxSharp::PressAndTapEvent(__arg0);
    }

    // PressAndTapEvent
overload1:
    {
        wxSharp::PressAndTapEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::PressAndTapEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_PressAndTapEvent_PressAndTapEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::PressAndTapEvent::PressAndTapEvent: %lu\n", argc);
    return _this;
}

// wxSharp::PressAndTapEvent::Clone
static napi_value callback_method_wxSharp_PressAndTapEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::PressAndTapEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::PressAndTapEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_PressAndTapEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_PressAndTapEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "PressAndTapEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_PressAndTapEvent_PressAndTapEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_PressAndTapEvent_PressAndTapEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_KeyEvent_KeyEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_KeyEvent_KeyEvent;

// wxSharp::KeyEvent::KeyEvent
static napi_value callback_method_wxSharp_KeyEvent_KeyEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::KeyEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // KeyEvent(int keyType)
overload0:
    {
        int32_t keyType;
        status = napi_get_value_int32(env, args[0], &keyType);
        auto __arg0 = keyType;

        instance = new wxSharp::KeyEvent(__arg0);
    }

    // KeyEvent(int eventType, const ::wxSharp::KeyEvent& evt)
overload1:
    {
        int32_t eventType;
        status = napi_get_value_int32(env, args[0], &eventType);
        auto __arg0 = eventType;

        wxSharp::KeyEvent* evt_instance;
        status = napi_unwrap(env, _this, (void**) &evt_instance);
        auto &__arg1 = *evt_instance;

        instance = new wxSharp::KeyEvent(__arg0, __arg1);
    }

    // KeyEvent
overload2:
    {
        wxSharp::KeyEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::KeyEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_KeyEvent_KeyEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::KeyEvent::KeyEvent: %lu\n", argc);
    return _this;
}

// wxSharp::KeyEvent::IsKeyInCategory
static napi_value callback_method_wxSharp_KeyEvent_IsKeyInCategory(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::KeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool IsKeyInCategory(int category) const
overload0:
    {
        int32_t category;
        status = napi_get_value_int32(env, args[0], &category);
        auto __arg0 = category;

        bool __ret = instance->IsKeyInCategory(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::KeyEvent::IsKeyInCategory: %lu\n", argc);
    return _this;
}

// wxSharp::KeyEvent::DoAllowNextEvent
static napi_value callback_method_wxSharp_KeyEvent_DoAllowNextEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::KeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->DoAllowNextEvent();
    printf("wxSharp::KeyEvent::DoAllowNextEvent: %lu\n", argc);
    return _this;
}

// wxSharp::KeyEvent::Clone
static napi_value callback_method_wxSharp_KeyEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::KeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::KeyEvent::Clone: %lu\n", argc);
    return _this;
}

// wxSharp::KeyEvent::set_m_x
static napi_value callback_method_wxSharp_KeyEvent_set_m_x(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::KeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_x(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_m_x(__arg0);
    }
    printf("wxSharp::KeyEvent::set_m_x: %lu\n", argc);
    return _this;
}

// wxSharp::KeyEvent::set_m_y
static napi_value callback_method_wxSharp_KeyEvent_set_m_y(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::KeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_y(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_m_y(__arg0);
    }
    printf("wxSharp::KeyEvent::set_m_y: %lu\n", argc);
    return _this;
}

// wxSharp::KeyEvent::set_m_keyCode
static napi_value callback_method_wxSharp_KeyEvent_set_m_keyCode(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::KeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_keyCode(long value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_m_keyCode(__arg0);
    }
    printf("wxSharp::KeyEvent::set_m_keyCode: %lu\n", argc);
    return _this;
}

// wxSharp::KeyEvent::set_m_uniChar
static napi_value callback_method_wxSharp_KeyEvent_set_m_uniChar(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::KeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_uniChar(wchar_t value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = (wchar_t)value;

        instance->set_m_uniChar(__arg0);
    }
    printf("wxSharp::KeyEvent::set_m_uniChar: %lu\n", argc);
    return _this;
}

// wxSharp::KeyEvent::set_m_rawCode
static napi_value callback_method_wxSharp_KeyEvent_set_m_rawCode(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::KeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_UINT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_rawCode(unsigned int value)
overload0:
    {
        uint32_t value;
        status = napi_get_value_uint32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_m_rawCode(__arg0);
    }
    printf("wxSharp::KeyEvent::set_m_rawCode: %lu\n", argc);
    return _this;
}

// wxSharp::KeyEvent::set_m_rawFlags
static napi_value callback_method_wxSharp_KeyEvent_set_m_rawFlags(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::KeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_UINT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_rawFlags(unsigned int value)
overload0:
    {
        uint32_t value;
        status = napi_get_value_uint32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_m_rawFlags(__arg0);
    }
    printf("wxSharp::KeyEvent::set_m_rawFlags: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_KeyEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "IsKeyInCategory", nullptr, callback_method_wxSharp_KeyEvent_IsKeyInCategory, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DoAllowNextEvent", nullptr, callback_method_wxSharp_KeyEvent_DoAllowNextEvent, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_KeyEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_x", nullptr, callback_method_wxSharp_KeyEvent_set_m_x, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_y", nullptr, callback_method_wxSharp_KeyEvent_set_m_y, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_keyCode", nullptr, callback_method_wxSharp_KeyEvent_set_m_keyCode, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_uniChar", nullptr, callback_method_wxSharp_KeyEvent_set_m_uniChar, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_rawCode", nullptr, callback_method_wxSharp_KeyEvent_set_m_rawCode, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_rawFlags", nullptr, callback_method_wxSharp_KeyEvent_set_m_rawFlags, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "KeyEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_KeyEvent_KeyEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_KeyEvent_KeyEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_SizeEvent_SizeEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_SizeEvent_SizeEvent;

// wxSharp::SizeEvent::SizeEvent
static napi_value callback_method_wxSharp_SizeEvent_SizeEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizeEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // SizeEvent()
overload0:
    {
        instance = new wxSharp::SizeEvent();
    }

    // SizeEvent(const ::wxSharp::Size& sz, int winid)
overload1:
    {
        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg0 = *sz_instance;

        int32_t winid;
        status = napi_get_value_int32(env, args[1], &winid);
        auto __arg1 = winid;

        instance = new wxSharp::SizeEvent(__arg0, __arg1);
    }

    // SizeEvent(const ::wxSharp::Rect& rect, int id)
overload2:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        int32_t id;
        status = napi_get_value_int32(env, args[1], &id);
        auto __arg1 = id;

        instance = new wxSharp::SizeEvent(__arg0, __arg1);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_SizeEvent_SizeEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::SizeEvent::SizeEvent: %lu\n", argc);
    return _this;
}

// wxSharp::SizeEvent::Clone
static napi_value callback_method_wxSharp_SizeEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::SizeEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::SizeEvent::Clone: %lu\n", argc);
    return _this;
}

// wxSharp::SizeEvent::set_m_size
static napi_value callback_method_wxSharp_SizeEvent_set_m_size(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizeEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_size(::wxSharp::Size value)
overload0:
    {
        wxSharp::Size* value_instance;
        status = napi_unwrap(env, _this, (void**) &value_instance);
        auto __arg0 = *value_instance;

        instance->set_m_size(__arg0);
    }
    printf("wxSharp::SizeEvent::set_m_size: %lu\n", argc);
    return _this;
}

// wxSharp::SizeEvent::set_m_rect
static napi_value callback_method_wxSharp_SizeEvent_set_m_rect(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizeEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_rect(::wxSharp::Rect value)
overload0:
    {
        wxSharp::Rect* value_instance;
        status = napi_unwrap(env, _this, (void**) &value_instance);
        auto __arg0 = *value_instance;

        instance->set_m_rect(__arg0);
    }
    printf("wxSharp::SizeEvent::set_m_rect: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_SizeEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_SizeEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_size", nullptr, callback_method_wxSharp_SizeEvent_set_m_size, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_rect", nullptr, callback_method_wxSharp_SizeEvent_set_m_rect, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "SizeEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_SizeEvent_SizeEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_SizeEvent_SizeEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_MoveEvent_MoveEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_MoveEvent_MoveEvent;

// wxSharp::MoveEvent::MoveEvent
static napi_value callback_method_wxSharp_MoveEvent_MoveEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MoveEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // MoveEvent()
overload0:
    {
        instance = new wxSharp::MoveEvent();
    }

    // MoveEvent(const ::wxSharp::Point& pos, int winid)
overload1:
    {
        wxSharp::Point* pos_instance;
        status = napi_unwrap(env, _this, (void**) &pos_instance);
        auto &__arg0 = *pos_instance;

        int32_t winid;
        status = napi_get_value_int32(env, args[1], &winid);
        auto __arg1 = winid;

        instance = new wxSharp::MoveEvent(__arg0, __arg1);
    }

    // MoveEvent(const ::wxSharp::Rect& rect, int id)
overload2:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        int32_t id;
        status = napi_get_value_int32(env, args[1], &id);
        auto __arg1 = id;

        instance = new wxSharp::MoveEvent(__arg0, __arg1);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_MoveEvent_MoveEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::MoveEvent::MoveEvent: %lu\n", argc);
    return _this;
}

// wxSharp::MoveEvent::Clone
static napi_value callback_method_wxSharp_MoveEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::MoveEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::MoveEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_MoveEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_MoveEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "MoveEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_MoveEvent_MoveEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_MoveEvent_MoveEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_PaintEvent_PaintEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_PaintEvent_PaintEvent;

// wxSharp::PaintEvent::PaintEvent
static napi_value callback_method_wxSharp_PaintEvent_PaintEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::PaintEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // PaintEvent
overload0:
    {
        wxSharp::PaintEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::PaintEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_PaintEvent_PaintEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::PaintEvent::PaintEvent: %lu\n", argc);
    return _this;
}

// wxSharp::PaintEvent::Clone
static napi_value callback_method_wxSharp_PaintEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::PaintEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::PaintEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_PaintEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_PaintEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "PaintEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_PaintEvent_PaintEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_PaintEvent_PaintEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_NcPaintEvent_NcPaintEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_NcPaintEvent_NcPaintEvent;

// wxSharp::NcPaintEvent::NcPaintEvent
static napi_value callback_method_wxSharp_NcPaintEvent_NcPaintEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::NcPaintEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // NcPaintEvent
overload0:
    {
        wxSharp::NcPaintEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::NcPaintEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_NcPaintEvent_NcPaintEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::NcPaintEvent::NcPaintEvent: %lu\n", argc);
    return _this;
}

// wxSharp::NcPaintEvent::Clone
static napi_value callback_method_wxSharp_NcPaintEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::NcPaintEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::NcPaintEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_NcPaintEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_NcPaintEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NcPaintEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_NcPaintEvent_NcPaintEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_NcPaintEvent_NcPaintEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_EraseEvent_EraseEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_EraseEvent_EraseEvent;

// wxSharp::EraseEvent::EraseEvent
static napi_value callback_method_wxSharp_EraseEvent_EraseEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::EraseEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // EraseEvent(int Id, ::wxSharp::DC* dc)
overload0:
    {
        int32_t Id;
        status = napi_get_value_int32(env, args[0], &Id);
        auto __arg0 = Id;

        wxSharp::DC* dc_instance;
        status = napi_unwrap(env, _this, (void**) &dc_instance);
        auto __arg1 = dc_instance;

        instance = new wxSharp::EraseEvent(__arg0, __arg1);
    }

    // EraseEvent
overload1:
    {
        wxSharp::EraseEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::EraseEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_EraseEvent_EraseEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::EraseEvent::EraseEvent: %lu\n", argc);
    return _this;
}

// wxSharp::EraseEvent::Clone
static napi_value callback_method_wxSharp_EraseEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::EraseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::EraseEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_EraseEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_EraseEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "EraseEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_EraseEvent_EraseEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_EraseEvent_EraseEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_FocusEvent_FocusEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_FocusEvent_FocusEvent;

// wxSharp::FocusEvent::FocusEvent
static napi_value callback_method_wxSharp_FocusEvent_FocusEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FocusEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // FocusEvent(int type, int winid)
overload0:
    {
        int32_t type;
        status = napi_get_value_int32(env, args[0], &type);
        auto __arg0 = type;

        int32_t winid;
        status = napi_get_value_int32(env, args[1], &winid);
        auto __arg1 = winid;

        instance = new wxSharp::FocusEvent(__arg0, __arg1);
    }

    // FocusEvent
overload1:
    {
        wxSharp::FocusEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::FocusEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_FocusEvent_FocusEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::FocusEvent::FocusEvent: %lu\n", argc);
    return _this;
}

// wxSharp::FocusEvent::Clone
static napi_value callback_method_wxSharp_FocusEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::FocusEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::FocusEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_FocusEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_FocusEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "FocusEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_FocusEvent_FocusEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_FocusEvent_FocusEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_ChildFocusEvent_ChildFocusEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_ChildFocusEvent_ChildFocusEvent;

// wxSharp::ChildFocusEvent::ChildFocusEvent
static napi_value callback_method_wxSharp_ChildFocusEvent_ChildFocusEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ChildFocusEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ChildFocusEvent(::wxSharp::Window* win)
overload0:
    {
        wxSharp::Window* win_instance;
        status = napi_unwrap(env, _this, (void**) &win_instance);
        auto __arg0 = win_instance;

        instance = new wxSharp::ChildFocusEvent(__arg0);
    }

    // ChildFocusEvent
overload1:
    {
        wxSharp::ChildFocusEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::ChildFocusEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_ChildFocusEvent_ChildFocusEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::ChildFocusEvent::ChildFocusEvent: %lu\n", argc);
    return _this;
}

// wxSharp::ChildFocusEvent::Clone
static napi_value callback_method_wxSharp_ChildFocusEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::ChildFocusEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::ChildFocusEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_ChildFocusEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_ChildFocusEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "ChildFocusEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_ChildFocusEvent_ChildFocusEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_ChildFocusEvent_ChildFocusEvent);
    assert(status == napi_ok);

    return constructor;
}

enum class Reason : unsigned int
{
    Mouse = 0,
    Unknown = 1
};

static void dtor_wxSharp_ActivateEvent_ActivateEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_ActivateEvent_ActivateEvent;

// wxSharp::ActivateEvent::ActivateEvent
static napi_value callback_method_wxSharp_ActivateEvent_ActivateEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ActivateEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_BOOL(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ActivateEvent(int type, bool active, int Id, ::wxSharp::ActivateEvent::Reason activationReason)
overload0:
    {
        int32_t type;
        status = napi_get_value_int32(env, args[0], &type);
        auto __arg0 = type;

        bool active;
        status = napi_get_value_bool(env, args[1], &active);
        auto __arg1 = (bool)active;

        int32_t Id;
        status = napi_get_value_int32(env, args[2], &Id);
        auto __arg2 = Id;

        int32_t activationReason;
        status = napi_get_value_int32(env, args[3], &activationReason);
        auto __arg3 = (::wxSharp::ActivateEvent::Reason)activationReason;

        instance = new wxSharp::ActivateEvent(__arg0, __arg1, __arg2, __arg3);
    }

    // ActivateEvent
overload1:
    {
        wxSharp::ActivateEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::ActivateEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_ActivateEvent_ActivateEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::ActivateEvent::ActivateEvent: %lu\n", argc);
    return _this;
}

// wxSharp::ActivateEvent::Clone
static napi_value callback_method_wxSharp_ActivateEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::ActivateEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::ActivateEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_ActivateEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_ActivateEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "ActivateEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_ActivateEvent_ActivateEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_ActivateEvent_ActivateEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_InitDialogEvent_InitDialogEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_InitDialogEvent_InitDialogEvent;

// wxSharp::InitDialogEvent::InitDialogEvent
static napi_value callback_method_wxSharp_InitDialogEvent_InitDialogEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::InitDialogEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // InitDialogEvent(int Id)
overload0:
    {
        int32_t Id;
        status = napi_get_value_int32(env, args[0], &Id);
        auto __arg0 = Id;

        instance = new wxSharp::InitDialogEvent(__arg0);
    }

    // InitDialogEvent
overload1:
    {
        wxSharp::InitDialogEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::InitDialogEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_InitDialogEvent_InitDialogEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::InitDialogEvent::InitDialogEvent: %lu\n", argc);
    return _this;
}

// wxSharp::InitDialogEvent::Clone
static napi_value callback_method_wxSharp_InitDialogEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::InitDialogEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::InitDialogEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_InitDialogEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_InitDialogEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "InitDialogEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_InitDialogEvent_InitDialogEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_InitDialogEvent_InitDialogEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_MenuEvent_MenuEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_MenuEvent_MenuEvent;

// wxSharp::MenuEvent::MenuEvent
static napi_value callback_method_wxSharp_MenuEvent_MenuEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MenuEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // MenuEvent
overload0:
    {
        wxSharp::MenuEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::MenuEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_MenuEvent_MenuEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::MenuEvent::MenuEvent: %lu\n", argc);
    return _this;
}

// wxSharp::MenuEvent::Clone
static napi_value callback_method_wxSharp_MenuEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::MenuEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::MenuEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_MenuEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_MenuEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "MenuEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_MenuEvent_MenuEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_MenuEvent_MenuEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_CloseEvent_CloseEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_CloseEvent_CloseEvent;

// wxSharp::CloseEvent::CloseEvent
static napi_value callback_method_wxSharp_CloseEvent_CloseEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::CloseEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // CloseEvent(int type, int winid)
overload0:
    {
        int32_t type;
        status = napi_get_value_int32(env, args[0], &type);
        auto __arg0 = type;

        int32_t winid;
        status = napi_get_value_int32(env, args[1], &winid);
        auto __arg1 = winid;

        instance = new wxSharp::CloseEvent(__arg0, __arg1);
    }

    // CloseEvent
overload1:
    {
        wxSharp::CloseEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::CloseEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_CloseEvent_CloseEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::CloseEvent::CloseEvent: %lu\n", argc);
    return _this;
}

// wxSharp::CloseEvent::SetCanVeto
static napi_value callback_method_wxSharp_CloseEvent_SetCanVeto(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::CloseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetCanVeto(bool canVeto)
overload0:
    {
        bool canVeto;
        status = napi_get_value_bool(env, args[0], &canVeto);
        auto __arg0 = (bool)canVeto;

        instance->SetCanVeto(__arg0);
    }
    printf("wxSharp::CloseEvent::SetCanVeto: %lu\n", argc);
    return _this;
}

// wxSharp::CloseEvent::CanVeto
static napi_value callback_method_wxSharp_CloseEvent_CanVeto(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::CloseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    bool __ret = instance->CanVeto();

    napi_value __result;
    status = napi_get_boolean(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;
    printf("wxSharp::CloseEvent::CanVeto: %lu\n", argc);
    return _this;
}

// wxSharp::CloseEvent::Clone
static napi_value callback_method_wxSharp_CloseEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::CloseEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::CloseEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_CloseEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "SetCanVeto", nullptr, callback_method_wxSharp_CloseEvent_SetCanVeto, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "CanVeto", nullptr, callback_method_wxSharp_CloseEvent_CanVeto, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_CloseEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "CloseEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_CloseEvent_CloseEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_CloseEvent_CloseEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_ShowEvent_ShowEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_ShowEvent_ShowEvent;

// wxSharp::ShowEvent::ShowEvent
static napi_value callback_method_wxSharp_ShowEvent_ShowEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ShowEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_BOOL(types[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ShowEvent(int winid, bool show)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        bool show;
        status = napi_get_value_bool(env, args[1], &show);
        auto __arg1 = (bool)show;

        instance = new wxSharp::ShowEvent(__arg0, __arg1);
    }

    // ShowEvent
overload1:
    {
        wxSharp::ShowEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::ShowEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_ShowEvent_ShowEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::ShowEvent::ShowEvent: %lu\n", argc);
    return _this;
}

// wxSharp::ShowEvent::SetShow
static napi_value callback_method_wxSharp_ShowEvent_SetShow(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ShowEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetShow(bool show)
overload0:
    {
        bool show;
        status = napi_get_value_bool(env, args[0], &show);
        auto __arg0 = (bool)show;

        instance->SetShow(__arg0);
    }
    printf("wxSharp::ShowEvent::SetShow: %lu\n", argc);
    return _this;
}

// wxSharp::ShowEvent::Clone
static napi_value callback_method_wxSharp_ShowEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::ShowEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::ShowEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_ShowEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "SetShow", nullptr, callback_method_wxSharp_ShowEvent_SetShow, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_ShowEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "ShowEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_ShowEvent_ShowEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_ShowEvent_ShowEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_IconizeEvent_IconizeEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_IconizeEvent_IconizeEvent;

// wxSharp::IconizeEvent::IconizeEvent
static napi_value callback_method_wxSharp_IconizeEvent_IconizeEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::IconizeEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_BOOL(types[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // IconizeEvent(int winid, bool iconized)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        bool iconized;
        status = napi_get_value_bool(env, args[1], &iconized);
        auto __arg1 = (bool)iconized;

        instance = new wxSharp::IconizeEvent(__arg0, __arg1);
    }

    // IconizeEvent
overload1:
    {
        wxSharp::IconizeEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::IconizeEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_IconizeEvent_IconizeEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::IconizeEvent::IconizeEvent: %lu\n", argc);
    return _this;
}

// wxSharp::IconizeEvent::Clone
static napi_value callback_method_wxSharp_IconizeEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::IconizeEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::IconizeEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_IconizeEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_IconizeEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "IconizeEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_IconizeEvent_IconizeEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_IconizeEvent_IconizeEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_MaximizeEvent_MaximizeEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_MaximizeEvent_MaximizeEvent;

// wxSharp::MaximizeEvent::MaximizeEvent
static napi_value callback_method_wxSharp_MaximizeEvent_MaximizeEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MaximizeEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // MaximizeEvent(int winid)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        instance = new wxSharp::MaximizeEvent(__arg0);
    }

    // MaximizeEvent
overload1:
    {
        wxSharp::MaximizeEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::MaximizeEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_MaximizeEvent_MaximizeEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::MaximizeEvent::MaximizeEvent: %lu\n", argc);
    return _this;
}

// wxSharp::MaximizeEvent::Clone
static napi_value callback_method_wxSharp_MaximizeEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::MaximizeEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::MaximizeEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_MaximizeEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_MaximizeEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "MaximizeEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_MaximizeEvent_MaximizeEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_MaximizeEvent_MaximizeEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_JoystickEvent_JoystickEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_JoystickEvent_JoystickEvent;

// wxSharp::JoystickEvent::JoystickEvent
static napi_value callback_method_wxSharp_JoystickEvent_JoystickEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::JoystickEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // JoystickEvent(int type, int state, int joystick, int change)
overload0:
    {
        int32_t type;
        status = napi_get_value_int32(env, args[0], &type);
        auto __arg0 = type;

        int32_t state;
        status = napi_get_value_int32(env, args[1], &state);
        auto __arg1 = state;

        int32_t joystick;
        status = napi_get_value_int32(env, args[2], &joystick);
        auto __arg2 = joystick;

        int32_t change;
        status = napi_get_value_int32(env, args[3], &change);
        auto __arg3 = change;

        instance = new wxSharp::JoystickEvent(__arg0, __arg1, __arg2, __arg3);
    }

    // JoystickEvent
overload1:
    {
        wxSharp::JoystickEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::JoystickEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_JoystickEvent_JoystickEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::JoystickEvent::JoystickEvent: %lu\n", argc);
    return _this;
}

// wxSharp::JoystickEvent::ButtonDown
static napi_value callback_method_wxSharp_JoystickEvent_ButtonDown(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::JoystickEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ButtonDown(int but) const
overload0:
    {
        int32_t but;
        status = napi_get_value_int32(env, args[0], &but);
        auto __arg0 = but;

        bool __ret = instance->ButtonDown(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::JoystickEvent::ButtonDown: %lu\n", argc);
    return _this;
}

// wxSharp::JoystickEvent::ButtonUp
static napi_value callback_method_wxSharp_JoystickEvent_ButtonUp(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::JoystickEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ButtonUp(int but) const
overload0:
    {
        int32_t but;
        status = napi_get_value_int32(env, args[0], &but);
        auto __arg0 = but;

        bool __ret = instance->ButtonUp(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::JoystickEvent::ButtonUp: %lu\n", argc);
    return _this;
}

// wxSharp::JoystickEvent::ButtonIsDown
static napi_value callback_method_wxSharp_JoystickEvent_ButtonIsDown(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::JoystickEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ButtonIsDown(int but) const
overload0:
    {
        int32_t but;
        status = napi_get_value_int32(env, args[0], &but);
        auto __arg0 = but;

        bool __ret = instance->ButtonIsDown(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::JoystickEvent::ButtonIsDown: %lu\n", argc);
    return _this;
}

// wxSharp::JoystickEvent::Clone
static napi_value callback_method_wxSharp_JoystickEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::JoystickEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::JoystickEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_JoystickEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "ButtonDown", nullptr, callback_method_wxSharp_JoystickEvent_ButtonDown, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ButtonUp", nullptr, callback_method_wxSharp_JoystickEvent_ButtonUp, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ButtonIsDown", nullptr, callback_method_wxSharp_JoystickEvent_ButtonIsDown, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_JoystickEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "JoystickEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_JoystickEvent_JoystickEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_JoystickEvent_JoystickEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_UpdateUIEvent_UpdateUIEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_UpdateUIEvent_UpdateUIEvent;

// wxSharp::UpdateUIEvent::UpdateUIEvent
static napi_value callback_method_wxSharp_UpdateUIEvent_UpdateUIEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::UpdateUIEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // UpdateUIEvent(int commandId)
overload0:
    {
        int32_t commandId;
        status = napi_get_value_int32(env, args[0], &commandId);
        auto __arg0 = commandId;

        instance = new wxSharp::UpdateUIEvent(__arg0);
    }

    // UpdateUIEvent
overload1:
    {
        wxSharp::UpdateUIEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::UpdateUIEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_UpdateUIEvent_UpdateUIEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::UpdateUIEvent::UpdateUIEvent: %lu\n", argc);
    return _this;
}

// wxSharp::UpdateUIEvent::Check
static napi_value callback_method_wxSharp_UpdateUIEvent_Check(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::UpdateUIEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void Check(bool check)
overload0:
    {
        bool check;
        status = napi_get_value_bool(env, args[0], &check);
        auto __arg0 = (bool)check;

        instance->Check(__arg0);
    }
    printf("wxSharp::UpdateUIEvent::Check: %lu\n", argc);
    return _this;
}

// wxSharp::UpdateUIEvent::Enable
static napi_value callback_method_wxSharp_UpdateUIEvent_Enable(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::UpdateUIEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void Enable(bool enable)
overload0:
    {
        bool enable;
        status = napi_get_value_bool(env, args[0], &enable);
        auto __arg0 = (bool)enable;

        instance->Enable(__arg0);
    }
    printf("wxSharp::UpdateUIEvent::Enable: %lu\n", argc);
    return _this;
}

// wxSharp::UpdateUIEvent::Show
static napi_value callback_method_wxSharp_UpdateUIEvent_Show(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::UpdateUIEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void Show(bool show)
overload0:
    {
        bool show;
        status = napi_get_value_bool(env, args[0], &show);
        auto __arg0 = (bool)show;

        instance->Show(__arg0);
    }
    printf("wxSharp::UpdateUIEvent::Show: %lu\n", argc);
    return _this;
}

// wxSharp::UpdateUIEvent::DisallowCheck
static napi_value callback_method_wxSharp_UpdateUIEvent_DisallowCheck(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::UpdateUIEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->DisallowCheck();
    printf("wxSharp::UpdateUIEvent::DisallowCheck: %lu\n", argc);
    return _this;
}

// wxSharp::UpdateUIEvent::Clone
static napi_value callback_method_wxSharp_UpdateUIEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::UpdateUIEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::UpdateUIEvent::Clone: %lu\n", argc);
    return _this;
}

// wxSharp::UpdateUIEvent::ResetUpdateTime
static napi_value callback_method_wxSharp_UpdateUIEvent_ResetUpdateTime(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::UpdateUIEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::UpdateUIEvent::ResetUpdateTime();
    printf("wxSharp::UpdateUIEvent::ResetUpdateTime: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_UpdateUIEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Check", nullptr, callback_method_wxSharp_UpdateUIEvent_Check, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Enable", nullptr, callback_method_wxSharp_UpdateUIEvent_Enable, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Show", nullptr, callback_method_wxSharp_UpdateUIEvent_Show, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DisallowCheck", nullptr, callback_method_wxSharp_UpdateUIEvent_DisallowCheck, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_UpdateUIEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ResetUpdateTime", nullptr, callback_method_wxSharp_UpdateUIEvent_ResetUpdateTime, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes | napi_static), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "UpdateUIEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_UpdateUIEvent_UpdateUIEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_UpdateUIEvent_UpdateUIEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_SysColourChangedEvent_SysColourChangedEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_SysColourChangedEvent_SysColourChangedEvent;

// wxSharp::SysColourChangedEvent::SysColourChangedEvent
static napi_value callback_method_wxSharp_SysColourChangedEvent_SysColourChangedEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SysColourChangedEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // SysColourChangedEvent()
overload0:
    {
        instance = new wxSharp::SysColourChangedEvent();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_SysColourChangedEvent_SysColourChangedEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::SysColourChangedEvent::SysColourChangedEvent: %lu\n", argc);
    return _this;
}

// wxSharp::SysColourChangedEvent::Clone
static napi_value callback_method_wxSharp_SysColourChangedEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::SysColourChangedEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::SysColourChangedEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_SysColourChangedEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_SysColourChangedEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "SysColourChangedEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_SysColourChangedEvent_SysColourChangedEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_SysColourChangedEvent_SysColourChangedEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_MouseCaptureChangedEvent_MouseCaptureChangedEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_MouseCaptureChangedEvent_MouseCaptureChangedEvent;

// wxSharp::MouseCaptureChangedEvent::MouseCaptureChangedEvent
static napi_value callback_method_wxSharp_MouseCaptureChangedEvent_MouseCaptureChangedEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseCaptureChangedEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // MouseCaptureChangedEvent(int winid, ::wxSharp::Window* gainedCapture)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        wxSharp::Window* gainedCapture_instance;
        status = napi_unwrap(env, _this, (void**) &gainedCapture_instance);
        auto __arg1 = gainedCapture_instance;

        instance = new wxSharp::MouseCaptureChangedEvent(__arg0, __arg1);
    }

    // MouseCaptureChangedEvent
overload1:
    {
        wxSharp::MouseCaptureChangedEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::MouseCaptureChangedEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_MouseCaptureChangedEvent_MouseCaptureChangedEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::MouseCaptureChangedEvent::MouseCaptureChangedEvent: %lu\n", argc);
    return _this;
}

// wxSharp::MouseCaptureChangedEvent::Clone
static napi_value callback_method_wxSharp_MouseCaptureChangedEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::MouseCaptureChangedEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::MouseCaptureChangedEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_MouseCaptureChangedEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_MouseCaptureChangedEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "MouseCaptureChangedEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_MouseCaptureChangedEvent_MouseCaptureChangedEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_MouseCaptureChangedEvent_MouseCaptureChangedEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_MouseCaptureLostEvent_MouseCaptureLostEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_MouseCaptureLostEvent_MouseCaptureLostEvent;

// wxSharp::MouseCaptureLostEvent::MouseCaptureLostEvent
static napi_value callback_method_wxSharp_MouseCaptureLostEvent_MouseCaptureLostEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::MouseCaptureLostEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // MouseCaptureLostEvent(int winid)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        instance = new wxSharp::MouseCaptureLostEvent(__arg0);
    }

    // MouseCaptureLostEvent
overload1:
    {
        wxSharp::MouseCaptureLostEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::MouseCaptureLostEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_MouseCaptureLostEvent_MouseCaptureLostEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::MouseCaptureLostEvent::MouseCaptureLostEvent: %lu\n", argc);
    return _this;
}

// wxSharp::MouseCaptureLostEvent::Clone
static napi_value callback_method_wxSharp_MouseCaptureLostEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::MouseCaptureLostEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::MouseCaptureLostEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_MouseCaptureLostEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_MouseCaptureLostEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "MouseCaptureLostEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_MouseCaptureLostEvent_MouseCaptureLostEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_MouseCaptureLostEvent_MouseCaptureLostEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_DisplayChangedEvent_DisplayChangedEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_DisplayChangedEvent_DisplayChangedEvent;

// wxSharp::DisplayChangedEvent::DisplayChangedEvent
static napi_value callback_method_wxSharp_DisplayChangedEvent_DisplayChangedEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DisplayChangedEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // DisplayChangedEvent()
overload0:
    {
        instance = new wxSharp::DisplayChangedEvent();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_DisplayChangedEvent_DisplayChangedEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::DisplayChangedEvent::DisplayChangedEvent: %lu\n", argc);
    return _this;
}

// wxSharp::DisplayChangedEvent::Clone
static napi_value callback_method_wxSharp_DisplayChangedEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DisplayChangedEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::DisplayChangedEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_DisplayChangedEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_DisplayChangedEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "DisplayChangedEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_DisplayChangedEvent_DisplayChangedEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_DisplayChangedEvent_DisplayChangedEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_DPIChangedEvent_DPIChangedEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_DPIChangedEvent_DPIChangedEvent;

// wxSharp::DPIChangedEvent::DPIChangedEvent
static napi_value callback_method_wxSharp_DPIChangedEvent_DPIChangedEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::DPIChangedEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // explicit DPIChangedEvent(const ::wxSharp::Size& oldDPI, const ::wxSharp::Size& newDPI)
overload0:
    {
        wxSharp::Size* oldDPI_instance;
        status = napi_unwrap(env, _this, (void**) &oldDPI_instance);
        auto &__arg0 = *oldDPI_instance;

        wxSharp::Size* newDPI_instance;
        status = napi_unwrap(env, _this, (void**) &newDPI_instance);
        auto &__arg1 = *newDPI_instance;

        instance = new wxSharp::DPIChangedEvent(__arg0, __arg1);
    }

    // DPIChangedEvent
overload1:
    {
        wxSharp::DPIChangedEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::DPIChangedEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_DPIChangedEvent_DPIChangedEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::DPIChangedEvent::DPIChangedEvent: %lu\n", argc);
    return _this;
}

// wxSharp::DPIChangedEvent::Clone
static napi_value callback_method_wxSharp_DPIChangedEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::DPIChangedEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::DPIChangedEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_DPIChangedEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_DPIChangedEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "DPIChangedEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_DPIChangedEvent_DPIChangedEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_DPIChangedEvent_DPIChangedEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_PaletteChangedEvent_PaletteChangedEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_PaletteChangedEvent_PaletteChangedEvent;

// wxSharp::PaletteChangedEvent::PaletteChangedEvent
static napi_value callback_method_wxSharp_PaletteChangedEvent_PaletteChangedEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::PaletteChangedEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // PaletteChangedEvent(int winid)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        instance = new wxSharp::PaletteChangedEvent(__arg0);
    }

    // PaletteChangedEvent
overload1:
    {
        wxSharp::PaletteChangedEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::PaletteChangedEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_PaletteChangedEvent_PaletteChangedEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::PaletteChangedEvent::PaletteChangedEvent: %lu\n", argc);
    return _this;
}

// wxSharp::PaletteChangedEvent::Clone
static napi_value callback_method_wxSharp_PaletteChangedEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::PaletteChangedEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::PaletteChangedEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_PaletteChangedEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_PaletteChangedEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "PaletteChangedEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_PaletteChangedEvent_PaletteChangedEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_PaletteChangedEvent_PaletteChangedEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_QueryNewPaletteEvent_QueryNewPaletteEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_QueryNewPaletteEvent_QueryNewPaletteEvent;

// wxSharp::QueryNewPaletteEvent::QueryNewPaletteEvent
static napi_value callback_method_wxSharp_QueryNewPaletteEvent_QueryNewPaletteEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::QueryNewPaletteEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // QueryNewPaletteEvent(int winid)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        instance = new wxSharp::QueryNewPaletteEvent(__arg0);
    }

    // QueryNewPaletteEvent
overload1:
    {
        wxSharp::QueryNewPaletteEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::QueryNewPaletteEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_QueryNewPaletteEvent_QueryNewPaletteEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::QueryNewPaletteEvent::QueryNewPaletteEvent: %lu\n", argc);
    return _this;
}

// wxSharp::QueryNewPaletteEvent::Clone
static napi_value callback_method_wxSharp_QueryNewPaletteEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::QueryNewPaletteEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::QueryNewPaletteEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_QueryNewPaletteEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_QueryNewPaletteEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "QueryNewPaletteEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_QueryNewPaletteEvent_QueryNewPaletteEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_QueryNewPaletteEvent_QueryNewPaletteEvent);
    assert(status == napi_ok);

    return constructor;
}

enum class NavigationKeyEventFlags : unsigned int
{
    IsBackward = 0x0,
    IsForward = 0x1,
    WinChange = 0x2,
    FromTab = 0x4
};

static void dtor_wxSharp_NavigationKeyEvent_NavigationKeyEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_NavigationKeyEvent_NavigationKeyEvent;

// wxSharp::NavigationKeyEvent::NavigationKeyEvent
static napi_value callback_method_wxSharp_NavigationKeyEvent_NavigationKeyEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::NavigationKeyEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // NavigationKeyEvent()
overload0:
    {
        instance = new wxSharp::NavigationKeyEvent();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_NavigationKeyEvent_NavigationKeyEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::NavigationKeyEvent::NavigationKeyEvent: %lu\n", argc);
    return _this;
}

// wxSharp::NavigationKeyEvent::SetWindowChange
static napi_value callback_method_wxSharp_NavigationKeyEvent_SetWindowChange(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::NavigationKeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetWindowChange(bool bIs)
overload0:
    {
        bool bIs;
        status = napi_get_value_bool(env, args[0], &bIs);
        auto __arg0 = (bool)bIs;

        instance->SetWindowChange(__arg0);
    }
    printf("wxSharp::NavigationKeyEvent::SetWindowChange: %lu\n", argc);
    return _this;
}

// wxSharp::NavigationKeyEvent::SetFromTab
static napi_value callback_method_wxSharp_NavigationKeyEvent_SetFromTab(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::NavigationKeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetFromTab(bool bIs)
overload0:
    {
        bool bIs;
        status = napi_get_value_bool(env, args[0], &bIs);
        auto __arg0 = (bool)bIs;

        instance->SetFromTab(__arg0);
    }
    printf("wxSharp::NavigationKeyEvent::SetFromTab: %lu\n", argc);
    return _this;
}

// wxSharp::NavigationKeyEvent::SetFlags
static napi_value callback_method_wxSharp_NavigationKeyEvent_SetFlags(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::NavigationKeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetFlags(long flags)
overload0:
    {
        int32_t flags;
        status = napi_get_value_int32(env, args[0], &flags);
        auto __arg0 = flags;

        instance->SetFlags(__arg0);
    }
    printf("wxSharp::NavigationKeyEvent::SetFlags: %lu\n", argc);
    return _this;
}

// wxSharp::NavigationKeyEvent::Clone
static napi_value callback_method_wxSharp_NavigationKeyEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::NavigationKeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::NavigationKeyEvent::Clone: %lu\n", argc);
    return _this;
}

// wxSharp::NavigationKeyEvent::set_m_flags
static napi_value callback_method_wxSharp_NavigationKeyEvent_set_m_flags(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::NavigationKeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_flags(long value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_m_flags(__arg0);
    }
    printf("wxSharp::NavigationKeyEvent::set_m_flags: %lu\n", argc);
    return _this;
}

// wxSharp::NavigationKeyEvent::set_m_focus
static napi_value callback_method_wxSharp_NavigationKeyEvent_set_m_focus(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::NavigationKeyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_m_focus(::wxSharp::Window* value)
overload0:
    {
        wxSharp::Window* value_instance;
        status = napi_unwrap(env, _this, (void**) &value_instance);
        auto __arg0 = value_instance;

        instance->set_m_focus(__arg0);
    }
    printf("wxSharp::NavigationKeyEvent::set_m_focus: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_NavigationKeyEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "SetWindowChange", nullptr, callback_method_wxSharp_NavigationKeyEvent_SetWindowChange, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetFromTab", nullptr, callback_method_wxSharp_NavigationKeyEvent_SetFromTab, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetFlags", nullptr, callback_method_wxSharp_NavigationKeyEvent_SetFlags, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_NavigationKeyEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_flags", nullptr, callback_method_wxSharp_NavigationKeyEvent_set_m_flags, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_m_focus", nullptr, callback_method_wxSharp_NavigationKeyEvent_set_m_focus, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NavigationKeyEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_NavigationKeyEvent_NavigationKeyEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_NavigationKeyEvent_NavigationKeyEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_WindowCreateEvent_WindowCreateEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_WindowCreateEvent_WindowCreateEvent;

// wxSharp::WindowCreateEvent::WindowCreateEvent
static napi_value callback_method_wxSharp_WindowCreateEvent_WindowCreateEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::WindowCreateEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // WindowCreateEvent(::wxSharp::Window* win)
overload0:
    {
        wxSharp::Window* win_instance;
        status = napi_unwrap(env, _this, (void**) &win_instance);
        auto __arg0 = win_instance;

        instance = new wxSharp::WindowCreateEvent(__arg0);
    }

    // WindowCreateEvent
overload1:
    {
        wxSharp::WindowCreateEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::WindowCreateEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_WindowCreateEvent_WindowCreateEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::WindowCreateEvent::WindowCreateEvent: %lu\n", argc);
    return _this;
}

// wxSharp::WindowCreateEvent::Clone
static napi_value callback_method_wxSharp_WindowCreateEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::WindowCreateEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::WindowCreateEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_WindowCreateEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_WindowCreateEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "WindowCreateEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_WindowCreateEvent_WindowCreateEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_WindowCreateEvent_WindowCreateEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_WindowDestroyEvent_WindowDestroyEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_WindowDestroyEvent_WindowDestroyEvent;

// wxSharp::WindowDestroyEvent::WindowDestroyEvent
static napi_value callback_method_wxSharp_WindowDestroyEvent_WindowDestroyEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::WindowDestroyEvent* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // WindowDestroyEvent(::wxSharp::Window* win)
overload0:
    {
        wxSharp::Window* win_instance;
        status = napi_unwrap(env, _this, (void**) &win_instance);
        auto __arg0 = win_instance;

        instance = new wxSharp::WindowDestroyEvent(__arg0);
    }

    // WindowDestroyEvent
overload1:
    {
        wxSharp::WindowDestroyEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::WindowDestroyEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_WindowDestroyEvent_WindowDestroyEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::WindowDestroyEvent::WindowDestroyEvent: %lu\n", argc);
    return _this;
}

// wxSharp::WindowDestroyEvent::Clone
static napi_value callback_method_wxSharp_WindowDestroyEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::WindowDestroyEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::WindowDestroyEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_WindowDestroyEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_WindowDestroyEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "WindowDestroyEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_WindowDestroyEvent_WindowDestroyEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_WindowDestroyEvent_WindowDestroyEvent);
    assert(status == napi_ok);

    return constructor;
}

enum class Source : unsigned int
{
    Unknown = 0,
    Keyboard = 1,
    HelpButton = 2
};

static void dtor_wxSharp_HelpEvent_HelpEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_HelpEvent_HelpEvent;

// wxSharp::HelpEvent::HelpEvent
static napi_value callback_method_wxSharp_HelpEvent_HelpEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::HelpEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // HelpEvent(int type, int winid, const ::wxSharp::Point& pt, ::wxSharp::HelpEvent::Source origin)
overload0:
    {
        int32_t type;
        status = napi_get_value_int32(env, args[0], &type);
        auto __arg0 = type;

        int32_t winid;
        status = napi_get_value_int32(env, args[1], &winid);
        auto __arg1 = winid;

        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg2 = *pt_instance;

        int32_t origin;
        status = napi_get_value_int32(env, args[3], &origin);
        auto __arg3 = (::wxSharp::HelpEvent::Source)origin;

        instance = new wxSharp::HelpEvent(__arg0, __arg1, __arg2, __arg3);
    }

    // HelpEvent
overload1:
    {
        wxSharp::HelpEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::HelpEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_HelpEvent_HelpEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::HelpEvent::HelpEvent: %lu\n", argc);
    return _this;
}

// wxSharp::HelpEvent::SetPosition
static napi_value callback_method_wxSharp_HelpEvent_SetPosition(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::HelpEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetPosition(const ::wxSharp::Point& pos)
overload0:
    {
        wxSharp::Point* pos_instance;
        status = napi_unwrap(env, _this, (void**) &pos_instance);
        auto &__arg0 = *pos_instance;

        instance->SetPosition(__arg0);
    }
    printf("wxSharp::HelpEvent::SetPosition: %lu\n", argc);
    return _this;
}

// wxSharp::HelpEvent::SetLink
static napi_value callback_method_wxSharp_HelpEvent_SetLink(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::HelpEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetLink(const char* link)
overload0:
    {
        size_t _link_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_link_size);

        char* link = (char*) malloc(_link_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_link_size);
        assert(status == napi_ok);
        auto __arg0 = link;

        instance->SetLink(__arg0);
    }
    printf("wxSharp::HelpEvent::SetLink: %lu\n", argc);
    return _this;
}

// wxSharp::HelpEvent::SetTarget
static napi_value callback_method_wxSharp_HelpEvent_SetTarget(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::HelpEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetTarget(const char* target)
overload0:
    {
        size_t _target_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_target_size);

        char* target = (char*) malloc(_target_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_target_size);
        assert(status == napi_ok);
        auto __arg0 = target;

        instance->SetTarget(__arg0);
    }
    printf("wxSharp::HelpEvent::SetTarget: %lu\n", argc);
    return _this;
}

// wxSharp::HelpEvent::Clone
static napi_value callback_method_wxSharp_HelpEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::HelpEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::HelpEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_HelpEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "SetPosition", nullptr, callback_method_wxSharp_HelpEvent_SetPosition, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetLink", nullptr, callback_method_wxSharp_HelpEvent_SetLink, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetTarget", nullptr, callback_method_wxSharp_HelpEvent_SetTarget, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_HelpEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "HelpEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_HelpEvent_HelpEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_HelpEvent_HelpEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_ClipboardTextEvent_ClipboardTextEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_ClipboardTextEvent_ClipboardTextEvent;

// wxSharp::ClipboardTextEvent::ClipboardTextEvent
static napi_value callback_method_wxSharp_ClipboardTextEvent_ClipboardTextEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ClipboardTextEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ClipboardTextEvent(int type, int winid)
overload0:
    {
        int32_t type;
        status = napi_get_value_int32(env, args[0], &type);
        auto __arg0 = type;

        int32_t winid;
        status = napi_get_value_int32(env, args[1], &winid);
        auto __arg1 = winid;

        instance = new wxSharp::ClipboardTextEvent(__arg0, __arg1);
    }

    // ClipboardTextEvent
overload1:
    {
        wxSharp::ClipboardTextEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::ClipboardTextEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_ClipboardTextEvent_ClipboardTextEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::ClipboardTextEvent::ClipboardTextEvent: %lu\n", argc);
    return _this;
}

// wxSharp::ClipboardTextEvent::Clone
static napi_value callback_method_wxSharp_ClipboardTextEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::ClipboardTextEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::ClipboardTextEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_ClipboardTextEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Clone", nullptr, callback_method_wxSharp_ClipboardTextEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "ClipboardTextEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_ClipboardTextEvent_ClipboardTextEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_ClipboardTextEvent_ClipboardTextEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_ContextMenuEvent_ContextMenuEvent(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_ContextMenuEvent_ContextMenuEvent;

// wxSharp::ContextMenuEvent::ContextMenuEvent
static napi_value callback_method_wxSharp_ContextMenuEvent_ContextMenuEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ContextMenuEvent* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ContextMenuEvent(int type, int winid, const ::wxSharp::Point& pt)
overload0:
    {
        int32_t type;
        status = napi_get_value_int32(env, args[0], &type);
        auto __arg0 = type;

        int32_t winid;
        status = napi_get_value_int32(env, args[1], &winid);
        auto __arg1 = winid;

        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg2 = *pt_instance;

        instance = new wxSharp::ContextMenuEvent(__arg0, __arg1, __arg2);
    }

    // ContextMenuEvent
overload1:
    {
        wxSharp::ContextMenuEvent* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::ContextMenuEvent(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_ContextMenuEvent_ContextMenuEvent, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::ContextMenuEvent::ContextMenuEvent: %lu\n", argc);
    return _this;
}

// wxSharp::ContextMenuEvent::SetPosition
static napi_value callback_method_wxSharp_ContextMenuEvent_SetPosition(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ContextMenuEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetPosition(const ::wxSharp::Point& pos)
overload0:
    {
        wxSharp::Point* pos_instance;
        status = napi_unwrap(env, _this, (void**) &pos_instance);
        auto &__arg0 = *pos_instance;

        instance->SetPosition(__arg0);
    }
    printf("wxSharp::ContextMenuEvent::SetPosition: %lu\n", argc);
    return _this;
}

// wxSharp::ContextMenuEvent::Clone
static napi_value callback_method_wxSharp_ContextMenuEvent_Clone(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::ContextMenuEvent* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Event* __ret = instance->Clone();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Event_Event, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::ContextMenuEvent::Clone: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_ContextMenuEvent(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "SetPosition", nullptr, callback_method_wxSharp_ContextMenuEvent_SetPosition, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clone", nullptr, callback_method_wxSharp_ContextMenuEvent_Clone, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "ContextMenuEvent", NAPI_AUTO_LENGTH, callback_method_wxSharp_ContextMenuEvent_ContextMenuEvent, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_ContextMenuEvent_ContextMenuEvent);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_EvtHandler_EvtHandler(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_EvtHandler_EvtHandler;

// wxSharp::EvtHandler::EvtHandler
static napi_value callback_method_wxSharp_EvtHandler_EvtHandler(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::EvtHandler* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // EvtHandler()
overload0:
    {
        instance = new wxSharp::EvtHandler();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_EvtHandler_EvtHandler, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::EvtHandler::EvtHandler: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::Unlink
static napi_value callback_method_wxSharp_EvtHandler_Unlink(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->Unlink();
    printf("wxSharp::EvtHandler::Unlink: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::ProcessEvent
static napi_value callback_method_wxSharp_EvtHandler_ProcessEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ProcessEvent(::wxSharp::Event& event)
overload0:
    {
        wxSharp::Event* event_instance;
        status = napi_unwrap(env, _this, (void**) &event_instance);
        auto &__arg0 = *event_instance;

        bool __ret = instance->ProcessEvent(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::EvtHandler::ProcessEvent: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::SafelyProcessEvent
static napi_value callback_method_wxSharp_EvtHandler_SafelyProcessEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool SafelyProcessEvent(::wxSharp::Event& event)
overload0:
    {
        wxSharp::Event* event_instance;
        status = napi_unwrap(env, _this, (void**) &event_instance);
        auto &__arg0 = *event_instance;

        bool __ret = instance->SafelyProcessEvent(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::EvtHandler::SafelyProcessEvent: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::ProcessEventLocally
static napi_value callback_method_wxSharp_EvtHandler_ProcessEventLocally(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ProcessEventLocally(::wxSharp::Event& event)
overload0:
    {
        wxSharp::Event* event_instance;
        status = napi_unwrap(env, _this, (void**) &event_instance);
        auto &__arg0 = *event_instance;

        bool __ret = instance->ProcessEventLocally(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::EvtHandler::ProcessEventLocally: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::QueueEvent
static napi_value callback_method_wxSharp_EvtHandler_QueueEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void QueueEvent(::wxSharp::Event* event)
overload0:
    {
        wxSharp::Event* event_instance;
        status = napi_unwrap(env, _this, (void**) &event_instance);
        auto __arg0 = event_instance;

        instance->QueueEvent(__arg0);
    }
    printf("wxSharp::EvtHandler::QueueEvent: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::AddPendingEvent
static napi_value callback_method_wxSharp_EvtHandler_AddPendingEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void AddPendingEvent(const ::wxSharp::Event& event)
overload0:
    {
        wxSharp::Event* event_instance;
        status = napi_unwrap(env, _this, (void**) &event_instance);
        auto &__arg0 = *event_instance;

        instance->AddPendingEvent(__arg0);
    }
    printf("wxSharp::EvtHandler::AddPendingEvent: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::ProcessPendingEvents
static napi_value callback_method_wxSharp_EvtHandler_ProcessPendingEvents(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->ProcessPendingEvents();
    printf("wxSharp::EvtHandler::ProcessPendingEvents: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::DeletePendingEvents
static napi_value callback_method_wxSharp_EvtHandler_DeletePendingEvents(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->DeletePendingEvents();
    printf("wxSharp::EvtHandler::DeletePendingEvents: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::ProcessThreadEvent
static napi_value callback_method_wxSharp_EvtHandler_ProcessThreadEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ProcessThreadEvent(const ::wxSharp::Event& event)
overload0:
    {
        wxSharp::Event* event_instance;
        status = napi_unwrap(env, _this, (void**) &event_instance);
        auto &__arg0 = *event_instance;

        bool __ret = instance->ProcessThreadEvent(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::EvtHandler::ProcessThreadEvent: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::SearchDynamicEventTable
static napi_value callback_method_wxSharp_EvtHandler_SearchDynamicEventTable(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool SearchDynamicEventTable(::wxSharp::Event& event)
overload0:
    {
        wxSharp::Event* event_instance;
        status = napi_unwrap(env, _this, (void**) &event_instance);
        auto &__arg0 = *event_instance;

        bool __ret = instance->SearchDynamicEventTable(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::EvtHandler::SearchDynamicEventTable: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::ClearEventHashTable
static napi_value callback_method_wxSharp_EvtHandler_ClearEventHashTable(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->ClearEventHashTable();
    printf("wxSharp::EvtHandler::ClearEventHashTable: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::OnSinkDestroyed
static napi_value callback_method_wxSharp_EvtHandler_OnSinkDestroyed(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void OnSinkDestroyed(::wxSharp::EvtHandler* sink)
overload0:
    {
        wxSharp::EvtHandler* sink_instance;
        status = napi_unwrap(env, _this, (void**) &sink_instance);
        auto __arg0 = sink_instance;

        instance->OnSinkDestroyed(__arg0);
    }
    printf("wxSharp::EvtHandler::OnSinkDestroyed: %lu\n", argc);
    return _this;
}

// wxSharp::EvtHandler::WXConsumeException
static napi_value callback_method_wxSharp_EvtHandler_WXConsumeException(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::EvtHandler* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::EvtHandler::WXConsumeException();
    printf("wxSharp::EvtHandler::WXConsumeException: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_EvtHandler(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Unlink", nullptr, callback_method_wxSharp_EvtHandler_Unlink, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ProcessEvent", nullptr, callback_method_wxSharp_EvtHandler_ProcessEvent, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SafelyProcessEvent", nullptr, callback_method_wxSharp_EvtHandler_SafelyProcessEvent, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ProcessEventLocally", nullptr, callback_method_wxSharp_EvtHandler_ProcessEventLocally, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "QueueEvent", nullptr, callback_method_wxSharp_EvtHandler_QueueEvent, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "AddPendingEvent", nullptr, callback_method_wxSharp_EvtHandler_AddPendingEvent, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ProcessPendingEvents", nullptr, callback_method_wxSharp_EvtHandler_ProcessPendingEvents, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DeletePendingEvents", nullptr, callback_method_wxSharp_EvtHandler_DeletePendingEvents, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ProcessThreadEvent", nullptr, callback_method_wxSharp_EvtHandler_ProcessThreadEvent, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SearchDynamicEventTable", nullptr, callback_method_wxSharp_EvtHandler_SearchDynamicEventTable, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ClearEventHashTable", nullptr, callback_method_wxSharp_EvtHandler_ClearEventHashTable, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "OnSinkDestroyed", nullptr, callback_method_wxSharp_EvtHandler_OnSinkDestroyed, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "WXConsumeException", nullptr, callback_method_wxSharp_EvtHandler_WXConsumeException, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes | napi_static), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "EvtHandler", NAPI_AUTO_LENGTH, callback_method_wxSharp_EvtHandler_EvtHandler, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_EvtHandler_EvtHandler);
    assert(status == napi_ok);

    return constructor;
}

// wxSharp::NewEventType
static napi_value callback_function_wxSharp_NewEventType(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    int __ret = ::wxSharp::NewEventType();

    napi_value __result;
    status = napi_create_int32(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;

    return nullptr;
}

static napi_value register_function_wxSharp_NewEventType(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_NewEventType;
    status = napi_create_function(env, "NewEventType", NAPI_AUTO_LENGTH, callback_function_wxSharp_NewEventType, 0, &_wxSharp_NewEventType);
    assert(status == napi_ok);

    return _wxSharp_NewEventType;
}

// wxSharp::PostEvent
static napi_value callback_function_wxSharp_PostEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void PostEvent(::wxSharp::EvtHandler* dest, const ::wxSharp::Event& event)
overload0:
    {
        wxSharp::EvtHandler* dest_instance;
        status = napi_unwrap(env, _this, (void**) &dest_instance);
        auto __arg0 = dest_instance;

        wxSharp::Event* event_instance;
        status = napi_unwrap(env, _this, (void**) &event_instance);
        auto &__arg1 = *event_instance;

        ::wxSharp::PostEvent(__arg0, __arg1);
    }

    return nullptr;
}

static napi_value register_function_wxSharp_PostEvent(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_PostEvent;
    status = napi_create_function(env, "PostEvent", NAPI_AUTO_LENGTH, callback_function_wxSharp_PostEvent, 0, &_wxSharp_PostEvent);
    assert(status == napi_ok);

    return _wxSharp_PostEvent;
}

// wxSharp::QueueEvent
static napi_value callback_function_wxSharp_QueueEvent(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void QueueEvent(::wxSharp::EvtHandler* dest, ::wxSharp::Event* event)
overload0:
    {
        wxSharp::EvtHandler* dest_instance;
        status = napi_unwrap(env, _this, (void**) &dest_instance);
        auto __arg0 = dest_instance;

        wxSharp::Event* event_instance;
        status = napi_unwrap(env, _this, (void**) &event_instance);
        auto __arg1 = event_instance;

        ::wxSharp::QueueEvent(__arg0, __arg1);
    }

    return nullptr;
}

static napi_value register_function_wxSharp_QueueEvent(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_QueueEvent;
    status = napi_create_function(env, "QueueEvent", NAPI_AUTO_LENGTH, callback_function_wxSharp_QueueEvent, 0, &_wxSharp_QueueEvent);
    assert(status == napi_ok);

    return _wxSharp_QueueEvent;
}

// wxSharp::FindFocusDescendant
static napi_value callback_function_wxSharp_FindFocusDescendant(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Window* FindFocusDescendant(::wxSharp::Window* ancestor)
overload0:
    {
        wxSharp::Window* ancestor_instance;
        status = napi_unwrap(env, _this, (void**) &ancestor_instance);
        auto __arg0 = ancestor_instance;

        ::wxSharp::Window* __ret = ::wxSharp::FindFocusDescendant(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Window_Window, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    return nullptr;
}

static napi_value register_function_wxSharp_FindFocusDescendant(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_FindFocusDescendant;
    status = napi_create_function(env, "FindFocusDescendant", NAPI_AUTO_LENGTH, callback_function_wxSharp_FindFocusDescendant, 0, &_wxSharp_FindFocusDescendant);
    assert(status == napi_ok);

    return _wxSharp_FindFocusDescendant;
}

void register_wxsharp_event(napi_env env, napi_value exports)
{
    napi_value value;

    value = register_enum_wxSharp_EventCategory(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "EventCategory", value));

    value = register_enum_wxSharp_IdleMode(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "IdleMode", value));

    value = register_enum_wxSharp_MouseWheelAxis(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "MouseWheelAxis", value));

    value = register_enum_wxSharp_UpdateUIMode(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "UpdateUIMode", value));

    value = register_enum_wxSharp_EventPropagation(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "EventPropagation", value));

    value = register_enum_wxSharp_JoystickButton(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "JoystickButton", value));

    value = register_enum_wxSharp_JoystickId(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "JoystickId", value));

    value = register_enum_wxSharp_KeyCategoryFlags(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "KeyCategoryFlags", value));

    value = register_class_wxSharp_Event(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Event", value));

    value = register_class_wxSharp_PropagateOnce(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PropagateOnce", value));

    value = register_class_wxSharp_IdleEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "IdleEvent", value));

    value = register_class_wxSharp_ThreadEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ThreadEvent", value));

    value = register_class_wxSharp_AsyncMethodCallEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "AsyncMethodCallEvent", value));

    value = register_class_wxSharp_CommandEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "CommandEvent", value));

    value = register_class_wxSharp_NotifyEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NotifyEvent", value));

    value = register_class_wxSharp_ScrollEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ScrollEvent", value));

    value = register_class_wxSharp_ScrollWinEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ScrollWinEvent", value));

    value = register_class_wxSharp_MouseEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "MouseEvent", value));

    value = register_class_wxSharp_SetCursorEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "SetCursorEvent", value));

    value = register_class_wxSharp_GestureEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "GestureEvent", value));

    value = register_class_wxSharp_PanGestureEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PanGestureEvent", value));

    value = register_class_wxSharp_ZoomGestureEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ZoomGestureEvent", value));

    value = register_class_wxSharp_RotateGestureEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "RotateGestureEvent", value));

    value = register_class_wxSharp_TwoFingerTapEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "TwoFingerTapEvent", value));

    value = register_class_wxSharp_LongPressEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "LongPressEvent", value));

    value = register_class_wxSharp_PressAndTapEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PressAndTapEvent", value));

    value = register_class_wxSharp_KeyEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "KeyEvent", value));

    value = register_class_wxSharp_SizeEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "SizeEvent", value));

    value = register_class_wxSharp_MoveEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "MoveEvent", value));

    value = register_class_wxSharp_PaintEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PaintEvent", value));

    value = register_class_wxSharp_NcPaintEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NcPaintEvent", value));

    value = register_class_wxSharp_EraseEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "EraseEvent", value));

    value = register_class_wxSharp_FocusEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "FocusEvent", value));

    value = register_class_wxSharp_ChildFocusEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ChildFocusEvent", value));

    value = register_class_wxSharp_ActivateEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ActivateEvent", value));

    value = register_class_wxSharp_InitDialogEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "InitDialogEvent", value));

    value = register_class_wxSharp_MenuEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "MenuEvent", value));

    value = register_class_wxSharp_CloseEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "CloseEvent", value));

    value = register_class_wxSharp_ShowEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ShowEvent", value));

    value = register_class_wxSharp_IconizeEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "IconizeEvent", value));

    value = register_class_wxSharp_MaximizeEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "MaximizeEvent", value));

    value = register_class_wxSharp_JoystickEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "JoystickEvent", value));

    value = register_class_wxSharp_UpdateUIEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "UpdateUIEvent", value));

    value = register_class_wxSharp_SysColourChangedEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "SysColourChangedEvent", value));

    value = register_class_wxSharp_MouseCaptureChangedEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "MouseCaptureChangedEvent", value));

    value = register_class_wxSharp_MouseCaptureLostEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "MouseCaptureLostEvent", value));

    value = register_class_wxSharp_DisplayChangedEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "DisplayChangedEvent", value));

    value = register_class_wxSharp_DPIChangedEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "DPIChangedEvent", value));

    value = register_class_wxSharp_PaletteChangedEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PaletteChangedEvent", value));

    value = register_class_wxSharp_QueryNewPaletteEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "QueryNewPaletteEvent", value));

    value = register_class_wxSharp_NavigationKeyEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NavigationKeyEvent", value));

    value = register_class_wxSharp_WindowCreateEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "WindowCreateEvent", value));

    value = register_class_wxSharp_WindowDestroyEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "WindowDestroyEvent", value));

    value = register_class_wxSharp_HelpEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "HelpEvent", value));

    value = register_class_wxSharp_ClipboardTextEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ClipboardTextEvent", value));

    value = register_class_wxSharp_ContextMenuEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ContextMenuEvent", value));

    value = register_class_wxSharp_EvtHandler(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "EvtHandler", value));

    value = register_function_wxSharp_NewEventType(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NewEventType", value));

    value = register_function_wxSharp_PostEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PostEvent", value));

    value = register_function_wxSharp_QueueEvent(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "QueueEvent", value));

    value = register_function_wxSharp_FindFocusDescendant(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "FindFocusDescendant", value));
}
