// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <wxsharp/frame.h>
#include <node/node_api.h>
#include <assert.h>
#include <stdio.h>
#include "NAPIHelpers.h"

extern napi_ref ctor_wxSharp_Event_Event;
extern napi_ref ctor_wxSharp_GraphicsContext_GraphicsContext;
extern napi_ref ctor_wxSharp_GraphicsPath_GraphicsPath;
extern napi_ref ctor_wxSharp_GraphicsMatrix_GraphicsMatrix;
extern napi_ref ctor_wxSharp_GraphicsPen_GraphicsPen;
extern napi_ref ctor_wxSharp_GraphicsBrush_GraphicsBrush;
extern napi_ref ctor_wxSharp_GraphicsFont_GraphicsFont;
extern napi_ref ctor_wxSharp_GraphicsBitmap_GraphicsBitmap;
extern napi_ref ctor_wxSharp_Color_Color;
extern napi_ref ctor_wxSharp_Size_Size;
extern napi_ref ctor_wxSharp_Rect_Rect;
extern napi_ref ctor_wxSharp_Point_Point;
extern napi_ref ctor_wxSharp_SizerItem_SizerItem;
extern napi_ref ctor_wxSharp_Window_Window;
extern napi_ref ctor_wxSharp_EvtHandler_EvtHandler;
extern napi_ref ctor_wxSharp_VisualAttributes_VisualAttributes;

static napi_value register_enum_wxSharp_FrameFlags(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // FRAME_NO_TASKBAR
    napi_value i_0;
    status = napi_create_int32(env, 2, &i_0);
    assert(status == napi_ok);

    // FRAME_TOOL_WINDOW
    napi_value i_1;
    status = napi_create_int32(env, 4, &i_1);
    assert(status == napi_ok);

    // FRAME_FLOAT_ON_PARENT
    napi_value i_2;
    status = napi_create_int32(env, 8, &i_2);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "FRAME_NO_TASKBAR", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "FRAME_TOOL_WINDOW", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "FRAME_FLOAT_ON_PARENT", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static void dtor_wxSharp_Frame_Frame(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_Frame_Frame;

// wxSharp::Frame::Frame
static napi_value callback_method_wxSharp_Frame_Frame(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 7)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_OBJECT(types[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[5], args[5]))
        goto typecheck6;

    goto error;

typecheck6:
    if (NAPI_IS_INT32(types[6], args[6]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // Frame()
overload0:
    {
        instance = new wxSharp::Frame();
    }

    // Frame(::wxSharp::Window* parent, int id, const char* title, const ::wxSharp::Point& pos, const ::wxSharp::Size& size, ::wxSharp::FrameStyle style, const char* name)
overload1:
    {
        wxSharp::Window* parent_instance;
        status = napi_unwrap(env, _this, (void**) &parent_instance);
        auto __arg0 = parent_instance;

        int32_t id;
        status = napi_get_value_int32(env, args[1], &id);
        auto __arg1 = id;

        size_t _title_size;
        status = napi_get_value_string_utf8(env, args[2], nullptr, 0, &_title_size);

        char* title = (char*) malloc(_title_size);
        status = napi_get_value_string_utf8(env, args[2], nullptr, 0, &_title_size);
        assert(status == napi_ok);
        auto __arg2 = title;

        wxSharp::Point* pos_instance;
        status = napi_unwrap(env, _this, (void**) &pos_instance);
        auto &__arg3 = *pos_instance;

        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg4 = *size_instance;

        int32_t style;
        status = napi_get_value_int32(env, args[5], &style);
        auto __arg5 = (::wxSharp::FrameStyle)style;

        size_t _name_size;
        status = napi_get_value_string_utf8(env, args[6], nullptr, 0, &_name_size);

        char* name = (char*) malloc(_name_size);
        status = napi_get_value_string_utf8(env, args[6], nullptr, 0, &_name_size);
        assert(status == napi_ok);
        auto __arg6 = name;

        instance = new wxSharp::Frame(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_Frame_Frame, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::Frame::Frame: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::Create
static napi_value callback_method_wxSharp_Frame_Create(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 7 || argc > 7)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_OBJECT(types[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[5], args[5]))
        goto typecheck6;

    goto error;

typecheck6:
    if (NAPI_IS_INT32(types[6], args[6]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Create(::wxSharp::Window* parent, int id, const char* title, const ::wxSharp::Point& pos, const ::wxSharp::Size& size, long style, const char* name)
overload0:
    {
        wxSharp::Window* parent_instance;
        status = napi_unwrap(env, _this, (void**) &parent_instance);
        auto __arg0 = parent_instance;

        int32_t id;
        status = napi_get_value_int32(env, args[1], &id);
        auto __arg1 = id;

        size_t _title_size;
        status = napi_get_value_string_utf8(env, args[2], nullptr, 0, &_title_size);

        char* title = (char*) malloc(_title_size);
        status = napi_get_value_string_utf8(env, args[2], nullptr, 0, &_title_size);
        assert(status == napi_ok);
        auto __arg2 = title;

        wxSharp::Point* pos_instance;
        status = napi_unwrap(env, _this, (void**) &pos_instance);
        auto &__arg3 = *pos_instance;

        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg4 = *size_instance;

        int32_t style;
        status = napi_get_value_int32(env, args[5], &style);
        auto __arg5 = style;

        size_t _name_size;
        status = napi_get_value_string_utf8(env, args[6], nullptr, 0, &_name_size);

        char* name = (char*) malloc(_name_size);
        status = napi_get_value_string_utf8(env, args[6], nullptr, 0, &_name_size);
        assert(status == napi_ok);
        auto __arg6 = name;

        bool __ret = instance->Create(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Frame::Create: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::ShowFullScreen
static napi_value callback_method_wxSharp_Frame_ShowFullScreen(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ShowFullScreen(bool show, long style) override
overload0:
    {
        bool show;
        status = napi_get_value_bool(env, args[0], &show);
        auto __arg0 = (bool)show;

        int32_t style;
        status = napi_get_value_int32(env, args[1], &style);
        auto __arg1 = style;

        bool __ret = instance->ShowFullScreen(__arg0, __arg1);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Frame::ShowFullScreen: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::GetClientAreaOrigin
static napi_value callback_method_wxSharp_Frame_GetClientAreaOrigin(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::Point __ret = instance->GetClientAreaOrigin();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Point_Point, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;
    printf("wxSharp::Frame::GetClientAreaOrigin: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::SendIdleEvents
static napi_value callback_method_wxSharp_Frame_SendIdleEvents(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool SendIdleEvents(::wxSharp::IdleEvent& event) override
overload0:
    {
        wxSharp::IdleEvent* event_instance;
        status = napi_unwrap(env, _this, (void**) &event_instance);
        auto &__arg0 = *event_instance;

        bool __ret = instance->SendIdleEvents(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Frame::SendIdleEvents: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::New
static napi_value callback_method_wxSharp_Frame_New(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 7 || argc > 7)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_OBJECT(types[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[5], args[5]))
        goto typecheck6;

    goto error;

typecheck6:
    if (NAPI_IS_INT32(types[6], args[6]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Frame* New(::wxSharp::Window* parent, int winid, const char* title, const ::wxSharp::Point& pos, const ::wxSharp::Size& size, long style, const char* name)
overload0:
    {
        wxSharp::Window* parent_instance;
        status = napi_unwrap(env, _this, (void**) &parent_instance);
        auto __arg0 = parent_instance;

        int32_t winid;
        status = napi_get_value_int32(env, args[1], &winid);
        auto __arg1 = winid;

        size_t _title_size;
        status = napi_get_value_string_utf8(env, args[2], nullptr, 0, &_title_size);

        char* title = (char*) malloc(_title_size);
        status = napi_get_value_string_utf8(env, args[2], nullptr, 0, &_title_size);
        assert(status == napi_ok);
        auto __arg2 = title;

        wxSharp::Point* pos_instance;
        status = napi_unwrap(env, _this, (void**) &pos_instance);
        auto &__arg3 = *pos_instance;

        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg4 = *size_instance;

        int32_t style;
        status = napi_get_value_int32(env, args[5], &style);
        auto __arg5 = style;

        size_t _name_size;
        status = napi_get_value_string_utf8(env, args[6], nullptr, 0, &_name_size);

        char* name = (char*) malloc(_name_size);
        status = napi_get_value_string_utf8(env, args[6], nullptr, 0, &_name_size);
        assert(status == napi_ok);
        auto __arg6 = name;

        ::wxSharp::Frame* __ret = instance->New(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Frame_Frame, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Frame::New: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::ProcessCommand
static napi_value callback_method_wxSharp_Frame_ProcessCommand(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool ProcessCommand(int winid)
overload0:
    {
        int32_t winid;
        status = napi_get_value_int32(env, args[0], &winid);
        auto __arg0 = winid;

        bool __ret = instance->ProcessCommand(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Frame::ProcessCommand: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::SetStatusText
static napi_value callback_method_wxSharp_Frame_SetStatusText(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetStatusText(const char* text, int number)
overload0:
    {
        size_t _text_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);

        char* text = (char*) malloc(_text_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);
        assert(status == napi_ok);
        auto __arg0 = text;

        int32_t number;
        status = napi_get_value_int32(env, args[1], &number);
        auto __arg1 = number;

        instance->SetStatusText(__arg0, __arg1);
    }
    printf("wxSharp::Frame::SetStatusText: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::SetStatusWidths
static napi_value callback_method_wxSharp_Frame_SetStatusWidths(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_ARRAY(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetStatusWidths(int n, int widths_field[])
overload0:
    {
        int32_t n;
        status = napi_get_value_int32(env, args[0], &n);
        auto __arg0 = n;

        auto __arg1 = nullptr;
        instance->SetStatusWidths(__arg0, __arg1);
    }
    printf("wxSharp::Frame::SetStatusWidths: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::PushStatusText
static napi_value callback_method_wxSharp_Frame_PushStatusText(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void PushStatusText(const char* text, int number)
overload0:
    {
        size_t _text_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);

        char* text = (char*) malloc(_text_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);
        assert(status == napi_ok);
        auto __arg0 = text;

        int32_t number;
        status = napi_get_value_int32(env, args[1], &number);
        auto __arg1 = number;

        instance->PushStatusText(__arg0, __arg1);
    }
    printf("wxSharp::Frame::PushStatusText: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::PopStatusText
static napi_value callback_method_wxSharp_Frame_PopStatusText(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void PopStatusText(int number)
overload0:
    {
        int32_t number;
        status = napi_get_value_int32(env, args[0], &number);
        auto __arg0 = number;

        instance->PopStatusText(__arg0);
    }
    printf("wxSharp::Frame::PopStatusText: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::UpdateWindowUI
static napi_value callback_method_wxSharp_Frame_UpdateWindowUI(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void UpdateWindowUI(long flags) override
overload0:
    {
        int32_t flags;
        status = napi_get_value_int32(env, args[0], &flags);
        auto __arg0 = flags;

        instance->UpdateWindowUI(__arg0);
    }
    printf("wxSharp::Frame::UpdateWindowUI: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::OnInternalIdle
static napi_value callback_method_wxSharp_Frame_OnInternalIdle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->OnInternalIdle();
    printf("wxSharp::Frame::OnInternalIdle: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::DoGiveHelp
static napi_value callback_method_wxSharp_Frame_DoGiveHelp(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_BOOL(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DoGiveHelp(const char* text, bool show)
overload0:
    {
        size_t _text_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);

        char* text = (char*) malloc(_text_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_text_size);
        assert(status == napi_ok);
        auto __arg0 = text;

        bool show;
        status = napi_get_value_bool(env, args[1], &show);
        auto __arg1 = (bool)show;

        instance->DoGiveHelp(__arg0, __arg1);
    }
    printf("wxSharp::Frame::DoGiveHelp: %lu\n", argc);
    return _this;
}

// wxSharp::Frame::IsClientAreaChild
static napi_value callback_method_wxSharp_Frame_IsClientAreaChild(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Frame* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool IsClientAreaChild(const ::wxSharp::Window* child) const override
overload0:
    {
        wxSharp::Window* child_instance;
        status = napi_unwrap(env, _this, (void**) &child_instance);
        auto __arg0 = child_instance;

        bool __ret = instance->IsClientAreaChild(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Frame::IsClientAreaChild: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_Frame(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Create", nullptr, callback_method_wxSharp_Frame_Create, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ShowFullScreen", nullptr, callback_method_wxSharp_Frame_ShowFullScreen, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "GetClientAreaOrigin", nullptr, callback_method_wxSharp_Frame_GetClientAreaOrigin, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SendIdleEvents", nullptr, callback_method_wxSharp_Frame_SendIdleEvents, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "New", nullptr, callback_method_wxSharp_Frame_New, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ProcessCommand", nullptr, callback_method_wxSharp_Frame_ProcessCommand, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetStatusText", nullptr, callback_method_wxSharp_Frame_SetStatusText, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetStatusWidths", nullptr, callback_method_wxSharp_Frame_SetStatusWidths, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "PushStatusText", nullptr, callback_method_wxSharp_Frame_PushStatusText, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "PopStatusText", nullptr, callback_method_wxSharp_Frame_PopStatusText, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "UpdateWindowUI", nullptr, callback_method_wxSharp_Frame_UpdateWindowUI, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "OnInternalIdle", nullptr, callback_method_wxSharp_Frame_OnInternalIdle, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DoGiveHelp", nullptr, callback_method_wxSharp_Frame_DoGiveHelp, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "IsClientAreaChild", nullptr, callback_method_wxSharp_Frame_IsClientAreaChild, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "Frame", NAPI_AUTO_LENGTH, callback_method_wxSharp_Frame_Frame, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_Frame_Frame);
    assert(status == napi_ok);

    return constructor;
}

void register_wxsharp_frame(napi_env env, napi_value exports)
{
    napi_value value;

    value = register_enum_wxSharp_FrameFlags(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "FrameFlags", value));

    value = register_class_wxSharp_Frame(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Frame", value));
}
