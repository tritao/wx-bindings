// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <wxsharp/gdicmn.h>
#include <node/node_api.h>
#include <assert.h>
#include <stdio.h>
#include "NAPIHelpers.h"

extern napi_ref ctor_wxSharp_Color_Color;
extern napi_ref ctor_wxSharp_Brush_Brush;
extern napi_ref ctor_wxSharp_Pen_Pen;

static napi_value register_enum_wxSharp_BitmapType(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // INVALID
    napi_value i_0;
    status = napi_create_uint32(env, 0, &i_0);
    assert(status == napi_ok);

    // BMP
    napi_value i_1;
    status = napi_create_uint32(env, 1, &i_1);
    assert(status == napi_ok);

    // BMP_RESOURCE
    napi_value i_2;
    status = napi_create_uint32(env, 2, &i_2);
    assert(status == napi_ok);

    // RESOURCE
    napi_value i_3;
    status = napi_create_uint32(env, 2, &i_3);
    assert(status == napi_ok);

    // ICO
    napi_value i_4;
    status = napi_create_uint32(env, 3, &i_4);
    assert(status == napi_ok);

    // ICO_RESOURCE
    napi_value i_5;
    status = napi_create_uint32(env, 4, &i_5);
    assert(status == napi_ok);

    // CUR
    napi_value i_6;
    status = napi_create_uint32(env, 5, &i_6);
    assert(status == napi_ok);

    // CUR_RESOURCE
    napi_value i_7;
    status = napi_create_uint32(env, 6, &i_7);
    assert(status == napi_ok);

    // XBM
    napi_value i_8;
    status = napi_create_uint32(env, 7, &i_8);
    assert(status == napi_ok);

    // XBM_DATA
    napi_value i_9;
    status = napi_create_uint32(env, 8, &i_9);
    assert(status == napi_ok);

    // XPM
    napi_value i_10;
    status = napi_create_uint32(env, 9, &i_10);
    assert(status == napi_ok);

    // XPM_DATA
    napi_value i_11;
    status = napi_create_uint32(env, 10, &i_11);
    assert(status == napi_ok);

    // TIFF
    napi_value i_12;
    status = napi_create_uint32(env, 11, &i_12);
    assert(status == napi_ok);

    // TIF
    napi_value i_13;
    status = napi_create_uint32(env, 11, &i_13);
    assert(status == napi_ok);

    // TIFF_RESOURCE
    napi_value i_14;
    status = napi_create_uint32(env, 12, &i_14);
    assert(status == napi_ok);

    // TIF_RESOURCE
    napi_value i_15;
    status = napi_create_uint32(env, 12, &i_15);
    assert(status == napi_ok);

    // GIF
    napi_value i_16;
    status = napi_create_uint32(env, 13, &i_16);
    assert(status == napi_ok);

    // GIF_RESOURCE
    napi_value i_17;
    status = napi_create_uint32(env, 14, &i_17);
    assert(status == napi_ok);

    // PNG
    napi_value i_18;
    status = napi_create_uint32(env, 15, &i_18);
    assert(status == napi_ok);

    // PNG_RESOURCE
    napi_value i_19;
    status = napi_create_uint32(env, 16, &i_19);
    assert(status == napi_ok);

    // JPEG
    napi_value i_20;
    status = napi_create_uint32(env, 17, &i_20);
    assert(status == napi_ok);

    // JPEG_RESOURCE
    napi_value i_21;
    status = napi_create_uint32(env, 18, &i_21);
    assert(status == napi_ok);

    // PNM
    napi_value i_22;
    status = napi_create_uint32(env, 19, &i_22);
    assert(status == napi_ok);

    // PNM_RESOURCE
    napi_value i_23;
    status = napi_create_uint32(env, 20, &i_23);
    assert(status == napi_ok);

    // PCX
    napi_value i_24;
    status = napi_create_uint32(env, 21, &i_24);
    assert(status == napi_ok);

    // PCX_RESOURCE
    napi_value i_25;
    status = napi_create_uint32(env, 22, &i_25);
    assert(status == napi_ok);

    // PICT
    napi_value i_26;
    status = napi_create_uint32(env, 23, &i_26);
    assert(status == napi_ok);

    // PICT_RESOURCE
    napi_value i_27;
    status = napi_create_uint32(env, 24, &i_27);
    assert(status == napi_ok);

    // ICON
    napi_value i_28;
    status = napi_create_uint32(env, 25, &i_28);
    assert(status == napi_ok);

    // ICON_RESOURCE
    napi_value i_29;
    status = napi_create_uint32(env, 26, &i_29);
    assert(status == napi_ok);

    // ANI
    napi_value i_30;
    status = napi_create_uint32(env, 27, &i_30);
    assert(status == napi_ok);

    // IFF
    napi_value i_31;
    status = napi_create_uint32(env, 28, &i_31);
    assert(status == napi_ok);

    // TGA
    napi_value i_32;
    status = napi_create_uint32(env, 29, &i_32);
    assert(status == napi_ok);

    // MACCURSOR
    napi_value i_33;
    status = napi_create_uint32(env, 30, &i_33);
    assert(status == napi_ok);

    // MACCURSOR_RESOURCE
    napi_value i_34;
    status = napi_create_uint32(env, 31, &i_34);
    assert(status == napi_ok);

    // MAX
    napi_value i_35;
    status = napi_create_uint32(env, 32, &i_35);
    assert(status == napi_ok);

    // ANY
    napi_value i_36;
    status = napi_create_uint32(env, 50, &i_36);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "INVALID", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "BMP", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "BMP_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "RESOURCE", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr },
        { "ICO", nullptr, nullptr, nullptr, nullptr, i_4, attributes, nullptr },
        { "ICO_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_5, attributes, nullptr },
        { "CUR", nullptr, nullptr, nullptr, nullptr, i_6, attributes, nullptr },
        { "CUR_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_7, attributes, nullptr },
        { "XBM", nullptr, nullptr, nullptr, nullptr, i_8, attributes, nullptr },
        { "XBM_DATA", nullptr, nullptr, nullptr, nullptr, i_9, attributes, nullptr },
        { "XPM", nullptr, nullptr, nullptr, nullptr, i_10, attributes, nullptr },
        { "XPM_DATA", nullptr, nullptr, nullptr, nullptr, i_11, attributes, nullptr },
        { "TIFF", nullptr, nullptr, nullptr, nullptr, i_12, attributes, nullptr },
        { "TIF", nullptr, nullptr, nullptr, nullptr, i_13, attributes, nullptr },
        { "TIFF_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_14, attributes, nullptr },
        { "TIF_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_15, attributes, nullptr },
        { "GIF", nullptr, nullptr, nullptr, nullptr, i_16, attributes, nullptr },
        { "GIF_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_17, attributes, nullptr },
        { "PNG", nullptr, nullptr, nullptr, nullptr, i_18, attributes, nullptr },
        { "PNG_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_19, attributes, nullptr },
        { "JPEG", nullptr, nullptr, nullptr, nullptr, i_20, attributes, nullptr },
        { "JPEG_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_21, attributes, nullptr },
        { "PNM", nullptr, nullptr, nullptr, nullptr, i_22, attributes, nullptr },
        { "PNM_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_23, attributes, nullptr },
        { "PCX", nullptr, nullptr, nullptr, nullptr, i_24, attributes, nullptr },
        { "PCX_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_25, attributes, nullptr },
        { "PICT", nullptr, nullptr, nullptr, nullptr, i_26, attributes, nullptr },
        { "PICT_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_27, attributes, nullptr },
        { "ICON", nullptr, nullptr, nullptr, nullptr, i_28, attributes, nullptr },
        { "ICON_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_29, attributes, nullptr },
        { "ANI", nullptr, nullptr, nullptr, nullptr, i_30, attributes, nullptr },
        { "IFF", nullptr, nullptr, nullptr, nullptr, i_31, attributes, nullptr },
        { "TGA", nullptr, nullptr, nullptr, nullptr, i_32, attributes, nullptr },
        { "MACCURSOR", nullptr, nullptr, nullptr, nullptr, i_33, attributes, nullptr },
        { "MACCURSOR_RESOURCE", nullptr, nullptr, nullptr, nullptr, i_34, attributes, nullptr },
        { "MAX", nullptr, nullptr, nullptr, nullptr, i_35, attributes, nullptr },
        { "ANY", nullptr, nullptr, nullptr, nullptr, i_36, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_EllipsizeFlags(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // NONE
    napi_value i_0;
    status = napi_create_uint32(env, 0, &i_0);
    assert(status == napi_ok);

    // PROCESS_MNEMONICS
    napi_value i_1;
    status = napi_create_uint32(env, 1, &i_1);
    assert(status == napi_ok);

    // EXPAND_TABS
    napi_value i_2;
    status = napi_create_uint32(env, 2, &i_2);
    assert(status == napi_ok);

    // DEFAULT
    napi_value i_3;
    status = napi_create_uint32(env, 3, &i_3);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "NONE", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "PROCESS_MNEMONICS", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "EXPAND_TABS", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "DEFAULT", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_EllipsizeMode(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // NONE
    napi_value i_0;
    status = napi_create_uint32(env, 0, &i_0);
    assert(status == napi_ok);

    // START
    napi_value i_1;
    status = napi_create_uint32(env, 1, &i_1);
    assert(status == napi_ok);

    // MIDDLE
    napi_value i_2;
    status = napi_create_uint32(env, 2, &i_2);
    assert(status == napi_ok);

    // END
    napi_value i_3;
    status = napi_create_uint32(env, 3, &i_3);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "NONE", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "START", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "MIDDLE", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "END", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_PolygonFillMode(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // ODDEVEN_RULE
    napi_value i_0;
    status = napi_create_uint32(env, 1, &i_0);
    assert(status == napi_ok);

    // WINDING_RULE
    napi_value i_1;
    status = napi_create_uint32(env, 2, &i_1);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "ODDEVEN_RULE", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "WINDING_RULE", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_StockCursor(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // NONE
    napi_value i_0;
    status = napi_create_uint32(env, 0, &i_0);
    assert(status == napi_ok);

    // ARROW
    napi_value i_1;
    status = napi_create_uint32(env, 1, &i_1);
    assert(status == napi_ok);

    // RIGHT_ARROW
    napi_value i_2;
    status = napi_create_uint32(env, 2, &i_2);
    assert(status == napi_ok);

    // BULLSEYE
    napi_value i_3;
    status = napi_create_uint32(env, 3, &i_3);
    assert(status == napi_ok);

    // CHAR
    napi_value i_4;
    status = napi_create_uint32(env, 4, &i_4);
    assert(status == napi_ok);

    // CROSS
    napi_value i_5;
    status = napi_create_uint32(env, 5, &i_5);
    assert(status == napi_ok);

    // HAND
    napi_value i_6;
    status = napi_create_uint32(env, 6, &i_6);
    assert(status == napi_ok);

    // IBEAM
    napi_value i_7;
    status = napi_create_uint32(env, 7, &i_7);
    assert(status == napi_ok);

    // LEFT_BUTTON
    napi_value i_8;
    status = napi_create_uint32(env, 8, &i_8);
    assert(status == napi_ok);

    // MAGNIFIER
    napi_value i_9;
    status = napi_create_uint32(env, 9, &i_9);
    assert(status == napi_ok);

    // MIDDLE_BUTTON
    napi_value i_10;
    status = napi_create_uint32(env, 10, &i_10);
    assert(status == napi_ok);

    // NO_ENTRY
    napi_value i_11;
    status = napi_create_uint32(env, 11, &i_11);
    assert(status == napi_ok);

    // PAINT_BRUSH
    napi_value i_12;
    status = napi_create_uint32(env, 12, &i_12);
    assert(status == napi_ok);

    // PENCIL
    napi_value i_13;
    status = napi_create_uint32(env, 13, &i_13);
    assert(status == napi_ok);

    // POINT_LEFT
    napi_value i_14;
    status = napi_create_uint32(env, 14, &i_14);
    assert(status == napi_ok);

    // POINT_RIGHT
    napi_value i_15;
    status = napi_create_uint32(env, 15, &i_15);
    assert(status == napi_ok);

    // QUESTION_ARROW
    napi_value i_16;
    status = napi_create_uint32(env, 16, &i_16);
    assert(status == napi_ok);

    // RIGHT_BUTTON
    napi_value i_17;
    status = napi_create_uint32(env, 17, &i_17);
    assert(status == napi_ok);

    // SIZENESW
    napi_value i_18;
    status = napi_create_uint32(env, 18, &i_18);
    assert(status == napi_ok);

    // SIZENS
    napi_value i_19;
    status = napi_create_uint32(env, 19, &i_19);
    assert(status == napi_ok);

    // SIZENWSE
    napi_value i_20;
    status = napi_create_uint32(env, 20, &i_20);
    assert(status == napi_ok);

    // SIZEWE
    napi_value i_21;
    status = napi_create_uint32(env, 21, &i_21);
    assert(status == napi_ok);

    // SIZING
    napi_value i_22;
    status = napi_create_uint32(env, 22, &i_22);
    assert(status == napi_ok);

    // SPRAYCAN
    napi_value i_23;
    status = napi_create_uint32(env, 23, &i_23);
    assert(status == napi_ok);

    // WAIT
    napi_value i_24;
    status = napi_create_uint32(env, 24, &i_24);
    assert(status == napi_ok);

    // WATCH
    napi_value i_25;
    status = napi_create_uint32(env, 25, &i_25);
    assert(status == napi_ok);

    // BLANK
    napi_value i_26;
    status = napi_create_uint32(env, 26, &i_26);
    assert(status == napi_ok);

    // DEFAULT
    napi_value i_27;
    status = napi_create_uint32(env, 27, &i_27);
    assert(status == napi_ok);

    // ARROWWAIT
    napi_value i_28;
    status = napi_create_uint32(env, 28, &i_28);
    assert(status == napi_ok);

    // MAX
    napi_value i_29;
    status = napi_create_uint32(env, 29, &i_29);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "NONE", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "ARROW", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "RIGHT_ARROW", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "BULLSEYE", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr },
        { "CHAR", nullptr, nullptr, nullptr, nullptr, i_4, attributes, nullptr },
        { "CROSS", nullptr, nullptr, nullptr, nullptr, i_5, attributes, nullptr },
        { "HAND", nullptr, nullptr, nullptr, nullptr, i_6, attributes, nullptr },
        { "IBEAM", nullptr, nullptr, nullptr, nullptr, i_7, attributes, nullptr },
        { "LEFT_BUTTON", nullptr, nullptr, nullptr, nullptr, i_8, attributes, nullptr },
        { "MAGNIFIER", nullptr, nullptr, nullptr, nullptr, i_9, attributes, nullptr },
        { "MIDDLE_BUTTON", nullptr, nullptr, nullptr, nullptr, i_10, attributes, nullptr },
        { "NO_ENTRY", nullptr, nullptr, nullptr, nullptr, i_11, attributes, nullptr },
        { "PAINT_BRUSH", nullptr, nullptr, nullptr, nullptr, i_12, attributes, nullptr },
        { "PENCIL", nullptr, nullptr, nullptr, nullptr, i_13, attributes, nullptr },
        { "POINT_LEFT", nullptr, nullptr, nullptr, nullptr, i_14, attributes, nullptr },
        { "POINT_RIGHT", nullptr, nullptr, nullptr, nullptr, i_15, attributes, nullptr },
        { "QUESTION_ARROW", nullptr, nullptr, nullptr, nullptr, i_16, attributes, nullptr },
        { "RIGHT_BUTTON", nullptr, nullptr, nullptr, nullptr, i_17, attributes, nullptr },
        { "SIZENESW", nullptr, nullptr, nullptr, nullptr, i_18, attributes, nullptr },
        { "SIZENS", nullptr, nullptr, nullptr, nullptr, i_19, attributes, nullptr },
        { "SIZENWSE", nullptr, nullptr, nullptr, nullptr, i_20, attributes, nullptr },
        { "SIZEWE", nullptr, nullptr, nullptr, nullptr, i_21, attributes, nullptr },
        { "SIZING", nullptr, nullptr, nullptr, nullptr, i_22, attributes, nullptr },
        { "SPRAYCAN", nullptr, nullptr, nullptr, nullptr, i_23, attributes, nullptr },
        { "WAIT", nullptr, nullptr, nullptr, nullptr, i_24, attributes, nullptr },
        { "WATCH", nullptr, nullptr, nullptr, nullptr, i_25, attributes, nullptr },
        { "BLANK", nullptr, nullptr, nullptr, nullptr, i_26, attributes, nullptr },
        { "DEFAULT", nullptr, nullptr, nullptr, nullptr, i_27, attributes, nullptr },
        { "ARROWWAIT", nullptr, nullptr, nullptr, nullptr, i_28, attributes, nullptr },
        { "MAX", nullptr, nullptr, nullptr, nullptr, i_29, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static void dtor_wxSharp_Size_Size(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_Size_Size;

// wxSharp::Size::Size
static napi_value callback_method_wxSharp_Size_Size(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Size* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // Size()
overload0:
    {
        instance = new wxSharp::Size();
    }

    // Size(int xx, int yy)
overload1:
    {
        int32_t xx;
        status = napi_get_value_int32(env, args[0], &xx);
        auto __arg0 = xx;

        int32_t yy;
        status = napi_get_value_int32(env, args[1], &yy);
        auto __arg1 = yy;

        instance = new wxSharp::Size(__arg0, __arg1);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_Size_Size, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::Size::Size: %lu\n", argc);
    return _this;
}

// wxSharp::Size::IncTo
static napi_value callback_method_wxSharp_Size_IncTo(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Size* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void IncTo(const ::wxSharp::Size& sz)
overload0:
    {
        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg0 = *sz_instance;

        instance->IncTo(__arg0);
    }
    printf("wxSharp::Size::IncTo: %lu\n", argc);
    return _this;
}

// wxSharp::Size::DecTo
static napi_value callback_method_wxSharp_Size_DecTo(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Size* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DecTo(const ::wxSharp::Size& sz)
overload0:
    {
        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg0 = *sz_instance;

        instance->DecTo(__arg0);
    }
    printf("wxSharp::Size::DecTo: %lu\n", argc);
    return _this;
}

// wxSharp::Size::DecToIfSpecified
static napi_value callback_method_wxSharp_Size_DecToIfSpecified(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Size* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DecToIfSpecified(const ::wxSharp::Size& sz)
overload0:
    {
        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg0 = *sz_instance;

        instance->DecToIfSpecified(__arg0);
    }
    printf("wxSharp::Size::DecToIfSpecified: %lu\n", argc);
    return _this;
}

// wxSharp::Size::IncBy
static napi_value callback_method_wxSharp_Size_IncBy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Size* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void IncBy(int dx, int dy)
overload0:
    {
        int32_t dx;
        status = napi_get_value_int32(env, args[0], &dx);
        auto __arg0 = dx;

        int32_t dy;
        status = napi_get_value_int32(env, args[1], &dy);
        auto __arg1 = dy;

        instance->IncBy(__arg0, __arg1);
    }

    // void IncBy(const ::wxSharp::Point& pt)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        instance->IncBy(__arg0);
    }

    // void IncBy(const ::wxSharp::Size& sz)
overload2:
    {
        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg0 = *sz_instance;

        instance->IncBy(__arg0);
    }

    // void IncBy(int d)
overload3:
    {
        int32_t d;
        status = napi_get_value_int32(env, args[0], &d);
        auto __arg0 = d;

        instance->IncBy(__arg0);
    }
    printf("wxSharp::Size::IncBy: %lu\n", argc);
    return _this;
}

// wxSharp::Size::DecBy
static napi_value callback_method_wxSharp_Size_DecBy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Size* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void DecBy(int dx, int dy)
overload0:
    {
        int32_t dx;
        status = napi_get_value_int32(env, args[0], &dx);
        auto __arg0 = dx;

        int32_t dy;
        status = napi_get_value_int32(env, args[1], &dy);
        auto __arg1 = dy;

        instance->DecBy(__arg0, __arg1);
    }

    // void DecBy(const ::wxSharp::Point& pt)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        instance->DecBy(__arg0);
    }

    // void DecBy(const ::wxSharp::Size& sz)
overload2:
    {
        wxSharp::Size* sz_instance;
        status = napi_unwrap(env, _this, (void**) &sz_instance);
        auto &__arg0 = *sz_instance;

        instance->DecBy(__arg0);
    }

    // void DecBy(int d)
overload3:
    {
        int32_t d;
        status = napi_get_value_int32(env, args[0], &d);
        auto __arg0 = d;

        instance->DecBy(__arg0);
    }
    printf("wxSharp::Size::DecBy: %lu\n", argc);
    return _this;
}

// wxSharp::Size::Set
static napi_value callback_method_wxSharp_Size_Set(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Size* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void Set(int xx, int yy)
overload0:
    {
        int32_t xx;
        status = napi_get_value_int32(env, args[0], &xx);
        auto __arg0 = xx;

        int32_t yy;
        status = napi_get_value_int32(env, args[1], &yy);
        auto __arg1 = yy;

        instance->Set(__arg0, __arg1);
    }
    printf("wxSharp::Size::Set: %lu\n", argc);
    return _this;
}

// wxSharp::Size::SetDefaults
static napi_value callback_method_wxSharp_Size_SetDefaults(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Size* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetDefaults(const ::wxSharp::Size& size)
overload0:
    {
        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg0 = *size_instance;

        instance->SetDefaults(__arg0);
    }
    printf("wxSharp::Size::SetDefaults: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_Size(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "IncTo", nullptr, callback_method_wxSharp_Size_IncTo, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DecTo", nullptr, callback_method_wxSharp_Size_DecTo, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DecToIfSpecified", nullptr, callback_method_wxSharp_Size_DecToIfSpecified, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "IncBy", nullptr, callback_method_wxSharp_Size_IncBy, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DecBy", nullptr, callback_method_wxSharp_Size_DecBy, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Set", nullptr, callback_method_wxSharp_Size_Set, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetDefaults", nullptr, callback_method_wxSharp_Size_SetDefaults, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "Size", NAPI_AUTO_LENGTH, callback_method_wxSharp_Size_Size, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_Size_Size);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_RealPoint_RealPoint(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_RealPoint_RealPoint;

// wxSharp::RealPoint::RealPoint
static napi_value callback_method_wxSharp_RealPoint_RealPoint(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::RealPoint* instance = nullptr;

    if (NAPI_IS_NUMBER(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

typecheck1:
    if (NAPI_IS_NUMBER(types[1]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // RealPoint()
overload0:
    {
        instance = new wxSharp::RealPoint();
    }

    // RealPoint(double xx, double yy)
overload1:
    {
        double xx;
        status = napi_get_value_double(env, args[0], &xx);
        auto __arg0 = xx;

        double yy;
        status = napi_get_value_double(env, args[1], &yy);
        auto __arg1 = yy;

        instance = new wxSharp::RealPoint(__arg0, __arg1);
    }

    // RealPoint(const ::wxSharp::Point& pt)
overload2:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        instance = new wxSharp::RealPoint(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_RealPoint_RealPoint, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::RealPoint::RealPoint: %lu\n", argc);
    return _this;
}

// wxSharp::RealPoint::set_x
static napi_value callback_method_wxSharp_RealPoint_set_x(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::RealPoint* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_NUMBER(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_x(double value)
overload0:
    {
        double value;
        status = napi_get_value_double(env, args[0], &value);
        auto __arg0 = value;

        instance->set_x(__arg0);
    }
    printf("wxSharp::RealPoint::set_x: %lu\n", argc);
    return _this;
}

// wxSharp::RealPoint::set_y
static napi_value callback_method_wxSharp_RealPoint_set_y(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::RealPoint* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_NUMBER(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_y(double value)
overload0:
    {
        double value;
        status = napi_get_value_double(env, args[0], &value);
        auto __arg0 = value;

        instance->set_y(__arg0);
    }
    printf("wxSharp::RealPoint::set_y: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_RealPoint(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "set_x", nullptr, callback_method_wxSharp_RealPoint_set_x, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_y", nullptr, callback_method_wxSharp_RealPoint_set_y, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "RealPoint", NAPI_AUTO_LENGTH, callback_method_wxSharp_RealPoint_RealPoint, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_RealPoint_RealPoint);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_Point_Point(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_Point_Point;

// wxSharp::Point::Point
static napi_value callback_method_wxSharp_Point_Point(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Point* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // Point()
overload0:
    {
        instance = new wxSharp::Point();
    }

    // Point(int xx, int yy)
overload1:
    {
        int32_t xx;
        status = napi_get_value_int32(env, args[0], &xx);
        auto __arg0 = xx;

        int32_t yy;
        status = napi_get_value_int32(env, args[1], &yy);
        auto __arg1 = yy;

        instance = new wxSharp::Point(__arg0, __arg1);
    }

    // Point(const ::wxSharp::RealPoint& pt)
overload2:
    {
        wxSharp::RealPoint* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        instance = new wxSharp::Point(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_Point_Point, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::Point::Point: %lu\n", argc);
    return _this;
}

// wxSharp::Point::SetDefaults
static napi_value callback_method_wxSharp_Point_SetDefaults(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Point* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetDefaults(const ::wxSharp::Point& pt)
overload0:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        instance->SetDefaults(__arg0);
    }
    printf("wxSharp::Point::SetDefaults: %lu\n", argc);
    return _this;
}

// wxSharp::Point::set_x
static napi_value callback_method_wxSharp_Point_set_x(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Point* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_x(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_x(__arg0);
    }
    printf("wxSharp::Point::set_x: %lu\n", argc);
    return _this;
}

// wxSharp::Point::set_y
static napi_value callback_method_wxSharp_Point_set_y(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Point* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void set_y(int value)
overload0:
    {
        int32_t value;
        status = napi_get_value_int32(env, args[0], &value);
        auto __arg0 = value;

        instance->set_y(__arg0);
    }
    printf("wxSharp::Point::set_y: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_Point(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "SetDefaults", nullptr, callback_method_wxSharp_Point_SetDefaults, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_x", nullptr, callback_method_wxSharp_Point_set_x, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "set_y", nullptr, callback_method_wxSharp_Point_set_y, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "Point", NAPI_AUTO_LENGTH, callback_method_wxSharp_Point_Point, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_Point_Point);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_wxPointListNode_wxPointListNode(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_wxPointListNode_wxPointListNode;

// wxSharp::wxPointListNode::wxPointListNode
static napi_value callback_method_wxSharp_wxPointListNode_wxPointListNode(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::wxPointListNode* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // wxPointListNode
overload0:
    {
        wxSharp::wxPointListNode* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::wxPointListNode(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_wxPointListNode_wxPointListNode, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::wxPointListNode::wxPointListNode: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_wxPointListNode(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }

    };

    napi_value constructor;
    status = napi_define_class(env, "wxPointListNode", NAPI_AUTO_LENGTH, callback_method_wxSharp_wxPointListNode_wxPointListNode, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_wxPointListNode_wxPointListNode);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_Rect_Rect(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_Rect_Rect;

// wxSharp::Rect::Rect
static napi_value callback_method_wxSharp_Rect_Rect(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload2;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload4;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // Rect()
overload0:
    {
        instance = new wxSharp::Rect();
    }

    // Rect(int xx, int yy, int ww, int hh)
overload1:
    {
        int32_t xx;
        status = napi_get_value_int32(env, args[0], &xx);
        auto __arg0 = xx;

        int32_t yy;
        status = napi_get_value_int32(env, args[1], &yy);
        auto __arg1 = yy;

        int32_t ww;
        status = napi_get_value_int32(env, args[2], &ww);
        auto __arg2 = ww;

        int32_t hh;
        status = napi_get_value_int32(env, args[3], &hh);
        auto __arg3 = hh;

        instance = new wxSharp::Rect(__arg0, __arg1, __arg2, __arg3);
    }

    // Rect(const ::wxSharp::Point& topLeft, const ::wxSharp::Point& bottomRight)
overload2:
    {
        wxSharp::Point* topLeft_instance;
        status = napi_unwrap(env, _this, (void**) &topLeft_instance);
        auto &__arg0 = *topLeft_instance;

        wxSharp::Point* bottomRight_instance;
        status = napi_unwrap(env, _this, (void**) &bottomRight_instance);
        auto &__arg1 = *bottomRight_instance;

        instance = new wxSharp::Rect(__arg0, __arg1);
    }

    // Rect(const ::wxSharp::Point& pt, const ::wxSharp::Size& size)
overload3:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg1 = *size_instance;

        instance = new wxSharp::Rect(__arg0, __arg1);
    }

    // Rect(const ::wxSharp::Size& size)
overload4:
    {
        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg0 = *size_instance;

        instance = new wxSharp::Rect(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_Rect_Rect, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::Rect::Rect: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::SetX
static napi_value callback_method_wxSharp_Rect_SetX(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetX(int xx)
overload0:
    {
        int32_t xx;
        status = napi_get_value_int32(env, args[0], &xx);
        auto __arg0 = xx;

        instance->SetX(__arg0);
    }
    printf("wxSharp::Rect::SetX: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::SetY
static napi_value callback_method_wxSharp_Rect_SetY(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetY(int yy)
overload0:
    {
        int32_t yy;
        status = napi_get_value_int32(env, args[0], &yy);
        auto __arg0 = yy;

        instance->SetY(__arg0);
    }
    printf("wxSharp::Rect::SetY: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::SetWidth
static napi_value callback_method_wxSharp_Rect_SetWidth(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetWidth(int w)
overload0:
    {
        int32_t w;
        status = napi_get_value_int32(env, args[0], &w);
        auto __arg0 = w;

        instance->SetWidth(__arg0);
    }
    printf("wxSharp::Rect::SetWidth: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::SetHeight
static napi_value callback_method_wxSharp_Rect_SetHeight(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetHeight(int h)
overload0:
    {
        int32_t h;
        status = napi_get_value_int32(env, args[0], &h);
        auto __arg0 = h;

        instance->SetHeight(__arg0);
    }
    printf("wxSharp::Rect::SetHeight: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::Inflate
static napi_value callback_method_wxSharp_Rect_Inflate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Rect Inflate(int dx, int dy) const
overload0:
    {
        int32_t dx;
        status = napi_get_value_int32(env, args[0], &dx);
        auto __arg0 = dx;

        int32_t dy;
        status = napi_get_value_int32(env, args[1], &dy);
        auto __arg1 = dy;

        ::wxSharp::Rect __ret = instance->Inflate(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Rect_Rect, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Rect::Inflate: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::Deflate
static napi_value callback_method_wxSharp_Rect_Deflate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Rect Deflate(int dx, int dy) const
overload0:
    {
        int32_t dx;
        status = napi_get_value_int32(env, args[0], &dx);
        auto __arg0 = dx;

        int32_t dy;
        status = napi_get_value_int32(env, args[1], &dy);
        auto __arg1 = dy;

        ::wxSharp::Rect __ret = instance->Deflate(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Rect_Rect, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Rect::Deflate: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::Offset
static napi_value callback_method_wxSharp_Rect_Offset(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void Offset(int dx, int dy)
overload0:
    {
        int32_t dx;
        status = napi_get_value_int32(env, args[0], &dx);
        auto __arg0 = dx;

        int32_t dy;
        status = napi_get_value_int32(env, args[1], &dy);
        auto __arg1 = dy;

        instance->Offset(__arg0, __arg1);
    }

    // void Offset(const ::wxSharp::Point& pt)
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        instance->Offset(__arg0);
    }
    printf("wxSharp::Rect::Offset: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::Intersect
static napi_value callback_method_wxSharp_Rect_Intersect(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Rect Intersect(const ::wxSharp::Rect& rect) const
overload0:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        ::wxSharp::Rect __ret = instance->Intersect(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Rect_Rect, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Rect::Intersect: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::Union
static napi_value callback_method_wxSharp_Rect_Union(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Rect Union(const ::wxSharp::Rect& rect) const
overload0:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        ::wxSharp::Rect __ret = instance->Union(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Rect_Rect, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Rect::Union: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::Contains
static napi_value callback_method_wxSharp_Rect_Contains(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Contains(int x, int y) const
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        bool __ret = instance->Contains(__arg0, __arg1);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Contains(const ::wxSharp::Point& pt) const
overload1:
    {
        wxSharp::Point* pt_instance;
        status = napi_unwrap(env, _this, (void**) &pt_instance);
        auto &__arg0 = *pt_instance;

        bool __ret = instance->Contains(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Contains(const ::wxSharp::Rect& rect) const
overload2:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        bool __ret = instance->Contains(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Rect::Contains: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::Intersects
static napi_value callback_method_wxSharp_Rect_Intersects(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Intersects(const ::wxSharp::Rect& rect) const
overload0:
    {
        wxSharp::Rect* rect_instance;
        status = napi_unwrap(env, _this, (void**) &rect_instance);
        auto &__arg0 = *rect_instance;

        bool __ret = instance->Intersects(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Rect::Intersects: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::CentreIn
static napi_value callback_method_wxSharp_Rect_CentreIn(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Rect CentreIn(const ::wxSharp::Rect& r, int dir) const
overload0:
    {
        wxSharp::Rect* r_instance;
        status = napi_unwrap(env, _this, (void**) &r_instance);
        auto &__arg0 = *r_instance;

        int32_t dir;
        status = napi_get_value_int32(env, args[1], &dir);
        auto __arg1 = dir;

        ::wxSharp::Rect __ret = instance->CentreIn(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Rect_Rect, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Rect::CentreIn: %lu\n", argc);
    return _this;
}

// wxSharp::Rect::CenterIn
static napi_value callback_method_wxSharp_Rect_CenterIn(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Rect* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Rect CenterIn(const ::wxSharp::Rect& r, int dir) const
overload0:
    {
        wxSharp::Rect* r_instance;
        status = napi_unwrap(env, _this, (void**) &r_instance);
        auto &__arg0 = *r_instance;

        int32_t dir;
        status = napi_get_value_int32(env, args[1], &dir);
        auto __arg1 = dir;

        ::wxSharp::Rect __ret = instance->CenterIn(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Rect_Rect, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Rect::CenterIn: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_Rect(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "SetX", nullptr, callback_method_wxSharp_Rect_SetX, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetY", nullptr, callback_method_wxSharp_Rect_SetY, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetWidth", nullptr, callback_method_wxSharp_Rect_SetWidth, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetHeight", nullptr, callback_method_wxSharp_Rect_SetHeight, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Inflate", nullptr, callback_method_wxSharp_Rect_Inflate, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Deflate", nullptr, callback_method_wxSharp_Rect_Deflate, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Offset", nullptr, callback_method_wxSharp_Rect_Offset, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Intersect", nullptr, callback_method_wxSharp_Rect_Intersect, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Union", nullptr, callback_method_wxSharp_Rect_Union, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Contains", nullptr, callback_method_wxSharp_Rect_Contains, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Intersects", nullptr, callback_method_wxSharp_Rect_Intersects, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "CentreIn", nullptr, callback_method_wxSharp_Rect_CentreIn, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "CenterIn", nullptr, callback_method_wxSharp_Rect_CenterIn, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "Rect", NAPI_AUTO_LENGTH, callback_method_wxSharp_Rect_Rect, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_Rect_Rect);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_GDIObjListBase_GDIObjListBase(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_GDIObjListBase_GDIObjListBase;

// wxSharp::GDIObjListBase::GDIObjListBase
static napi_value callback_method_wxSharp_GDIObjListBase_GDIObjListBase(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::GDIObjListBase* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // GDIObjListBase()
overload0:
    {
        instance = new wxSharp::GDIObjListBase();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_GDIObjListBase_GDIObjListBase, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::GDIObjListBase::GDIObjListBase: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_GDIObjListBase(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }

    };

    napi_value constructor;
    status = napi_define_class(env, "GDIObjListBase", NAPI_AUTO_LENGTH, callback_method_wxSharp_GDIObjListBase_GDIObjListBase, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_GDIObjListBase_GDIObjListBase);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_ColourDatabase_ColourDatabase(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_ColourDatabase_ColourDatabase;

// wxSharp::ColourDatabase::ColourDatabase
static napi_value callback_method_wxSharp_ColourDatabase_ColourDatabase(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ColourDatabase* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ColourDatabase()
overload0:
    {
        instance = new wxSharp::ColourDatabase();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_ColourDatabase_ColourDatabase, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::ColourDatabase::ColourDatabase: %lu\n", argc);
    return _this;
}

// wxSharp::ColourDatabase::Find
static napi_value callback_method_wxSharp_ColourDatabase_Find(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ColourDatabase* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Color Find(const char* name) const
overload0:
    {
        size_t _name_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_name_size);

        char* name = (char*) malloc(_name_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_name_size);
        assert(status == napi_ok);
        auto __arg0 = name;

        ::wxSharp::Color __ret = instance->Find(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Color_Color, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::ColourDatabase::Find: %lu\n", argc);
    return _this;
}

// wxSharp::ColourDatabase::FindName
static napi_value callback_method_wxSharp_ColourDatabase_FindName(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ColourDatabase* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // char* FindName(const ::wxSharp::Color& colour) const
overload0:
    {
        wxSharp::Color* colour_instance;
        status = napi_unwrap(env, _this, (void**) &colour_instance);
        auto &__arg0 = *colour_instance;

        const char* __ret = instance->FindName(__arg0);

        napi_value __result;
        status = napi_create_string_latin1(env, __ret, NAPI_AUTO_LENGTH, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::ColourDatabase::FindName: %lu\n", argc);
    return _this;
}

// wxSharp::ColourDatabase::AddColour
static napi_value callback_method_wxSharp_ColourDatabase_AddColour(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ColourDatabase* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void AddColour(const char* name, const ::wxSharp::Color& colour)
overload0:
    {
        size_t _name_size;
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_name_size);

        char* name = (char*) malloc(_name_size);
        status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &_name_size);
        assert(status == napi_ok);
        auto __arg0 = name;

        wxSharp::Color* colour_instance;
        status = napi_unwrap(env, _this, (void**) &colour_instance);
        auto &__arg1 = *colour_instance;

        instance->AddColour(__arg0, __arg1);
    }
    printf("wxSharp::ColourDatabase::AddColour: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_ColourDatabase(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Find", nullptr, callback_method_wxSharp_ColourDatabase_Find, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "FindName", nullptr, callback_method_wxSharp_ColourDatabase_FindName, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "AddColour", nullptr, callback_method_wxSharp_ColourDatabase_AddColour, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "ColourDatabase", NAPI_AUTO_LENGTH, callback_method_wxSharp_ColourDatabase_ColourDatabase, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_ColourDatabase_ColourDatabase);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_ResourceCache_ResourceCache(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_ResourceCache_ResourceCache;

// wxSharp::ResourceCache::ResourceCache
static napi_value callback_method_wxSharp_ResourceCache_ResourceCache(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::ResourceCache* instance = nullptr;

    if (NAPI_IS_UINT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ResourceCache()
overload0:
    {
        instance = new wxSharp::ResourceCache();
    }

    // ResourceCache(unsigned int keyType)
overload1:
    {
        uint32_t keyType;
        status = napi_get_value_uint32(env, args[0], &keyType);
        auto __arg0 = keyType;

        instance = new wxSharp::ResourceCache(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_ResourceCache_ResourceCache, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::ResourceCache::ResourceCache: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_ResourceCache(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }

    };

    napi_value constructor;
    status = napi_define_class(env, "ResourceCache", NAPI_AUTO_LENGTH, callback_method_wxSharp_ResourceCache_ResourceCache, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_ResourceCache_ResourceCache);
    assert(status == napi_ok);

    return constructor;
}

enum class Item : unsigned int
{
    BRUSH_BLACK = 0,
    BRUSH_BLUE = 1,
    BRUSH_CYAN = 2,
    BRUSH_GREEN = 3,
    BRUSH_YELLOW = 4,
    BRUSH_GREY = 5,
    BRUSH_LIGHTGREY = 6,
    BRUSH_MEDIUMGREY = 7,
    BRUSH_RED = 8,
    BRUSH_TRANSPARENT = 9,
    BRUSH_WHITE = 10,
    COLOUR_BLACK = 11,
    COLOUR_BLUE = 12,
    COLOUR_CYAN = 13,
    COLOUR_GREEN = 14,
    COLOUR_YELLOW = 15,
    COLOUR_LIGHTGREY = 16,
    COLOUR_RED = 17,
    COLOUR_WHITE = 18,
    CURSOR_CROSS = 19,
    CURSOR_HOURGLASS = 20,
    CURSOR_STANDARD = 21,
    FONT_ITALIC = 22,
    FONT_NORMAL = 23,
    FONT_SMALL = 24,
    FONT_SWISS = 25,
    PEN_BLACK = 26,
    PEN_BLACKDASHED = 27,
    PEN_BLUE = 28,
    PEN_CYAN = 29,
    PEN_GREEN = 30,
    PEN_YELLOW = 31,
    PEN_GREY = 32,
    PEN_LIGHTGREY = 33,
    PEN_MEDIUMGREY = 34,
    PEN_RED = 35,
    PEN_TRANSPARENT = 36,
    PEN_WHITE = 37,
    ITEMCOUNT = 38
};

static void dtor_wxSharp_StockGDI_StockGDI(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_StockGDI_StockGDI;

// wxSharp::StockGDI::StockGDI
static napi_value callback_method_wxSharp_StockGDI_StockGDI(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::StockGDI* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // StockGDI()
overload0:
    {
        instance = new wxSharp::StockGDI();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_StockGDI_StockGDI, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::StockGDI::StockGDI: %lu\n", argc);
    return _this;
}

// wxSharp::StockGDI::DeleteAll
static napi_value callback_method_wxSharp_StockGDI_DeleteAll(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::StockGDI* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    ::wxSharp::StockGDI::DeleteAll();
    printf("wxSharp::StockGDI::DeleteAll: %lu\n", argc);
    return _this;
}

// wxSharp::StockGDI::GetBrush
static napi_value callback_method_wxSharp_StockGDI_GetBrush(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::StockGDI* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Brush* GetBrush(::wxSharp::StockGDI::Item item)
overload0:
    {
        int32_t item;
        status = napi_get_value_int32(env, args[0], &item);
        auto __arg0 = (::wxSharp::StockGDI::Item)item;

        const ::wxSharp::Brush* __ret = ::wxSharp::StockGDI::GetBrush(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Brush_Brush, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::StockGDI::GetBrush: %lu\n", argc);
    return _this;
}

// wxSharp::StockGDI::GetColour
static napi_value callback_method_wxSharp_StockGDI_GetColour(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::StockGDI* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Color* GetColour(::wxSharp::StockGDI::Item item)
overload0:
    {
        int32_t item;
        status = napi_get_value_int32(env, args[0], &item);
        auto __arg0 = (::wxSharp::StockGDI::Item)item;

        const ::wxSharp::Color* __ret = ::wxSharp::StockGDI::GetColour(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Color_Color, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::StockGDI::GetColour: %lu\n", argc);
    return _this;
}

// wxSharp::StockGDI::GetPen
static napi_value callback_method_wxSharp_StockGDI_GetPen(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::StockGDI* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Pen* GetPen(::wxSharp::StockGDI::Item item)
overload0:
    {
        int32_t item;
        status = napi_get_value_int32(env, args[0], &item);
        auto __arg0 = (::wxSharp::StockGDI::Item)item;

        const ::wxSharp::Pen* __ret = ::wxSharp::StockGDI::GetPen(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Pen_Pen, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::StockGDI::GetPen: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_StockGDI(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "DeleteAll", nullptr, callback_method_wxSharp_StockGDI_DeleteAll, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes | napi_static), nullptr },
        { "GetBrush", nullptr, callback_method_wxSharp_StockGDI_GetBrush, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes | napi_static), nullptr },
        { "GetColour", nullptr, callback_method_wxSharp_StockGDI_GetColour, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes | napi_static), nullptr },
        { "GetPen", nullptr, callback_method_wxSharp_StockGDI_GetPen, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes | napi_static), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "StockGDI", NAPI_AUTO_LENGTH, callback_method_wxSharp_StockGDI_StockGDI, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_StockGDI_StockGDI);
    assert(status == napi_ok);

    return constructor;
}

// wxSharp::InitializeStockLists
static napi_value callback_function_wxSharp_InitializeStockLists(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    ::wxSharp::InitializeStockLists();

    return nullptr;
}

static napi_value register_function_wxSharp_InitializeStockLists(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_InitializeStockLists;
    status = napi_create_function(env, "InitializeStockLists", NAPI_AUTO_LENGTH, callback_function_wxSharp_InitializeStockLists, 0, &_wxSharp_InitializeStockLists);
    assert(status == napi_ok);

    return _wxSharp_InitializeStockLists;
}

// wxSharp::DeleteStockLists
static napi_value callback_function_wxSharp_DeleteStockLists(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    ::wxSharp::DeleteStockLists();

    return nullptr;
}

static napi_value register_function_wxSharp_DeleteStockLists(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_DeleteStockLists;
    status = napi_create_function(env, "DeleteStockLists", NAPI_AUTO_LENGTH, callback_function_wxSharp_DeleteStockLists, 0, &_wxSharp_DeleteStockLists);
    assert(status == napi_ok);

    return _wxSharp_DeleteStockLists;
}

// wxSharp::ColourDisplay
static napi_value callback_function_wxSharp_ColourDisplay(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    bool __ret = ::wxSharp::ColourDisplay();

    napi_value __result;
    status = napi_get_boolean(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;

    return nullptr;
}

static napi_value register_function_wxSharp_ColourDisplay(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_ColourDisplay;
    status = napi_create_function(env, "ColourDisplay", NAPI_AUTO_LENGTH, callback_function_wxSharp_ColourDisplay, 0, &_wxSharp_ColourDisplay);
    assert(status == napi_ok);

    return _wxSharp_ColourDisplay;
}

// wxSharp::DisplayDepth
static napi_value callback_function_wxSharp_DisplayDepth(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    int __ret = ::wxSharp::DisplayDepth();

    napi_value __result;
    status = napi_create_int32(env, __ret, &__result);
    assert(status == napi_ok);

    return __result;

    return nullptr;
}

static napi_value register_function_wxSharp_DisplayDepth(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_DisplayDepth;
    status = napi_create_function(env, "DisplayDepth", NAPI_AUTO_LENGTH, callback_function_wxSharp_DisplayDepth, 0, &_wxSharp_DisplayDepth);
    assert(status == napi_ok);

    return _wxSharp_DisplayDepth;
}

// wxSharp::GetDisplaySize
static napi_value callback_function_wxSharp_GetDisplaySize(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    ::wxSharp::Size __ret = ::wxSharp::GetDisplaySize();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Size_Size, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;

    return nullptr;
}

static napi_value register_function_wxSharp_GetDisplaySize(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_GetDisplaySize;
    status = napi_create_function(env, "GetDisplaySize", NAPI_AUTO_LENGTH, callback_function_wxSharp_GetDisplaySize, 0, &_wxSharp_GetDisplaySize);
    assert(status == napi_ok);

    return _wxSharp_GetDisplaySize;
}

// wxSharp::GetDisplaySizeMM
static napi_value callback_function_wxSharp_GetDisplaySizeMM(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    ::wxSharp::Size __ret = ::wxSharp::GetDisplaySizeMM();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Size_Size, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;

    return nullptr;
}

static napi_value register_function_wxSharp_GetDisplaySizeMM(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_GetDisplaySizeMM;
    status = napi_create_function(env, "GetDisplaySizeMM", NAPI_AUTO_LENGTH, callback_function_wxSharp_GetDisplaySizeMM, 0, &_wxSharp_GetDisplaySizeMM);
    assert(status == napi_ok);

    return _wxSharp_GetDisplaySizeMM;
}

// wxSharp::GetDisplayPPI
static napi_value callback_function_wxSharp_GetDisplayPPI(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    ::wxSharp::Size __ret = ::wxSharp::GetDisplayPPI();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Size_Size, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;

    return nullptr;
}

static napi_value register_function_wxSharp_GetDisplayPPI(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_GetDisplayPPI;
    status = napi_create_function(env, "GetDisplayPPI", NAPI_AUTO_LENGTH, callback_function_wxSharp_GetDisplayPPI, 0, &_wxSharp_GetDisplayPPI);
    assert(status == napi_ok);

    return _wxSharp_GetDisplayPPI;
}

// wxSharp::GetClientDisplayRect
static napi_value callback_function_wxSharp_GetClientDisplayRect(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    ::wxSharp::Rect __ret = ::wxSharp::GetClientDisplayRect();

    napi_value ____ret_ctor;
    status = napi_get_reference_value(env, ctor_wxSharp_Rect_Rect, &____ret_ctor);
    assert(status == napi_ok);

    napi_value ____ret_instance;
    status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
    assert(status == napi_ok);


    return ____ret_instance;

    return nullptr;
}

static napi_value register_function_wxSharp_GetClientDisplayRect(napi_env env)
{
    napi_status status;
    napi_value _wxSharp_GetClientDisplayRect;
    status = napi_create_function(env, "GetClientDisplayRect", NAPI_AUTO_LENGTH, callback_function_wxSharp_GetClientDisplayRect, 0, &_wxSharp_GetClientDisplayRect);
    assert(status == napi_ok);

    return _wxSharp_GetClientDisplayRect;
}

void register_wxsharp_gdicmn(napi_env env, napi_value exports)
{
    napi_value value;

    value = register_enum_wxSharp_BitmapType(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "BitmapType", value));

    value = register_enum_wxSharp_EllipsizeFlags(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "EllipsizeFlags", value));

    value = register_enum_wxSharp_EllipsizeMode(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "EllipsizeMode", value));

    value = register_enum_wxSharp_PolygonFillMode(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PolygonFillMode", value));

    value = register_enum_wxSharp_StockCursor(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "StockCursor", value));

    value = register_class_wxSharp_Size(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Size", value));

    value = register_class_wxSharp_RealPoint(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "RealPoint", value));

    value = register_class_wxSharp_Point(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Point", value));

    value = register_class_wxSharp_wxPointListNode(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "wxPointListNode", value));

    value = register_class_wxSharp_Rect(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Rect", value));

    value = register_class_wxSharp_GDIObjListBase(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "GDIObjListBase", value));

    value = register_class_wxSharp_ColourDatabase(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ColourDatabase", value));

    value = register_class_wxSharp_ResourceCache(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ResourceCache", value));

    value = register_class_wxSharp_StockGDI(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "StockGDI", value));

    value = register_function_wxSharp_InitializeStockLists(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "InitializeStockLists", value));

    value = register_function_wxSharp_DeleteStockLists(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "DeleteStockLists", value));

    value = register_function_wxSharp_ColourDisplay(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ColourDisplay", value));

    value = register_function_wxSharp_DisplayDepth(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "DisplayDepth", value));

    value = register_function_wxSharp_GetDisplaySize(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "GetDisplaySize", value));

    value = register_function_wxSharp_GetDisplaySizeMM(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "GetDisplaySizeMM", value));

    value = register_function_wxSharp_GetDisplayPPI(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "GetDisplayPPI", value));

    value = register_function_wxSharp_GetClientDisplayRect(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "GetClientDisplayRect", value));
}
