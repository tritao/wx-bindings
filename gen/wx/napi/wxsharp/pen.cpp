// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <wxsharp/pen.h>
#include <node/node_api.h>
#include <assert.h>
#include <stdio.h>
#include "NAPIHelpers.h"

extern napi_ref ctor_wxSharp_Color_Color;

static napi_value register_enum_wxSharp_PenStyle(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // INVALID
    napi_value i_0;
    status = napi_create_int32(env, -1, &i_0);
    assert(status == napi_ok);

    // SOLID
    napi_value i_1;
    status = napi_create_int32(env, 100, &i_1);
    assert(status == napi_ok);

    // DOT
    napi_value i_2;
    status = napi_create_int32(env, 101, &i_2);
    assert(status == napi_ok);

    // LONG_DASH
    napi_value i_3;
    status = napi_create_int32(env, 102, &i_3);
    assert(status == napi_ok);

    // SHORT_DASH
    napi_value i_4;
    status = napi_create_int32(env, 103, &i_4);
    assert(status == napi_ok);

    // DOT_DASH
    napi_value i_5;
    status = napi_create_int32(env, 104, &i_5);
    assert(status == napi_ok);

    // USER_DASH
    napi_value i_6;
    status = napi_create_int32(env, 105, &i_6);
    assert(status == napi_ok);

    // TRANSPARENT
    napi_value i_7;
    status = napi_create_int32(env, 106, &i_7);
    assert(status == napi_ok);

    // STIPPLE_MASK_OPAQUE
    napi_value i_8;
    status = napi_create_int32(env, 107, &i_8);
    assert(status == napi_ok);

    // STIPPLE_MASK
    napi_value i_9;
    status = napi_create_int32(env, 108, &i_9);
    assert(status == napi_ok);

    // STIPPLE
    napi_value i_10;
    status = napi_create_int32(env, 110, &i_10);
    assert(status == napi_ok);

    // BDIAGONAL_HATCH
    napi_value i_11;
    status = napi_create_int32(env, 111, &i_11);
    assert(status == napi_ok);

    // CROSSDIAG_HATCH
    napi_value i_12;
    status = napi_create_int32(env, 112, &i_12);
    assert(status == napi_ok);

    // FDIAGONAL_HATCH
    napi_value i_13;
    status = napi_create_int32(env, 113, &i_13);
    assert(status == napi_ok);

    // CROSS_HATCH
    napi_value i_14;
    status = napi_create_int32(env, 114, &i_14);
    assert(status == napi_ok);

    // HORIZONTAL_HATCH
    napi_value i_15;
    status = napi_create_int32(env, 115, &i_15);
    assert(status == napi_ok);

    // VERTICAL_HATCH
    napi_value i_16;
    status = napi_create_int32(env, 116, &i_16);
    assert(status == napi_ok);

    // FIRST_HATCH
    napi_value i_17;
    status = napi_create_int32(env, 111, &i_17);
    assert(status == napi_ok);

    // LAST_HATCH
    napi_value i_18;
    status = napi_create_int32(env, 116, &i_18);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "INVALID", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "SOLID", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "DOT", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "LONG_DASH", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr },
        { "SHORT_DASH", nullptr, nullptr, nullptr, nullptr, i_4, attributes, nullptr },
        { "DOT_DASH", nullptr, nullptr, nullptr, nullptr, i_5, attributes, nullptr },
        { "USER_DASH", nullptr, nullptr, nullptr, nullptr, i_6, attributes, nullptr },
        { "TRANSPARENT", nullptr, nullptr, nullptr, nullptr, i_7, attributes, nullptr },
        { "STIPPLE_MASK_OPAQUE", nullptr, nullptr, nullptr, nullptr, i_8, attributes, nullptr },
        { "STIPPLE_MASK", nullptr, nullptr, nullptr, nullptr, i_9, attributes, nullptr },
        { "STIPPLE", nullptr, nullptr, nullptr, nullptr, i_10, attributes, nullptr },
        { "BDIAGONAL_HATCH", nullptr, nullptr, nullptr, nullptr, i_11, attributes, nullptr },
        { "CROSSDIAG_HATCH", nullptr, nullptr, nullptr, nullptr, i_12, attributes, nullptr },
        { "FDIAGONAL_HATCH", nullptr, nullptr, nullptr, nullptr, i_13, attributes, nullptr },
        { "CROSS_HATCH", nullptr, nullptr, nullptr, nullptr, i_14, attributes, nullptr },
        { "HORIZONTAL_HATCH", nullptr, nullptr, nullptr, nullptr, i_15, attributes, nullptr },
        { "VERTICAL_HATCH", nullptr, nullptr, nullptr, nullptr, i_16, attributes, nullptr },
        { "FIRST_HATCH", nullptr, nullptr, nullptr, nullptr, i_17, attributes, nullptr },
        { "LAST_HATCH", nullptr, nullptr, nullptr, nullptr, i_18, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_PenJoin(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // INVALID
    napi_value i_0;
    status = napi_create_int32(env, -1, &i_0);
    assert(status == napi_ok);

    // BEVEL
    napi_value i_1;
    status = napi_create_int32(env, 120, &i_1);
    assert(status == napi_ok);

    // MITER
    napi_value i_2;
    status = napi_create_int32(env, 121, &i_2);
    assert(status == napi_ok);

    // ROUND
    napi_value i_3;
    status = napi_create_int32(env, 122, &i_3);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "INVALID", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "BEVEL", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "MITER", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "ROUND", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static napi_value register_enum_wxSharp_PenCap(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // INVALID
    napi_value i_0;
    status = napi_create_int32(env, -1, &i_0);
    assert(status == napi_ok);

    // ROUND
    napi_value i_1;
    status = napi_create_int32(env, 130, &i_1);
    assert(status == napi_ok);

    // PROJECTING
    napi_value i_2;
    status = napi_create_int32(env, 131, &i_2);
    assert(status == napi_ok);

    // BUTT
    napi_value i_3;
    status = napi_create_int32(env, 132, &i_3);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "INVALID", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "ROUND", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "PROJECTING", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "BUTT", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static void dtor_wxSharp_PenInfo_PenInfo(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_PenInfo_PenInfo;

// wxSharp::PenInfo::PenInfo
static napi_value callback_method_wxSharp_PenInfo_PenInfo(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::PenInfo* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // explicit PenInfo(const ::wxSharp::Color& colour, int width, ::wxSharp::PenStyle style)
overload0:
    {
        wxSharp::Color* colour_instance;
        status = napi_unwrap(env, _this, (void**) &colour_instance);
        auto &__arg0 = *colour_instance;

        int32_t width;
        status = napi_get_value_int32(env, args[1], &width);
        auto __arg1 = width;

        int32_t style;
        status = napi_get_value_int32(env, args[2], &style);
        auto __arg2 = (::wxSharp::PenStyle)style;

        instance = new wxSharp::PenInfo(__arg0, __arg1, __arg2);
    }

    // PenInfo(const ::wxSharp::PenInfo& _0)
overload1:
    {
        wxSharp::PenInfo* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::PenInfo(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_PenInfo_PenInfo, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::PenInfo::PenInfo: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_PenInfo(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }

    };

    napi_value constructor;
    status = napi_define_class(env, "PenInfo", NAPI_AUTO_LENGTH, callback_method_wxSharp_PenInfo_PenInfo, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_PenInfo_PenInfo);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_Pen_Pen(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_Pen_Pen;

// wxSharp::Pen::Pen
static napi_value callback_method_wxSharp_Pen_Pen(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Pen* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // Pen()
overload0:
    {
        instance = new wxSharp::Pen();
    }

    // Pen(const ::wxSharp::Color& colour, int width, ::wxSharp::PenStyle style)
overload1:
    {
        wxSharp::Color* colour_instance;
        status = napi_unwrap(env, _this, (void**) &colour_instance);
        auto &__arg0 = *colour_instance;

        int32_t width;
        status = napi_get_value_int32(env, args[1], &width);
        auto __arg1 = width;

        int32_t style;
        status = napi_get_value_int32(env, args[2], &style);
        auto __arg2 = (::wxSharp::PenStyle)style;

        instance = new wxSharp::Pen(__arg0, __arg1, __arg2);
    }

    // Pen(const ::wxSharp::PenInfo& info)
overload2:
    {
        wxSharp::PenInfo* info_instance;
        status = napi_unwrap(env, _this, (void**) &info_instance);
        auto &__arg0 = *info_instance;

        instance = new wxSharp::Pen(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_Pen_Pen, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::Pen::Pen: %lu\n", argc);
    return _this;
}

// wxSharp::Pen::operator==
static napi_value callback_method_wxSharp_Pen_operator_EqualEqual(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Pen* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool operator==(const ::wxSharp::Pen& pen) const
overload0:
    {
        wxSharp::Pen* pen_instance;
        status = napi_unwrap(env, _this, (void**) &pen_instance);
        auto &__arg0 = *pen_instance;

        bool __ret = instance->operator==(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Pen::operator==: %lu\n", argc);
    return _this;
}

// wxSharp::Pen::operator!=
static napi_value callback_method_wxSharp_Pen_operator_ExclaimEqual(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Pen* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool operator!=(const ::wxSharp::Pen& pen) const
overload0:
    {
        wxSharp::Pen* pen_instance;
        status = napi_unwrap(env, _this, (void**) &pen_instance);
        auto &__arg0 = *pen_instance;

        bool __ret = instance->operator!=(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Pen::operator!=: %lu\n", argc);
    return _this;
}

// wxSharp::Pen::SetColour
static napi_value callback_method_wxSharp_Pen_SetColour(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Pen* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetColour(unsigned char red, unsigned char green, unsigned char blue)
overload0:
    {
        uint32_t red;
        status = napi_get_value_uint32(env, args[0], &red);
        auto __arg0 = red;

        uint32_t green;
        status = napi_get_value_uint32(env, args[1], &green);
        auto __arg1 = green;

        uint32_t blue;
        status = napi_get_value_uint32(env, args[2], &blue);
        auto __arg2 = blue;

        instance->SetColour(__arg0, __arg1, __arg2);
    }
    printf("wxSharp::Pen::SetColour: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_Pen(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "operator==", nullptr, callback_method_wxSharp_Pen_operator_EqualEqual, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "operator!=", nullptr, callback_method_wxSharp_Pen_operator_ExclaimEqual, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetColour", nullptr, callback_method_wxSharp_Pen_SetColour, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "Pen", NAPI_AUTO_LENGTH, callback_method_wxSharp_Pen_Pen, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_Pen_Pen);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_PenList_PenList(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_PenList_PenList;

// wxSharp::PenList::PenList
static napi_value callback_method_wxSharp_PenList_PenList(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::PenList* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // PenList(const ::wxSharp::PenList& _0)
overload0:
    {
        wxSharp::PenList* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::PenList(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_PenList_PenList, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::PenList::PenList: %lu\n", argc);
    return _this;
}

// wxSharp::PenList::FindOrCreatePen
static napi_value callback_method_wxSharp_PenList_FindOrCreatePen(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::PenList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Pen* FindOrCreatePen(const ::wxSharp::Color& colour, int width, ::wxSharp::PenStyle style)
overload0:
    {
        wxSharp::Color* colour_instance;
        status = napi_unwrap(env, _this, (void**) &colour_instance);
        auto &__arg0 = *colour_instance;

        int32_t width;
        status = napi_get_value_int32(env, args[1], &width);
        auto __arg1 = width;

        int32_t style;
        status = napi_get_value_int32(env, args[2], &style);
        auto __arg2 = (::wxSharp::PenStyle)style;

        ::wxSharp::Pen* __ret = instance->FindOrCreatePen(__arg0, __arg1, __arg2);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Pen_Pen, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::PenList::FindOrCreatePen: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_PenList(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "FindOrCreatePen", nullptr, callback_method_wxSharp_PenList_FindOrCreatePen, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "PenList", NAPI_AUTO_LENGTH, callback_method_wxSharp_PenList_PenList, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_PenList_PenList);
    assert(status == napi_ok);

    return constructor;
}

void register_wxsharp_pen(napi_env env, napi_value exports)
{
    napi_value value;

    value = register_enum_wxSharp_PenStyle(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PenStyle", value));

    value = register_enum_wxSharp_PenJoin(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PenJoin", value));

    value = register_enum_wxSharp_PenCap(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PenCap", value));

    value = register_class_wxSharp_PenInfo(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PenInfo", value));

    value = register_class_wxSharp_Pen(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Pen", value));

    value = register_class_wxSharp_PenList(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "PenList", value));
}
