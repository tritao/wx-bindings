// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <wxsharp/sizer.h>
#include <node/node_api.h>
#include <assert.h>
#include <stdio.h>
#include "NAPIHelpers.h"

extern napi_ref ctor_wxSharp_Rect_Rect;
extern napi_ref ctor_wxSharp_Event_Event;
extern napi_ref ctor_wxSharp_GraphicsContext_GraphicsContext;
extern napi_ref ctor_wxSharp_GraphicsPath_GraphicsPath;
extern napi_ref ctor_wxSharp_GraphicsMatrix_GraphicsMatrix;
extern napi_ref ctor_wxSharp_GraphicsPen_GraphicsPen;
extern napi_ref ctor_wxSharp_GraphicsBrush_GraphicsBrush;
extern napi_ref ctor_wxSharp_GraphicsFont_GraphicsFont;
extern napi_ref ctor_wxSharp_GraphicsBitmap_GraphicsBitmap;
extern napi_ref ctor_wxSharp_Color_Color;
extern napi_ref ctor_wxSharp_Size_Size;
extern napi_ref ctor_wxSharp_Point_Point;
extern napi_ref ctor_wxSharp_Window_Window;
extern napi_ref ctor_wxSharp_EvtHandler_EvtHandler;
extern napi_ref ctor_wxSharp_VisualAttributes_VisualAttributes;

static napi_value register_enum_wxSharp_FlexSizerGrowMode(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // NONE
    napi_value i_0;
    status = napi_create_uint32(env, 0, &i_0);
    assert(status == napi_ok);

    // SPECIFIED
    napi_value i_1;
    status = napi_create_uint32(env, 1, &i_1);
    assert(status == napi_ok);

    // ALL
    napi_value i_2;
    status = napi_create_uint32(env, 2, &i_2);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "NONE", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "SPECIFIED", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "ALL", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static void dtor_wxSharp_SizerFlags_SizerFlags(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_SizerFlags_SizerFlags;

// wxSharp::SizerFlags::SizerFlags
static napi_value callback_method_wxSharp_SizerFlags_SizerFlags(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerFlags* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // SizerFlags(int proportion)
overload0:
    {
        int32_t proportion;
        status = napi_get_value_int32(env, args[0], &proportion);
        auto __arg0 = proportion;

        instance = new wxSharp::SizerFlags(__arg0);
    }

    // SizerFlags(const ::wxSharp::SizerFlags& _0)
overload1:
    {
        wxSharp::SizerFlags* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::SizerFlags(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_SizerFlags_SizerFlags, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::SizerFlags::SizerFlags: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_SizerFlags(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }

    };

    napi_value constructor;
    status = napi_define_class(env, "SizerFlags", NAPI_AUTO_LENGTH, callback_method_wxSharp_SizerFlags_SizerFlags, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_SizerFlags_SizerFlags);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_SizerSpacer_SizerSpacer(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_SizerSpacer_SizerSpacer;

// wxSharp::SizerSpacer::SizerSpacer
static napi_value callback_method_wxSharp_SizerSpacer_SizerSpacer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerSpacer* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // SizerSpacer(const ::wxSharp::Size& size)
overload0:
    {
        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg0 = *size_instance;

        instance = new wxSharp::SizerSpacer(__arg0);
    }

    // SizerSpacer(const ::wxSharp::SizerSpacer& _0)
overload1:
    {
        wxSharp::SizerSpacer* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::SizerSpacer(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_SizerSpacer_SizerSpacer, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::SizerSpacer::SizerSpacer: %lu\n", argc);
    return _this;
}

// wxSharp::SizerSpacer::SetSize
static napi_value callback_method_wxSharp_SizerSpacer_SetSize(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerSpacer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetSize(const ::wxSharp::Size& size)
overload0:
    {
        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg0 = *size_instance;

        instance->SetSize(__arg0);
    }
    printf("wxSharp::SizerSpacer::SetSize: %lu\n", argc);
    return _this;
}

// wxSharp::SizerSpacer::Show
static napi_value callback_method_wxSharp_SizerSpacer_Show(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerSpacer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void Show(bool show)
overload0:
    {
        bool show;
        status = napi_get_value_bool(env, args[0], &show);
        auto __arg0 = (bool)show;

        instance->Show(__arg0);
    }
    printf("wxSharp::SizerSpacer::Show: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_SizerSpacer(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "SetSize", nullptr, callback_method_wxSharp_SizerSpacer_SetSize, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Show", nullptr, callback_method_wxSharp_SizerSpacer_Show, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "SizerSpacer", NAPI_AUTO_LENGTH, callback_method_wxSharp_SizerSpacer_SizerSpacer, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_SizerSpacer_SizerSpacer);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_SizerItem_SizerItem(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_SizerItem_SizerItem;

// wxSharp::SizerItem::SizerItem
static napi_value callback_method_wxSharp_SizerItem_SizerItem(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 6)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItem* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck3;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck4;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck5;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload2;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck6;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck7;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck8;

    goto error;

typecheck6:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck9;

    if (NAPI_IS_OBJECT(types[2]))
        goto overload3;

    goto error;

typecheck7:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck10;

    goto error;

typecheck8:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck11;

    goto error;

typecheck9:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck12;

    goto error;

typecheck10:
    if (NAPI_IS_OBJECT(types[4]))
        goto overload4;

    goto error;

typecheck11:
    if (NAPI_IS_OBJECT(types[4]))
        goto overload5;

    goto error;

typecheck12:
    if (NAPI_IS_INT32(types[4], args[4]))
        goto typecheck13;

    goto error;

typecheck13:
    if (NAPI_IS_OBJECT(types[5]))
        goto overload6;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // SizerItem(::wxSharp::Window* window, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        int32_t proportion;
        status = napi_get_value_int32(env, args[1], &proportion);
        auto __arg1 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[2], &flag);
        auto __arg2 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[3], &border);
        auto __arg3 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg4 = userData_instance;

        instance = new wxSharp::SizerItem(__arg0, __arg1, __arg2, __arg3, __arg4);
    }

    // SizerItem(::wxSharp::Window* window, const ::wxSharp::SizerFlags& flags)
overload1:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg1 = *flags_instance;

        instance = new wxSharp::SizerItem(__arg0, __arg1);
    }

    // SizerItem(::wxSharp::Sizer* sizer, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload2:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        int32_t proportion;
        status = napi_get_value_int32(env, args[1], &proportion);
        auto __arg1 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[2], &flag);
        auto __arg2 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[3], &border);
        auto __arg3 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg4 = userData_instance;

        instance = new wxSharp::SizerItem(__arg0, __arg1, __arg2, __arg3, __arg4);
    }

    // SizerItem(::wxSharp::Sizer* sizer, const ::wxSharp::SizerFlags& flags)
overload3:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg1 = *flags_instance;

        instance = new wxSharp::SizerItem(__arg0, __arg1);
    }

    // SizerItem(int width, int height, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload4:
    {
        int32_t width;
        status = napi_get_value_int32(env, args[0], &width);
        auto __arg0 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[1], &height);
        auto __arg1 = height;

        int32_t proportion;
        status = napi_get_value_int32(env, args[2], &proportion);
        auto __arg2 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[3], &flag);
        auto __arg3 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[4], &border);
        auto __arg4 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg5 = userData_instance;

        instance = new wxSharp::SizerItem(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
    }

    // SizerItem(int width, int height, const ::wxSharp::SizerFlags& flags)
overload5:
    {
        int32_t width;
        status = napi_get_value_int32(env, args[0], &width);
        auto __arg0 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[1], &height);
        auto __arg1 = height;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg2 = *flags_instance;

        instance = new wxSharp::SizerItem(__arg0, __arg1, __arg2);
    }

    // SizerItem()
overload6:
    {
        instance = new wxSharp::SizerItem();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_SizerItem_SizerItem, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::SizerItem::SizerItem: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::DeleteWindows
static napi_value callback_method_wxSharp_SizerItem_DeleteWindows(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->DeleteWindows();
    printf("wxSharp::SizerItem::DeleteWindows: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::DetachSizer
static napi_value callback_method_wxSharp_SizerItem_DetachSizer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->DetachSizer();
    printf("wxSharp::SizerItem::DetachSizer: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::DetachWindow
static napi_value callback_method_wxSharp_SizerItem_DetachWindow(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->DetachWindow();
    printf("wxSharp::SizerItem::DetachWindow: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::SetDimension
static napi_value callback_method_wxSharp_SizerItem_SetDimension(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetDimension(const ::wxSharp::Point& pos, const ::wxSharp::Size& size)
overload0:
    {
        wxSharp::Point* pos_instance;
        status = napi_unwrap(env, _this, (void**) &pos_instance);
        auto &__arg0 = *pos_instance;

        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg1 = *size_instance;

        instance->SetDimension(__arg0, __arg1);
    }
    printf("wxSharp::SizerItem::SetDimension: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::SetMinSize
static napi_value callback_method_wxSharp_SizerItem_SetMinSize(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetMinSize(int x, int y)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        instance->SetMinSize(__arg0, __arg1);
    }
    printf("wxSharp::SizerItem::SetMinSize: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::SetInitSize
static napi_value callback_method_wxSharp_SizerItem_SetInitSize(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetInitSize(int x, int y)
overload0:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        instance->SetInitSize(__arg0, __arg1);
    }
    printf("wxSharp::SizerItem::SetInitSize: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::SetRatio
static napi_value callback_method_wxSharp_SizerItem_SetRatio(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetRatio(int width, int height)
overload0:
    {
        int32_t width;
        status = napi_get_value_int32(env, args[0], &width);
        auto __arg0 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[1], &height);
        auto __arg1 = height;

        instance->SetRatio(__arg0, __arg1);
    }

    // void SetRatio(const ::wxSharp::Size& size)
overload1:
    {
        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg0 = *size_instance;

        instance->SetRatio(__arg0);
    }
    printf("wxSharp::SizerItem::SetRatio: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::Show
static napi_value callback_method_wxSharp_SizerItem_Show(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void Show(bool show)
overload0:
    {
        bool show;
        status = napi_get_value_bool(env, args[0], &show);
        auto __arg0 = (bool)show;

        instance->Show(__arg0);
    }
    printf("wxSharp::SizerItem::Show: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::InformFirstDirection
static napi_value callback_method_wxSharp_SizerItem_InformFirstDirection(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool InformFirstDirection(int direction, int size, int availableOtherDir)
overload0:
    {
        int32_t direction;
        status = napi_get_value_int32(env, args[0], &direction);
        auto __arg0 = direction;

        int32_t size;
        status = napi_get_value_int32(env, args[1], &size);
        auto __arg1 = size;

        int32_t availableOtherDir;
        status = napi_get_value_int32(env, args[2], &availableOtherDir);
        auto __arg2 = availableOtherDir;

        bool __ret = instance->InformFirstDirection(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::SizerItem::InformFirstDirection: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::AssignWindow
static napi_value callback_method_wxSharp_SizerItem_AssignWindow(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void AssignWindow(::wxSharp::Window* window)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        instance->AssignWindow(__arg0);
    }
    printf("wxSharp::SizerItem::AssignWindow: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::AssignSizer
static napi_value callback_method_wxSharp_SizerItem_AssignSizer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void AssignSizer(::wxSharp::Sizer* sizer)
overload0:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        instance->AssignSizer(__arg0);
    }
    printf("wxSharp::SizerItem::AssignSizer: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItem::AssignSpacer
static napi_value callback_method_wxSharp_SizerItem_AssignSpacer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItem* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void AssignSpacer(const ::wxSharp::Size& size)
overload0:
    {
        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg0 = *size_instance;

        instance->AssignSpacer(__arg0);
    }

    // void AssignSpacer(int w, int h)
overload1:
    {
        int32_t w;
        status = napi_get_value_int32(env, args[0], &w);
        auto __arg0 = w;

        int32_t h;
        status = napi_get_value_int32(env, args[1], &h);
        auto __arg1 = h;

        instance->AssignSpacer(__arg0, __arg1);
    }
    printf("wxSharp::SizerItem::AssignSpacer: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_SizerItem(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "DeleteWindows", nullptr, callback_method_wxSharp_SizerItem_DeleteWindows, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DetachSizer", nullptr, callback_method_wxSharp_SizerItem_DetachSizer, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DetachWindow", nullptr, callback_method_wxSharp_SizerItem_DetachWindow, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetDimension", nullptr, callback_method_wxSharp_SizerItem_SetDimension, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetMinSize", nullptr, callback_method_wxSharp_SizerItem_SetMinSize, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetInitSize", nullptr, callback_method_wxSharp_SizerItem_SetInitSize, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetRatio", nullptr, callback_method_wxSharp_SizerItem_SetRatio, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Show", nullptr, callback_method_wxSharp_SizerItem_Show, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "InformFirstDirection", nullptr, callback_method_wxSharp_SizerItem_InformFirstDirection, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "AssignWindow", nullptr, callback_method_wxSharp_SizerItem_AssignWindow, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "AssignSizer", nullptr, callback_method_wxSharp_SizerItem_AssignSizer, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "AssignSpacer", nullptr, callback_method_wxSharp_SizerItem_AssignSpacer, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "SizerItem", NAPI_AUTO_LENGTH, callback_method_wxSharp_SizerItem_SizerItem, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_SizerItem_SizerItem);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_SizerItemList_SizerItemList(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_SizerItemList_SizerItemList;

// wxSharp::SizerItemList::SizerItemList
static napi_value callback_method_wxSharp_SizerItemList_SizerItemList(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItemList* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // SizerItemList(::wxSharp::KeyType keyType)
overload0:
    {
        int32_t keyType;
        status = napi_get_value_int32(env, args[0], &keyType);
        auto __arg0 = (::wxSharp::KeyType)keyType;

        instance = new wxSharp::SizerItemList(__arg0);
    }

    // SizerItemList(const ::wxSharp::SizerItemList& list)
overload1:
    {
        wxSharp::SizerItemList* list_instance;
        status = napi_unwrap(env, _this, (void**) &list_instance);
        auto &__arg0 = *list_instance;

        instance = new wxSharp::SizerItemList(__arg0);
    }

    // explicit SizerItemList(unsigned long n, ::wxSharp::SizerItem*const & v)
overload2:
    {
        uint32_t n;
        status = napi_get_value_uint32(env, args[0], &n);
        auto __arg0 = n;

        wxSharp::SizerItem* v_instance;
        status = napi_unwrap(env, _this, (void**) &v_instance);
        auto __arg1 = v_instance;

        instance = new wxSharp::SizerItemList(__arg0, __arg1);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_SizerItemList_SizerItemList, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::SizerItemList::SizerItemList: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::operator[]
static napi_value callback_method_wxSharp_SizerItemList_operator_Subscript(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* operator[](unsigned long index) const
overload0:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        ::wxSharp::SizerItem* __ret = instance->operator[](__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::SizerItemList::operator[]: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::DeleteObject
static napi_value callback_method_wxSharp_SizerItemList_DeleteObject(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool DeleteObject(::wxSharp::SizerItem* object)
overload0:
    {
        wxSharp::SizerItem* object_instance;
        status = napi_unwrap(env, _this, (void**) &object_instance);
        auto __arg0 = object_instance;

        bool __ret = instance->DeleteObject(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::SizerItemList::DeleteObject: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::Member
static napi_value callback_method_wxSharp_SizerItemList_Member(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Member(const ::wxSharp::SizerItem* object) const
overload0:
    {
        wxSharp::SizerItem* object_instance;
        status = napi_unwrap(env, _this, (void**) &object_instance);
        auto __arg0 = object_instance;

        bool __ret = instance->Member(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::SizerItemList::Member: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::IndexOf
static napi_value callback_method_wxSharp_SizerItemList_IndexOf(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // int IndexOf(::wxSharp::SizerItem* object) const
overload0:
    {
        wxSharp::SizerItem* object_instance;
        status = napi_unwrap(env, _this, (void**) &object_instance);
        auto __arg0 = object_instance;

        int __ret = instance->IndexOf(__arg0);

        napi_value __result;
        status = napi_create_int32(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::SizerItemList::IndexOf: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::resize
static napi_value callback_method_wxSharp_SizerItemList_resize(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void resize(unsigned long n, ::wxSharp::SizerItem* v)
overload0:
    {
        uint32_t n;
        status = napi_get_value_uint32(env, args[0], &n);
        auto __arg0 = n;

        wxSharp::SizerItem* v_instance;
        status = napi_unwrap(env, _this, (void**) &v_instance);
        auto __arg1 = v_instance;

        instance->resize(__arg0, __arg1);
    }
    printf("wxSharp::SizerItemList::resize: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::push_front
static napi_value callback_method_wxSharp_SizerItemList_push_front(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void push_front(::wxSharp::SizerItem*const & v)
overload0:
    {
        wxSharp::SizerItem* v_instance;
        status = napi_unwrap(env, _this, (void**) &v_instance);
        auto __arg0 = v_instance;

        instance->push_front(__arg0);
    }
    printf("wxSharp::SizerItemList::push_front: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::pop_front
static napi_value callback_method_wxSharp_SizerItemList_pop_front(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->pop_front();
    printf("wxSharp::SizerItemList::pop_front: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::push_back
static napi_value callback_method_wxSharp_SizerItemList_push_back(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void push_back(::wxSharp::SizerItem*const & v)
overload0:
    {
        wxSharp::SizerItem* v_instance;
        status = napi_unwrap(env, _this, (void**) &v_instance);
        auto __arg0 = v_instance;

        instance->push_back(__arg0);
    }
    printf("wxSharp::SizerItemList::push_back: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::pop_back
static napi_value callback_method_wxSharp_SizerItemList_pop_back(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->pop_back();
    printf("wxSharp::SizerItemList::pop_back: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::assign
static napi_value callback_method_wxSharp_SizerItemList_assign(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void assign(unsigned long n, ::wxSharp::SizerItem*const & v)
overload0:
    {
        uint32_t n;
        status = napi_get_value_uint32(env, args[0], &n);
        auto __arg0 = n;

        wxSharp::SizerItem* v_instance;
        status = napi_unwrap(env, _this, (void**) &v_instance);
        auto __arg1 = v_instance;

        instance->assign(__arg0, __arg1);
    }
    printf("wxSharp::SizerItemList::assign: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::clear
static napi_value callback_method_wxSharp_SizerItemList_clear(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->clear();
    printf("wxSharp::SizerItemList::clear: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::remove
static napi_value callback_method_wxSharp_SizerItemList_remove(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void remove(::wxSharp::SizerItem*const & v)
overload0:
    {
        wxSharp::SizerItem* v_instance;
        status = napi_unwrap(env, _this, (void**) &v_instance);
        auto __arg0 = v_instance;

        instance->remove(__arg0);
    }
    printf("wxSharp::SizerItemList::remove: %lu\n", argc);
    return _this;
}

// wxSharp::SizerItemList::reverse
static napi_value callback_method_wxSharp_SizerItemList_reverse(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::SizerItemList* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->reverse();
    printf("wxSharp::SizerItemList::reverse: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_SizerItemList(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "operator[]", nullptr, callback_method_wxSharp_SizerItemList_operator_Subscript, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DeleteObject", nullptr, callback_method_wxSharp_SizerItemList_DeleteObject, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Member", nullptr, callback_method_wxSharp_SizerItemList_Member, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "IndexOf", nullptr, callback_method_wxSharp_SizerItemList_IndexOf, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "resize", nullptr, callback_method_wxSharp_SizerItemList_resize, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "push_front", nullptr, callback_method_wxSharp_SizerItemList_push_front, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "pop_front", nullptr, callback_method_wxSharp_SizerItemList_pop_front, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "push_back", nullptr, callback_method_wxSharp_SizerItemList_push_back, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "pop_back", nullptr, callback_method_wxSharp_SizerItemList_pop_back, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "assign", nullptr, callback_method_wxSharp_SizerItemList_assign, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "clear", nullptr, callback_method_wxSharp_SizerItemList_clear, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "remove", nullptr, callback_method_wxSharp_SizerItemList_remove, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "reverse", nullptr, callback_method_wxSharp_SizerItemList_reverse, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "SizerItemList", NAPI_AUTO_LENGTH, callback_method_wxSharp_SizerItemList_SizerItemList, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_SizerItemList_SizerItemList);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_Sizer_Sizer(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_Sizer_Sizer;

// wxSharp::Sizer::Sizer
static napi_value callback_method_wxSharp_Sizer_Sizer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // Sizer()
overload0:
    {
        instance = new wxSharp::Sizer();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_Sizer_Sizer, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::Sizer::Sizer: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::Add
static napi_value callback_method_wxSharp_Sizer_Add(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 6)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck3;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck4;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck5;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload2;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck6;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck7;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck8;

    goto error;

typecheck6:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck9;

    if (NAPI_IS_OBJECT(types[2]))
        goto overload3;

    goto error;

typecheck7:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck10;

    goto error;

typecheck8:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck11;

    goto error;

typecheck9:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck12;

    goto error;

typecheck10:
    if (NAPI_IS_OBJECT(types[4]))
        goto overload4;

    goto error;

typecheck11:
    if (NAPI_IS_OBJECT(types[4]))
        goto overload5;

    goto error;

typecheck12:
    if (NAPI_IS_INT32(types[4], args[4]))
        goto typecheck13;

    goto error;

typecheck13:
    if (NAPI_IS_OBJECT(types[5]))
        goto overload6;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* Add(::wxSharp::Window* window, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        int32_t proportion;
        status = napi_get_value_int32(env, args[1], &proportion);
        auto __arg1 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[2], &flag);
        auto __arg2 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[3], &border);
        auto __arg3 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg4 = userData_instance;

        ::wxSharp::SizerItem* __ret = instance->Add(__arg0, __arg1, __arg2, __arg3, __arg4);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Add(::wxSharp::Sizer* sizer, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload1:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        int32_t proportion;
        status = napi_get_value_int32(env, args[1], &proportion);
        auto __arg1 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[2], &flag);
        auto __arg2 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[3], &border);
        auto __arg3 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg4 = userData_instance;

        ::wxSharp::SizerItem* __ret = instance->Add(__arg0, __arg1, __arg2, __arg3, __arg4);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Add(int width, int height, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload2:
    {
        int32_t width;
        status = napi_get_value_int32(env, args[0], &width);
        auto __arg0 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[1], &height);
        auto __arg1 = height;

        int32_t proportion;
        status = napi_get_value_int32(env, args[2], &proportion);
        auto __arg2 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[3], &flag);
        auto __arg3 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[4], &border);
        auto __arg4 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg5 = userData_instance;

        ::wxSharp::SizerItem* __ret = instance->Add(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Add(::wxSharp::Window* window, const ::wxSharp::SizerFlags& flags)
overload3:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg1 = *flags_instance;

        ::wxSharp::SizerItem* __ret = instance->Add(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Add(::wxSharp::Sizer* sizer, const ::wxSharp::SizerFlags& flags)
overload4:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg1 = *flags_instance;

        ::wxSharp::SizerItem* __ret = instance->Add(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Add(int width, int height, const ::wxSharp::SizerFlags& flags)
overload5:
    {
        int32_t width;
        status = napi_get_value_int32(env, args[0], &width);
        auto __arg0 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[1], &height);
        auto __arg1 = height;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg2 = *flags_instance;

        ::wxSharp::SizerItem* __ret = instance->Add(__arg0, __arg1, __arg2);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Add(::wxSharp::SizerItem* item)
overload6:
    {
        wxSharp::SizerItem* item_instance;
        status = napi_unwrap(env, _this, (void**) &item_instance);
        auto __arg0 = item_instance;

        ::wxSharp::SizerItem* __ret = instance->Add(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::Add: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::AddSpacer
static napi_value callback_method_wxSharp_Sizer_AddSpacer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* AddSpacer(int size)
overload0:
    {
        int32_t size;
        status = napi_get_value_int32(env, args[0], &size);
        auto __arg0 = size;

        ::wxSharp::SizerItem* __ret = instance->AddSpacer(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::AddSpacer: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::AddStretchSpacer
static napi_value callback_method_wxSharp_Sizer_AddStretchSpacer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* AddStretchSpacer(int prop)
overload0:
    {
        int32_t prop;
        status = napi_get_value_int32(env, args[0], &prop);
        auto __arg0 = prop;

        ::wxSharp::SizerItem* __ret = instance->AddStretchSpacer(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::AddStretchSpacer: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::Insert
static napi_value callback_method_wxSharp_Sizer_Insert(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 7)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck3;

    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck4;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck5;

    if (NAPI_IS_OBJECT(types[2]))
        goto overload1;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck6;

    if (NAPI_IS_OBJECT(types[2]))
        goto overload2;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck7;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck8;

    goto error;

typecheck6:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck9;

    goto error;

typecheck7:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck10;

    if (NAPI_IS_OBJECT(types[3]))
        goto overload3;

    goto error;

typecheck8:
    if (NAPI_IS_INT32(types[4], args[4]))
        goto typecheck11;

    goto error;

typecheck9:
    if (NAPI_IS_INT32(types[4], args[4]))
        goto typecheck12;

    goto error;

typecheck10:
    if (NAPI_IS_INT32(types[4], args[4]))
        goto typecheck13;

    goto error;

typecheck11:
    if (NAPI_IS_OBJECT(types[5]))
        goto overload4;

    goto error;

typecheck12:
    if (NAPI_IS_OBJECT(types[5]))
        goto overload5;

    goto error;

typecheck13:
    if (NAPI_IS_INT32(types[5], args[5]))
        goto typecheck14;

    goto error;

typecheck14:
    if (NAPI_IS_OBJECT(types[6]))
        goto overload6;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* Insert(unsigned long index, ::wxSharp::Window* window, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload0:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg1 = window_instance;

        int32_t proportion;
        status = napi_get_value_int32(env, args[2], &proportion);
        auto __arg2 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[3], &flag);
        auto __arg3 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[4], &border);
        auto __arg4 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg5 = userData_instance;

        ::wxSharp::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Insert(unsigned long index, ::wxSharp::Sizer* sizer, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload1:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg1 = sizer_instance;

        int32_t proportion;
        status = napi_get_value_int32(env, args[2], &proportion);
        auto __arg2 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[3], &flag);
        auto __arg3 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[4], &border);
        auto __arg4 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg5 = userData_instance;

        ::wxSharp::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Insert(unsigned long index, int width, int height, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload2:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        int32_t width;
        status = napi_get_value_int32(env, args[1], &width);
        auto __arg1 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[2], &height);
        auto __arg2 = height;

        int32_t proportion;
        status = napi_get_value_int32(env, args[3], &proportion);
        auto __arg3 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[4], &flag);
        auto __arg4 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[5], &border);
        auto __arg5 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg6 = userData_instance;

        ::wxSharp::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Insert(unsigned long index, ::wxSharp::Window* window, const ::wxSharp::SizerFlags& flags)
overload3:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg1 = window_instance;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg2 = *flags_instance;

        ::wxSharp::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Insert(unsigned long index, ::wxSharp::Sizer* sizer, const ::wxSharp::SizerFlags& flags)
overload4:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg1 = sizer_instance;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg2 = *flags_instance;

        ::wxSharp::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Insert(unsigned long index, int width, int height, const ::wxSharp::SizerFlags& flags)
overload5:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        int32_t width;
        status = napi_get_value_int32(env, args[1], &width);
        auto __arg1 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[2], &height);
        auto __arg2 = height;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg3 = *flags_instance;

        ::wxSharp::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2, __arg3);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Insert(unsigned long index, ::wxSharp::SizerItem* item)
overload6:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        wxSharp::SizerItem* item_instance;
        status = napi_unwrap(env, _this, (void**) &item_instance);
        auto __arg1 = item_instance;

        ::wxSharp::SizerItem* __ret = instance->Insert(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::Insert: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::InsertSpacer
static napi_value callback_method_wxSharp_Sizer_InsertSpacer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* InsertSpacer(unsigned long index, int size)
overload0:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        int32_t size;
        status = napi_get_value_int32(env, args[1], &size);
        auto __arg1 = size;

        ::wxSharp::SizerItem* __ret = instance->InsertSpacer(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::InsertSpacer: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::InsertStretchSpacer
static napi_value callback_method_wxSharp_Sizer_InsertStretchSpacer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* InsertStretchSpacer(unsigned long index, int prop)
overload0:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        int32_t prop;
        status = napi_get_value_int32(env, args[1], &prop);
        auto __arg1 = prop;

        ::wxSharp::SizerItem* __ret = instance->InsertStretchSpacer(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::InsertStretchSpacer: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::Prepend
static napi_value callback_method_wxSharp_Sizer_Prepend(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 6)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck3;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck4;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck5;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload2;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck6;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck7;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck8;

    goto error;

typecheck6:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck9;

    if (NAPI_IS_OBJECT(types[2]))
        goto overload3;

    goto error;

typecheck7:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck10;

    goto error;

typecheck8:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck11;

    goto error;

typecheck9:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto typecheck12;

    goto error;

typecheck10:
    if (NAPI_IS_OBJECT(types[4]))
        goto overload4;

    goto error;

typecheck11:
    if (NAPI_IS_OBJECT(types[4]))
        goto overload5;

    goto error;

typecheck12:
    if (NAPI_IS_INT32(types[4], args[4]))
        goto typecheck13;

    goto error;

typecheck13:
    if (NAPI_IS_OBJECT(types[5]))
        goto overload6;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* Prepend(::wxSharp::Window* window, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        int32_t proportion;
        status = napi_get_value_int32(env, args[1], &proportion);
        auto __arg1 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[2], &flag);
        auto __arg2 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[3], &border);
        auto __arg3 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg4 = userData_instance;

        ::wxSharp::SizerItem* __ret = instance->Prepend(__arg0, __arg1, __arg2, __arg3, __arg4);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Prepend(::wxSharp::Sizer* sizer, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload1:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        int32_t proportion;
        status = napi_get_value_int32(env, args[1], &proportion);
        auto __arg1 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[2], &flag);
        auto __arg2 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[3], &border);
        auto __arg3 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg4 = userData_instance;

        ::wxSharp::SizerItem* __ret = instance->Prepend(__arg0, __arg1, __arg2, __arg3, __arg4);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Prepend(int width, int height, int proportion, int flag, int border, ::wxSharp::Object* userData)
overload2:
    {
        int32_t width;
        status = napi_get_value_int32(env, args[0], &width);
        auto __arg0 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[1], &height);
        auto __arg1 = height;

        int32_t proportion;
        status = napi_get_value_int32(env, args[2], &proportion);
        auto __arg2 = proportion;

        int32_t flag;
        status = napi_get_value_int32(env, args[3], &flag);
        auto __arg3 = flag;

        int32_t border;
        status = napi_get_value_int32(env, args[4], &border);
        auto __arg4 = border;

        wxSharp::Object* userData_instance;
        status = napi_unwrap(env, _this, (void**) &userData_instance);
        auto __arg5 = userData_instance;

        ::wxSharp::SizerItem* __ret = instance->Prepend(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Prepend(::wxSharp::Window* window, const ::wxSharp::SizerFlags& flags)
overload3:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg1 = *flags_instance;

        ::wxSharp::SizerItem* __ret = instance->Prepend(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Prepend(::wxSharp::Sizer* sizer, const ::wxSharp::SizerFlags& flags)
overload4:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg1 = *flags_instance;

        ::wxSharp::SizerItem* __ret = instance->Prepend(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Prepend(int width, int height, const ::wxSharp::SizerFlags& flags)
overload5:
    {
        int32_t width;
        status = napi_get_value_int32(env, args[0], &width);
        auto __arg0 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[1], &height);
        auto __arg1 = height;

        wxSharp::SizerFlags* flags_instance;
        status = napi_unwrap(env, _this, (void**) &flags_instance);
        auto &__arg2 = *flags_instance;

        ::wxSharp::SizerItem* __ret = instance->Prepend(__arg0, __arg1, __arg2);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* Prepend(::wxSharp::SizerItem* item)
overload6:
    {
        wxSharp::SizerItem* item_instance;
        status = napi_unwrap(env, _this, (void**) &item_instance);
        auto __arg0 = item_instance;

        ::wxSharp::SizerItem* __ret = instance->Prepend(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::Prepend: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::PrependSpacer
static napi_value callback_method_wxSharp_Sizer_PrependSpacer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* PrependSpacer(int size)
overload0:
    {
        int32_t size;
        status = napi_get_value_int32(env, args[0], &size);
        auto __arg0 = size;

        ::wxSharp::SizerItem* __ret = instance->PrependSpacer(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::PrependSpacer: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::PrependStretchSpacer
static napi_value callback_method_wxSharp_Sizer_PrependStretchSpacer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* PrependStretchSpacer(int prop)
overload0:
    {
        int32_t prop;
        status = napi_get_value_int32(env, args[0], &prop);
        auto __arg0 = prop;

        ::wxSharp::SizerItem* __ret = instance->PrependStretchSpacer(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::PrependStretchSpacer: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::Remove
static napi_value callback_method_wxSharp_Sizer_Remove(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Remove(::wxSharp::Sizer* sizer)
overload0:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        bool __ret = instance->Remove(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Remove(int index)
overload1:
    {
        int32_t index;
        status = napi_get_value_int32(env, args[0], &index);
        auto __arg0 = index;

        bool __ret = instance->Remove(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Sizer::Remove: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::Detach
static napi_value callback_method_wxSharp_Sizer_Detach(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Detach(::wxSharp::Window* window)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        bool __ret = instance->Detach(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Detach(::wxSharp::Sizer* sizer)
overload1:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        bool __ret = instance->Detach(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Detach(int index)
overload2:
    {
        int32_t index;
        status = napi_get_value_int32(env, args[0], &index);
        auto __arg0 = index;

        bool __ret = instance->Detach(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Sizer::Detach: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::Replace
static napi_value callback_method_wxSharp_Sizer_Replace(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck3;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck4;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck5;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

typecheck4:
    if (NAPI_IS_BOOL(types[2]))
        goto overload1;

    goto error;

typecheck5:
    if (NAPI_IS_BOOL(types[2]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Replace(::wxSharp::Window* oldwin, ::wxSharp::Window* newwin, bool recursive)
overload0:
    {
        wxSharp::Window* oldwin_instance;
        status = napi_unwrap(env, _this, (void**) &oldwin_instance);
        auto __arg0 = oldwin_instance;

        wxSharp::Window* newwin_instance;
        status = napi_unwrap(env, _this, (void**) &newwin_instance);
        auto __arg1 = newwin_instance;

        bool recursive;
        status = napi_get_value_bool(env, args[2], &recursive);
        auto __arg2 = (bool)recursive;

        bool __ret = instance->Replace(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Replace(::wxSharp::Sizer* oldsz, ::wxSharp::Sizer* newsz, bool recursive)
overload1:
    {
        wxSharp::Sizer* oldsz_instance;
        status = napi_unwrap(env, _this, (void**) &oldsz_instance);
        auto __arg0 = oldsz_instance;

        wxSharp::Sizer* newsz_instance;
        status = napi_unwrap(env, _this, (void**) &newsz_instance);
        auto __arg1 = newsz_instance;

        bool recursive;
        status = napi_get_value_bool(env, args[2], &recursive);
        auto __arg2 = (bool)recursive;

        bool __ret = instance->Replace(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Replace(unsigned long index, ::wxSharp::SizerItem* newitem)
overload2:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        wxSharp::SizerItem* newitem_instance;
        status = napi_unwrap(env, _this, (void**) &newitem_instance);
        auto __arg1 = newitem_instance;

        bool __ret = instance->Replace(__arg0, __arg1);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Sizer::Replace: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::Clear
static napi_value callback_method_wxSharp_Sizer_Clear(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void Clear(bool delete_windows)
overload0:
    {
        bool delete_windows;
        status = napi_get_value_bool(env, args[0], &delete_windows);
        auto __arg0 = (bool)delete_windows;

        instance->Clear(__arg0);
    }
    printf("wxSharp::Sizer::Clear: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::DeleteWindows
static napi_value callback_method_wxSharp_Sizer_DeleteWindows(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->DeleteWindows();
    printf("wxSharp::Sizer::DeleteWindows: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::InformFirstDirection
static napi_value callback_method_wxSharp_Sizer_InformFirstDirection(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool InformFirstDirection(int _0, int _1, int _2)
overload0:
    {
        int32_t _0;
        status = napi_get_value_int32(env, args[0], &_0);
        auto __arg0 = _0;

        int32_t _1;
        status = napi_get_value_int32(env, args[1], &_1);
        auto __arg1 = _1;

        int32_t _2;
        status = napi_get_value_int32(env, args[2], &_2);
        auto __arg2 = _2;

        bool __ret = instance->InformFirstDirection(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Sizer::InformFirstDirection: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::SetMinSize
static napi_value callback_method_wxSharp_Sizer_SetMinSize(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetMinSize(int width, int height)
overload0:
    {
        int32_t width;
        status = napi_get_value_int32(env, args[0], &width);
        auto __arg0 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[1], &height);
        auto __arg1 = height;

        instance->SetMinSize(__arg0, __arg1);
    }
    printf("wxSharp::Sizer::SetMinSize: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::SetItemMinSize
static napi_value callback_method_wxSharp_Sizer_SetItemMinSize(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck3;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck4;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck5;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck6;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload2;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload3;

    goto error;

typecheck5:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload4;

    goto error;

typecheck6:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload5;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool SetItemMinSize(::wxSharp::Window* window, int width, int height)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        int32_t width;
        status = napi_get_value_int32(env, args[1], &width);
        auto __arg1 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[2], &height);
        auto __arg2 = height;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool SetItemMinSize(::wxSharp::Window* window, const ::wxSharp::Size& size)
overload1:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg1 = *size_instance;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool SetItemMinSize(::wxSharp::Sizer* sizer, int width, int height)
overload2:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        int32_t width;
        status = napi_get_value_int32(env, args[1], &width);
        auto __arg1 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[2], &height);
        auto __arg2 = height;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool SetItemMinSize(::wxSharp::Sizer* sizer, const ::wxSharp::Size& size)
overload3:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg1 = *size_instance;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool SetItemMinSize(unsigned long index, int width, int height)
overload4:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        int32_t width;
        status = napi_get_value_int32(env, args[1], &width);
        auto __arg1 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[2], &height);
        auto __arg2 = height;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool SetItemMinSize(unsigned long index, const ::wxSharp::Size& size)
overload5:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg1 = *size_instance;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Sizer::SetItemMinSize: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::RepositionChildren
static napi_value callback_method_wxSharp_Sizer_RepositionChildren(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void RepositionChildren(const ::wxSharp::Size& _0)
overload0:
    {
        wxSharp::Size* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance->RepositionChildren(__arg0);
    }
    printf("wxSharp::Sizer::RepositionChildren: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::RecalcSizes
static napi_value callback_method_wxSharp_Sizer_RecalcSizes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->RecalcSizes();
    printf("wxSharp::Sizer::RecalcSizes: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::Layout
static napi_value callback_method_wxSharp_Sizer_Layout(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->Layout();
    printf("wxSharp::Sizer::Layout: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::ComputeFittingClientSize
static napi_value callback_method_wxSharp_Sizer_ComputeFittingClientSize(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Size ComputeFittingClientSize(::wxSharp::Window* window)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        ::wxSharp::Size __ret = instance->ComputeFittingClientSize(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Size_Size, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::ComputeFittingClientSize: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::ComputeFittingWindowSize
static napi_value callback_method_wxSharp_Sizer_ComputeFittingWindowSize(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Size ComputeFittingWindowSize(::wxSharp::Window* window)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        ::wxSharp::Size __ret = instance->ComputeFittingWindowSize(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Size_Size, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::ComputeFittingWindowSize: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::Fit
static napi_value callback_method_wxSharp_Sizer_Fit(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::Size Fit(::wxSharp::Window* window)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        ::wxSharp::Size __ret = instance->Fit(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_Size_Size, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::Fit: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::FitInside
static napi_value callback_method_wxSharp_Sizer_FitInside(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void FitInside(::wxSharp::Window* window)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        instance->FitInside(__arg0);
    }
    printf("wxSharp::Sizer::FitInside: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::SetSizeHints
static napi_value callback_method_wxSharp_Sizer_SetSizeHints(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetSizeHints(::wxSharp::Window* window)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        instance->SetSizeHints(__arg0);
    }
    printf("wxSharp::Sizer::SetSizeHints: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::SetDimension
static napi_value callback_method_wxSharp_Sizer_SetDimension(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (NAPI_IS_INT32(types[3], args[3]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void SetDimension(const ::wxSharp::Point& pos, const ::wxSharp::Size& size)
overload0:
    {
        wxSharp::Point* pos_instance;
        status = napi_unwrap(env, _this, (void**) &pos_instance);
        auto &__arg0 = *pos_instance;

        wxSharp::Size* size_instance;
        status = napi_unwrap(env, _this, (void**) &size_instance);
        auto &__arg1 = *size_instance;

        instance->SetDimension(__arg0, __arg1);
    }

    // void SetDimension(int x, int y, int width, int height)
overload1:
    {
        int32_t x;
        status = napi_get_value_int32(env, args[0], &x);
        auto __arg0 = x;

        int32_t y;
        status = napi_get_value_int32(env, args[1], &y);
        auto __arg1 = y;

        int32_t width;
        status = napi_get_value_int32(env, args[2], &width);
        auto __arg2 = width;

        int32_t height;
        status = napi_get_value_int32(env, args[3], &height);
        auto __arg3 = height;

        instance->SetDimension(__arg0, __arg1, __arg2, __arg3);
    }
    printf("wxSharp::Sizer::SetDimension: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::GetItem
static napi_value callback_method_wxSharp_Sizer_GetItem(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_BOOL(types[1]))
        goto overload1;

    goto error;

typecheck2:
    if (NAPI_IS_BOOL(types[1]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* GetItem(::wxSharp::Window* window, bool recursive)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        bool recursive;
        status = napi_get_value_bool(env, args[1], &recursive);
        auto __arg1 = (bool)recursive;

        ::wxSharp::SizerItem* __ret = instance->GetItem(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* GetItem(::wxSharp::Sizer* sizer, bool recursive)
overload1:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        bool recursive;
        status = napi_get_value_bool(env, args[1], &recursive);
        auto __arg1 = (bool)recursive;

        ::wxSharp::SizerItem* __ret = instance->GetItem(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }

    // ::wxSharp::SizerItem* GetItem(unsigned long index)
overload2:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        ::wxSharp::SizerItem* __ret = instance->GetItem(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::GetItem: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::GetItemById
static napi_value callback_method_wxSharp_Sizer_GetItemById(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_BOOL(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* GetItemById(int id, bool recursive)
overload0:
    {
        int32_t id;
        status = napi_get_value_int32(env, args[0], &id);
        auto __arg0 = id;

        bool recursive;
        status = napi_get_value_bool(env, args[1], &recursive);
        auto __arg1 = (bool)recursive;

        ::wxSharp::SizerItem* __ret = instance->GetItemById(__arg0, __arg1);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::Sizer::GetItemById: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::Show
static napi_value callback_method_wxSharp_Sizer_Show(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck3;

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_BOOL(types[1]))
        goto typecheck4;

    goto error;

typecheck2:
    if (NAPI_IS_BOOL(types[1]))
        goto typecheck5;

    goto error;

typecheck3:
    if (NAPI_IS_BOOL(types[1]))
        goto overload1;

    goto error;

typecheck4:
    if (NAPI_IS_BOOL(types[2]))
        goto overload2;

    goto error;

typecheck5:
    if (NAPI_IS_BOOL(types[2]))
        goto overload3;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Show(::wxSharp::Window* window, bool show, bool recursive)
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        bool show;
        status = napi_get_value_bool(env, args[1], &show);
        auto __arg1 = (bool)show;

        bool recursive;
        status = napi_get_value_bool(env, args[2], &recursive);
        auto __arg2 = (bool)recursive;

        bool __ret = instance->Show(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Show(::wxSharp::Sizer* sizer, bool show, bool recursive)
overload1:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        bool show;
        status = napi_get_value_bool(env, args[1], &show);
        auto __arg1 = (bool)show;

        bool recursive;
        status = napi_get_value_bool(env, args[2], &recursive);
        auto __arg2 = (bool)recursive;

        bool __ret = instance->Show(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Show(unsigned long index, bool show)
overload2:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        bool show;
        status = napi_get_value_bool(env, args[1], &show);
        auto __arg1 = (bool)show;

        bool __ret = instance->Show(__arg0, __arg1);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // void Show(bool show)
overload3:
    {
        bool show;
        status = napi_get_value_bool(env, args[0], &show);
        auto __arg0 = (bool)show;

        instance->Show(__arg0);
    }
    printf("wxSharp::Sizer::Show: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::Hide
static napi_value callback_method_wxSharp_Sizer_Hide(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck2;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_BOOL(types[1]))
        goto overload1;

    goto error;

typecheck2:
    if (NAPI_IS_BOOL(types[1]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Hide(::wxSharp::Sizer* sizer, bool recursive)
overload0:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        bool recursive;
        status = napi_get_value_bool(env, args[1], &recursive);
        auto __arg1 = (bool)recursive;

        bool __ret = instance->Hide(__arg0, __arg1);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Hide(::wxSharp::Window* window, bool recursive)
overload1:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        bool recursive;
        status = napi_get_value_bool(env, args[1], &recursive);
        auto __arg1 = (bool)recursive;

        bool __ret = instance->Hide(__arg0, __arg1);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Hide(unsigned long index)
overload2:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        bool __ret = instance->Hide(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Sizer::Hide: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::IsShown
static napi_value callback_method_wxSharp_Sizer_IsShown(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool IsShown(::wxSharp::Window* window) const
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        bool __ret = instance->IsShown(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool IsShown(::wxSharp::Sizer* sizer) const
overload1:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        bool __ret = instance->IsShown(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool IsShown(unsigned long index) const
overload2:
    {
        uint32_t index;
        status = napi_get_value_uint32(env, args[0], &index);
        auto __arg0 = index;

        bool __ret = instance->IsShown(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::Sizer::IsShown: %lu\n", argc);
    return _this;
}

// wxSharp::Sizer::ShowItems
static napi_value callback_method_wxSharp_Sizer_ShowItems(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::Sizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void ShowItems(bool show)
overload0:
    {
        bool show;
        status = napi_get_value_bool(env, args[0], &show);
        auto __arg0 = (bool)show;

        instance->ShowItems(__arg0);
    }
    printf("wxSharp::Sizer::ShowItems: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_Sizer(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Add", nullptr, callback_method_wxSharp_Sizer_Add, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "AddSpacer", nullptr, callback_method_wxSharp_Sizer_AddSpacer, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "AddStretchSpacer", nullptr, callback_method_wxSharp_Sizer_AddStretchSpacer, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Insert", nullptr, callback_method_wxSharp_Sizer_Insert, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "InsertSpacer", nullptr, callback_method_wxSharp_Sizer_InsertSpacer, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "InsertStretchSpacer", nullptr, callback_method_wxSharp_Sizer_InsertStretchSpacer, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Prepend", nullptr, callback_method_wxSharp_Sizer_Prepend, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "PrependSpacer", nullptr, callback_method_wxSharp_Sizer_PrependSpacer, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "PrependStretchSpacer", nullptr, callback_method_wxSharp_Sizer_PrependStretchSpacer, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Remove", nullptr, callback_method_wxSharp_Sizer_Remove, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Detach", nullptr, callback_method_wxSharp_Sizer_Detach, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Replace", nullptr, callback_method_wxSharp_Sizer_Replace, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Clear", nullptr, callback_method_wxSharp_Sizer_Clear, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "DeleteWindows", nullptr, callback_method_wxSharp_Sizer_DeleteWindows, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "InformFirstDirection", nullptr, callback_method_wxSharp_Sizer_InformFirstDirection, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetMinSize", nullptr, callback_method_wxSharp_Sizer_SetMinSize, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetItemMinSize", nullptr, callback_method_wxSharp_Sizer_SetItemMinSize, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "RepositionChildren", nullptr, callback_method_wxSharp_Sizer_RepositionChildren, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "RecalcSizes", nullptr, callback_method_wxSharp_Sizer_RecalcSizes, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Layout", nullptr, callback_method_wxSharp_Sizer_Layout, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ComputeFittingClientSize", nullptr, callback_method_wxSharp_Sizer_ComputeFittingClientSize, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ComputeFittingWindowSize", nullptr, callback_method_wxSharp_Sizer_ComputeFittingWindowSize, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Fit", nullptr, callback_method_wxSharp_Sizer_Fit, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "FitInside", nullptr, callback_method_wxSharp_Sizer_FitInside, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetSizeHints", nullptr, callback_method_wxSharp_Sizer_SetSizeHints, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "SetDimension", nullptr, callback_method_wxSharp_Sizer_SetDimension, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "GetItem", nullptr, callback_method_wxSharp_Sizer_GetItem, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "GetItemById", nullptr, callback_method_wxSharp_Sizer_GetItemById, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Show", nullptr, callback_method_wxSharp_Sizer_Show, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Hide", nullptr, callback_method_wxSharp_Sizer_Hide, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "IsShown", nullptr, callback_method_wxSharp_Sizer_IsShown, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ShowItems", nullptr, callback_method_wxSharp_Sizer_ShowItems, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "Sizer", NAPI_AUTO_LENGTH, callback_method_wxSharp_Sizer_Sizer, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_Sizer_Sizer);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_GridSizer_GridSizer(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_GridSizer_GridSizer;

// wxSharp::GridSizer::GridSizer
static napi_value callback_method_wxSharp_GridSizer_GridSizer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::GridSizer* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload2;

    if (NAPI_IS_OBJECT(types[2]))
        goto overload3;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // GridSizer(int cols, int vgap, int hgap)
overload0:
    {
        int32_t cols;
        status = napi_get_value_int32(env, args[0], &cols);
        auto __arg0 = cols;

        int32_t vgap;
        status = napi_get_value_int32(env, args[1], &vgap);
        auto __arg1 = vgap;

        int32_t hgap;
        status = napi_get_value_int32(env, args[2], &hgap);
        auto __arg2 = hgap;

        instance = new wxSharp::GridSizer(__arg0, __arg1, __arg2);
    }

    // GridSizer(int cols, const ::wxSharp::Size& gap)
overload1:
    {
        int32_t cols;
        status = napi_get_value_int32(env, args[0], &cols);
        auto __arg0 = cols;

        wxSharp::Size* gap_instance;
        status = napi_unwrap(env, _this, (void**) &gap_instance);
        auto &__arg1 = *gap_instance;

        instance = new wxSharp::GridSizer(__arg0, __arg1);
    }

    // GridSizer(int rows, int cols, int vgap, int hgap)
overload2:
    {
        int32_t rows;
        status = napi_get_value_int32(env, args[0], &rows);
        auto __arg0 = rows;

        int32_t cols;
        status = napi_get_value_int32(env, args[1], &cols);
        auto __arg1 = cols;

        int32_t vgap;
        status = napi_get_value_int32(env, args[2], &vgap);
        auto __arg2 = vgap;

        int32_t hgap;
        status = napi_get_value_int32(env, args[3], &hgap);
        auto __arg3 = hgap;

        instance = new wxSharp::GridSizer(__arg0, __arg1, __arg2, __arg3);
    }

    // GridSizer(int rows, int cols, const ::wxSharp::Size& gap)
overload3:
    {
        int32_t rows;
        status = napi_get_value_int32(env, args[0], &rows);
        auto __arg0 = rows;

        int32_t cols;
        status = napi_get_value_int32(env, args[1], &cols);
        auto __arg1 = cols;

        wxSharp::Size* gap_instance;
        status = napi_unwrap(env, _this, (void**) &gap_instance);
        auto &__arg2 = *gap_instance;

        instance = new wxSharp::GridSizer(__arg0, __arg1, __arg2);
    }

    // GridSizer(const ::wxSharp::GridSizer& _0)
overload4:
    {
        wxSharp::GridSizer* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::GridSizer(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_GridSizer_GridSizer, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::GridSizer::GridSizer: %lu\n", argc);
    return _this;
}

// wxSharp::GridSizer::RepositionChildren
static napi_value callback_method_wxSharp_GridSizer_RepositionChildren(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::GridSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void RepositionChildren(const ::wxSharp::Size& minSize) override
overload0:
    {
        wxSharp::Size* minSize_instance;
        status = napi_unwrap(env, _this, (void**) &minSize_instance);
        auto &__arg0 = *minSize_instance;

        instance->RepositionChildren(__arg0);
    }
    printf("wxSharp::GridSizer::RepositionChildren: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_GridSizer(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "RepositionChildren", nullptr, callback_method_wxSharp_GridSizer_RepositionChildren, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "GridSizer", NAPI_AUTO_LENGTH, callback_method_wxSharp_GridSizer_GridSizer, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_GridSizer_GridSizer);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_FlexGridSizer_FlexGridSizer(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_FlexGridSizer_FlexGridSizer;

// wxSharp::FlexGridSizer::FlexGridSizer
static napi_value callback_method_wxSharp_FlexGridSizer_FlexGridSizer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FlexGridSizer* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    if (NAPI_IS_OBJECT(types[1]))
        goto overload1;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload2;

    if (NAPI_IS_OBJECT(types[2]))
        goto overload3;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // FlexGridSizer(int cols, int vgap, int hgap)
overload0:
    {
        int32_t cols;
        status = napi_get_value_int32(env, args[0], &cols);
        auto __arg0 = cols;

        int32_t vgap;
        status = napi_get_value_int32(env, args[1], &vgap);
        auto __arg1 = vgap;

        int32_t hgap;
        status = napi_get_value_int32(env, args[2], &hgap);
        auto __arg2 = hgap;

        instance = new wxSharp::FlexGridSizer(__arg0, __arg1, __arg2);
    }

    // FlexGridSizer(int cols, const ::wxSharp::Size& gap)
overload1:
    {
        int32_t cols;
        status = napi_get_value_int32(env, args[0], &cols);
        auto __arg0 = cols;

        wxSharp::Size* gap_instance;
        status = napi_unwrap(env, _this, (void**) &gap_instance);
        auto &__arg1 = *gap_instance;

        instance = new wxSharp::FlexGridSizer(__arg0, __arg1);
    }

    // FlexGridSizer(int rows, int cols, int vgap, int hgap)
overload2:
    {
        int32_t rows;
        status = napi_get_value_int32(env, args[0], &rows);
        auto __arg0 = rows;

        int32_t cols;
        status = napi_get_value_int32(env, args[1], &cols);
        auto __arg1 = cols;

        int32_t vgap;
        status = napi_get_value_int32(env, args[2], &vgap);
        auto __arg2 = vgap;

        int32_t hgap;
        status = napi_get_value_int32(env, args[3], &hgap);
        auto __arg3 = hgap;

        instance = new wxSharp::FlexGridSizer(__arg0, __arg1, __arg2, __arg3);
    }

    // FlexGridSizer(int rows, int cols, const ::wxSharp::Size& gap)
overload3:
    {
        int32_t rows;
        status = napi_get_value_int32(env, args[0], &rows);
        auto __arg0 = rows;

        int32_t cols;
        status = napi_get_value_int32(env, args[1], &cols);
        auto __arg1 = cols;

        wxSharp::Size* gap_instance;
        status = napi_unwrap(env, _this, (void**) &gap_instance);
        auto &__arg2 = *gap_instance;

        instance = new wxSharp::FlexGridSizer(__arg0, __arg1, __arg2);
    }

    // FlexGridSizer
overload4:
    {
        wxSharp::FlexGridSizer* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::FlexGridSizer(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_FlexGridSizer_FlexGridSizer, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::FlexGridSizer::FlexGridSizer: %lu\n", argc);
    return _this;
}

// wxSharp::FlexGridSizer::AddGrowableRow
static napi_value callback_method_wxSharp_FlexGridSizer_AddGrowableRow(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FlexGridSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void AddGrowableRow(unsigned long idx, int proportion)
overload0:
    {
        uint32_t idx;
        status = napi_get_value_uint32(env, args[0], &idx);
        auto __arg0 = idx;

        int32_t proportion;
        status = napi_get_value_int32(env, args[1], &proportion);
        auto __arg1 = proportion;

        instance->AddGrowableRow(__arg0, __arg1);
    }
    printf("wxSharp::FlexGridSizer::AddGrowableRow: %lu\n", argc);
    return _this;
}

// wxSharp::FlexGridSizer::RemoveGrowableRow
static napi_value callback_method_wxSharp_FlexGridSizer_RemoveGrowableRow(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FlexGridSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void RemoveGrowableRow(unsigned long idx)
overload0:
    {
        uint32_t idx;
        status = napi_get_value_uint32(env, args[0], &idx);
        auto __arg0 = idx;

        instance->RemoveGrowableRow(__arg0);
    }
    printf("wxSharp::FlexGridSizer::RemoveGrowableRow: %lu\n", argc);
    return _this;
}

// wxSharp::FlexGridSizer::AddGrowableCol
static napi_value callback_method_wxSharp_FlexGridSizer_AddGrowableCol(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FlexGridSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void AddGrowableCol(unsigned long idx, int proportion)
overload0:
    {
        uint32_t idx;
        status = napi_get_value_uint32(env, args[0], &idx);
        auto __arg0 = idx;

        int32_t proportion;
        status = napi_get_value_int32(env, args[1], &proportion);
        auto __arg1 = proportion;

        instance->AddGrowableCol(__arg0, __arg1);
    }
    printf("wxSharp::FlexGridSizer::AddGrowableCol: %lu\n", argc);
    return _this;
}

// wxSharp::FlexGridSizer::RemoveGrowableCol
static napi_value callback_method_wxSharp_FlexGridSizer_RemoveGrowableCol(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FlexGridSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void RemoveGrowableCol(unsigned long idx)
overload0:
    {
        uint32_t idx;
        status = napi_get_value_uint32(env, args[0], &idx);
        auto __arg0 = idx;

        instance->RemoveGrowableCol(__arg0);
    }
    printf("wxSharp::FlexGridSizer::RemoveGrowableCol: %lu\n", argc);
    return _this;
}

// wxSharp::FlexGridSizer::IsRowGrowable
static napi_value callback_method_wxSharp_FlexGridSizer_IsRowGrowable(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FlexGridSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool IsRowGrowable(unsigned long idx)
overload0:
    {
        uint32_t idx;
        status = napi_get_value_uint32(env, args[0], &idx);
        auto __arg0 = idx;

        bool __ret = instance->IsRowGrowable(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::FlexGridSizer::IsRowGrowable: %lu\n", argc);
    return _this;
}

// wxSharp::FlexGridSizer::IsColGrowable
static napi_value callback_method_wxSharp_FlexGridSizer_IsColGrowable(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FlexGridSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool IsColGrowable(unsigned long idx)
overload0:
    {
        uint32_t idx;
        status = napi_get_value_uint32(env, args[0], &idx);
        auto __arg0 = idx;

        bool __ret = instance->IsColGrowable(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::FlexGridSizer::IsColGrowable: %lu\n", argc);
    return _this;
}

// wxSharp::FlexGridSizer::RepositionChildren
static napi_value callback_method_wxSharp_FlexGridSizer_RepositionChildren(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::FlexGridSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void RepositionChildren(const ::wxSharp::Size& minSize) override
overload0:
    {
        wxSharp::Size* minSize_instance;
        status = napi_unwrap(env, _this, (void**) &minSize_instance);
        auto &__arg0 = *minSize_instance;

        instance->RepositionChildren(__arg0);
    }
    printf("wxSharp::FlexGridSizer::RepositionChildren: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_FlexGridSizer(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "AddGrowableRow", nullptr, callback_method_wxSharp_FlexGridSizer_AddGrowableRow, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "RemoveGrowableRow", nullptr, callback_method_wxSharp_FlexGridSizer_RemoveGrowableRow, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "AddGrowableCol", nullptr, callback_method_wxSharp_FlexGridSizer_AddGrowableCol, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "RemoveGrowableCol", nullptr, callback_method_wxSharp_FlexGridSizer_RemoveGrowableCol, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "IsRowGrowable", nullptr, callback_method_wxSharp_FlexGridSizer_IsRowGrowable, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "IsColGrowable", nullptr, callback_method_wxSharp_FlexGridSizer_IsColGrowable, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "RepositionChildren", nullptr, callback_method_wxSharp_FlexGridSizer_RepositionChildren, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "FlexGridSizer", NAPI_AUTO_LENGTH, callback_method_wxSharp_FlexGridSizer_FlexGridSizer, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_FlexGridSizer_FlexGridSizer);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_BoxSizer_BoxSizer(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_BoxSizer_BoxSizer;

// wxSharp::BoxSizer::BoxSizer
static napi_value callback_method_wxSharp_BoxSizer_BoxSizer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::BoxSizer* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // BoxSizer(::wxSharp::SizerOrientation orient)
overload0:
    {
        int32_t orient;
        status = napi_get_value_int32(env, args[0], &orient);
        auto __arg0 = (::wxSharp::SizerOrientation)orient;

        instance = new wxSharp::BoxSizer(__arg0);
    }

    // BoxSizer(const ::wxSharp::BoxSizer& _0)
overload1:
    {
        wxSharp::BoxSizer* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::BoxSizer(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_BoxSizer_BoxSizer, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::BoxSizer::BoxSizer: %lu\n", argc);
    return _this;
}

// wxSharp::BoxSizer::AddSpacer
static napi_value callback_method_wxSharp_BoxSizer_AddSpacer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::BoxSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ::wxSharp::SizerItem* AddSpacer(int size) override
overload0:
    {
        int32_t size;
        status = napi_get_value_int32(env, args[0], &size);
        auto __arg0 = size;

        ::wxSharp::SizerItem* __ret = instance->AddSpacer(__arg0);

        napi_value ____ret_ctor;
        status = napi_get_reference_value(env, ctor_wxSharp_SizerItem_SizerItem, &____ret_ctor);
        assert(status == napi_ok);

        napi_value ____ret_instance;
        status = napi_new_instance(env, ____ret_ctor, 0, nullptr, &____ret_instance);
        assert(status == napi_ok);


        return ____ret_instance;
    }
    printf("wxSharp::BoxSizer::AddSpacer: %lu\n", argc);
    return _this;
}

// wxSharp::BoxSizer::RepositionChildren
static napi_value callback_method_wxSharp_BoxSizer_RepositionChildren(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::BoxSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void RepositionChildren(const ::wxSharp::Size& minSize) override
overload0:
    {
        wxSharp::Size* minSize_instance;
        status = napi_unwrap(env, _this, (void**) &minSize_instance);
        auto &__arg0 = *minSize_instance;

        instance->RepositionChildren(__arg0);
    }
    printf("wxSharp::BoxSizer::RepositionChildren: %lu\n", argc);
    return _this;
}

// wxSharp::BoxSizer::InformFirstDirection
static napi_value callback_method_wxSharp_BoxSizer_InformFirstDirection(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::BoxSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_INT32(types[1], args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool InformFirstDirection(int direction, int size, int availableOtherDir) override
overload0:
    {
        int32_t direction;
        status = napi_get_value_int32(env, args[0], &direction);
        auto __arg0 = direction;

        int32_t size;
        status = napi_get_value_int32(env, args[1], &size);
        auto __arg1 = size;

        int32_t availableOtherDir;
        status = napi_get_value_int32(env, args[2], &availableOtherDir);
        auto __arg2 = availableOtherDir;

        bool __ret = instance->InformFirstDirection(__arg0, __arg1, __arg2);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::BoxSizer::InformFirstDirection: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_BoxSizer(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "AddSpacer", nullptr, callback_method_wxSharp_BoxSizer_AddSpacer, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "RepositionChildren", nullptr, callback_method_wxSharp_BoxSizer_RepositionChildren, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "InformFirstDirection", nullptr, callback_method_wxSharp_BoxSizer_InformFirstDirection, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "BoxSizer", NAPI_AUTO_LENGTH, callback_method_wxSharp_BoxSizer_BoxSizer, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_BoxSizer_BoxSizer);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_StaticBoxSizer_StaticBoxSizer(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_StaticBoxSizer_StaticBoxSizer;

// wxSharp::StaticBoxSizer::StaticBoxSizer
static napi_value callback_method_wxSharp_StaticBoxSizer_StaticBoxSizer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::StaticBoxSizer* instance = nullptr;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload1;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // StaticBoxSizer(::wxSharp::SizerOrientation orient, ::wxSharp::Window* win, const char* label)
overload0:
    {
        int32_t orient;
        status = napi_get_value_int32(env, args[0], &orient);
        auto __arg0 = (::wxSharp::SizerOrientation)orient;

        wxSharp::Window* win_instance;
        status = napi_unwrap(env, _this, (void**) &win_instance);
        auto __arg1 = win_instance;

        size_t _label_size;
        status = napi_get_value_string_utf8(env, args[2], nullptr, 0, &_label_size);

        char* label = (char*) malloc(_label_size);
        status = napi_get_value_string_utf8(env, args[2], nullptr, 0, &_label_size);
        assert(status == napi_ok);
        auto __arg2 = label;

        instance = new wxSharp::StaticBoxSizer(__arg0, __arg1, __arg2);
    }

    // StaticBoxSizer
overload1:
    {
        wxSharp::StaticBoxSizer* _0_instance;
        status = napi_unwrap(env, _this, (void**) &_0_instance);
        auto &__arg0 = *_0_instance;

        instance = new wxSharp::StaticBoxSizer(__arg0);
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_StaticBoxSizer_StaticBoxSizer, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::StaticBoxSizer::StaticBoxSizer: %lu\n", argc);
    return _this;
}

// wxSharp::StaticBoxSizer::RepositionChildren
static napi_value callback_method_wxSharp_StaticBoxSizer_RepositionChildren(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::StaticBoxSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void RepositionChildren(const ::wxSharp::Size& minSize) override
overload0:
    {
        wxSharp::Size* minSize_instance;
        status = napi_unwrap(env, _this, (void**) &minSize_instance);
        auto &__arg0 = *minSize_instance;

        instance->RepositionChildren(__arg0);
    }
    printf("wxSharp::StaticBoxSizer::RepositionChildren: %lu\n", argc);
    return _this;
}

// wxSharp::StaticBoxSizer::ShowItems
static napi_value callback_method_wxSharp_StaticBoxSizer_ShowItems(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::StaticBoxSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_BOOL(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // void ShowItems(bool show) override
overload0:
    {
        bool show;
        status = napi_get_value_bool(env, args[0], &show);
        auto __arg0 = (bool)show;

        instance->ShowItems(__arg0);
    }
    printf("wxSharp::StaticBoxSizer::ShowItems: %lu\n", argc);
    return _this;
}

// wxSharp::StaticBoxSizer::Detach
static napi_value callback_method_wxSharp_StaticBoxSizer_Detach(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::StaticBoxSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload1;

    if (NAPI_IS_INT32(types[0], args[0]))
        goto overload2;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // bool Detach(::wxSharp::Window* window) override
overload0:
    {
        wxSharp::Window* window_instance;
        status = napi_unwrap(env, _this, (void**) &window_instance);
        auto __arg0 = window_instance;

        bool __ret = instance->Detach(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Detach(::wxSharp::Sizer* sizer) override
overload1:
    {
        wxSharp::Sizer* sizer_instance;
        status = napi_unwrap(env, _this, (void**) &sizer_instance);
        auto __arg0 = sizer_instance;

        bool __ret = instance->Detach(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }

    // bool Detach(int index) override
overload2:
    {
        int32_t index;
        status = napi_get_value_int32(env, args[0], &index);
        auto __arg0 = index;

        bool __ret = instance->Detach(__arg0);

        napi_value __result;
        status = napi_get_boolean(env, __ret, &__result);
        assert(status == napi_ok);

        return __result;
    }
    printf("wxSharp::StaticBoxSizer::Detach: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_StaticBoxSizer(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "RepositionChildren", nullptr, callback_method_wxSharp_StaticBoxSizer_RepositionChildren, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "ShowItems", nullptr, callback_method_wxSharp_StaticBoxSizer_ShowItems, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
        { "Detach", nullptr, callback_method_wxSharp_StaticBoxSizer_Detach, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "StaticBoxSizer", NAPI_AUTO_LENGTH, callback_method_wxSharp_StaticBoxSizer_StaticBoxSizer, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_StaticBoxSizer_StaticBoxSizer);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_wxSharp_StdDialogButtonSizer_StdDialogButtonSizer(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_wxSharp_StdDialogButtonSizer_StdDialogButtonSizer;

// wxSharp::StdDialogButtonSizer::StdDialogButtonSizer
static napi_value callback_method_wxSharp_StdDialogButtonSizer_StdDialogButtonSizer(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    napi_value args[argc];
    status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
    assert(status == napi_ok);

    napi_valuetype types[argc];
    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    wxSharp::StdDialogButtonSizer* instance = nullptr;

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // StdDialogButtonSizer()
overload0:
    {
        instance = new wxSharp::StdDialogButtonSizer();
    }
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_wxSharp_StdDialogButtonSizer_StdDialogButtonSizer, nullptr, &result);
    assert(status == napi_ok);

    printf("wxSharp::StdDialogButtonSizer::StdDialogButtonSizer: %lu\n", argc);
    return _this;
}

// wxSharp::StdDialogButtonSizer::Realize
static napi_value callback_method_wxSharp_StdDialogButtonSizer_Realize(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    wxSharp::StdDialogButtonSizer* instance;
    status = napi_unwrap(env, _this, (void**) &instance);

    instance->Realize();
    printf("wxSharp::StdDialogButtonSizer::Realize: %lu\n", argc);
    return _this;
}

static napi_value register_class_wxSharp_StdDialogButtonSizer(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "Realize", nullptr, callback_method_wxSharp_StdDialogButtonSizer_Realize, nullptr, nullptr, nullptr, (napi_property_attributes)(attributes), nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "StdDialogButtonSizer", NAPI_AUTO_LENGTH, callback_method_wxSharp_StdDialogButtonSizer_StdDialogButtonSizer, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_wxSharp_StdDialogButtonSizer_StdDialogButtonSizer);
    assert(status == napi_ok);

    return constructor;
}

void register_wxsharp_sizer(napi_env env, napi_value exports)
{
    napi_value value;

    value = register_enum_wxSharp_FlexSizerGrowMode(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "FlexSizerGrowMode", value));

    value = register_class_wxSharp_SizerFlags(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "SizerFlags", value));

    value = register_class_wxSharp_SizerSpacer(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "SizerSpacer", value));

    value = register_class_wxSharp_SizerItem(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "SizerItem", value));

    value = register_class_wxSharp_SizerItemList(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "SizerItemList", value));

    value = register_class_wxSharp_Sizer(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Sizer", value));

    value = register_class_wxSharp_GridSizer(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "GridSizer", value));

    value = register_class_wxSharp_FlexGridSizer(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "FlexGridSizer", value));

    value = register_class_wxSharp_BoxSizer(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "BoxSizer", value));

    value = register_class_wxSharp_StaticBoxSizer(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "StaticBoxSizer", value));

    value = register_class_wxSharp_StdDialogButtonSizer(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "StdDialogButtonSizer", value));
}
