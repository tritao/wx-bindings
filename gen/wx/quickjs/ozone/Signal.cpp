// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <quickjs.h>
#include <assert.h>

extern "C" {

class Signal
{

};

extern JSClassID classId__Signal;

JSClassID classId__Signal;

// Signal::Signal
static JSValue callback_method_Signal_Signal(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Signal* instance;

    instance = new Signal();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId__Signal);
    else
        proto = JS_GetPropertyStr(ctx, this_val, "prototype");

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId__Signal);
    JS_SetOpaque(__obj, instance);

    JS_FreeValue(ctx, proto);

    return __obj;
}

void finalizer__Signal(JSRuntime *rt, JSValue val)
{
}

static JSClassDef classDef__Signal
{
    "Signal",
    .finalizer = finalizer__Signal
};

static JSCFunctionListEntry funcDef__Signal[]
{
};

static void register_class__Signal(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "Signal");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId__Signal);

        JS_NewClass(JS_GetRuntime(ctx), classId__Signal, &classDef__Signal);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef__Signal, sizeof(funcDef__Signal) / sizeof(funcDef__Signal[0]));
        JS_SetClassProto(ctx, classId__Signal, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Signal_Signal, "Signal", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "Signal", ctor);
    }
}

void register_signal(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    register_class__Signal(ctx, m, set, phase);
}
}
