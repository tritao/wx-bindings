// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <CppSharp_QuickJS.h>
#include <assert.h>
#include <ozone/colour.h>

extern "C" {

extern JSClassID classId_Ozone_Color;
extern JSClassID classId__Signal;

static void register_enum_Ozone_C2S(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "C2S");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // C2S_NAME
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "C2S_NAME", __item);
    }

    // C2S_CSS_SYNTAX
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "C2S_CSS_SYNTAX", __item);
    }

    // C2S_HTML_SYNTAX
    {
        JSValue __item = JS_NewUint32(ctx, 4);
        JS_SetPropertyStr(ctx, val, "C2S_HTML_SYNTAX", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "C2S", val);
    assert(status != -1);
}

JSClassID classId_Ozone_Color;

// Ozone::Color::Color
static JSValue callback_method_Ozone_Color_Color(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 4)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance;

    if (argc == 0)
        goto overload0;

    if (JS_IsUInt8(argv[0]))
        goto typecheck1;

    if (JS_IsUInt32(argv[0]))
        goto overload2;

    if (JS_IsString(argv[0]) || JS_IsNull(argv[0]))
        goto overload3;

    if (JS_IsString(argv[0]) || JS_IsNull(argv[0]))
        goto overload4;

    goto error;

typecheck1:
    if (JS_IsUInt8(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsUInt8(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsUInt8(argv[3]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // Color()
overload0:
    {
        instance = new Ozone::Color();

        goto wrap;
    }

    // Color(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha)
overload1:
    {
        unsigned char red;
        int32_t _red;
        if (JS_ToInt32(ctx, &_red, argv[0]))
            return JS_EXCEPTION;
        red = (unsigned char)_red;
        auto __arg0 = red;

        unsigned char green;
        int32_t _green;
        if (JS_ToInt32(ctx, &_green, argv[1]))
            return JS_EXCEPTION;
        green = (unsigned char)_green;
        auto __arg1 = green;

        unsigned char blue;
        int32_t _blue;
        if (JS_ToInt32(ctx, &_blue, argv[2]))
            return JS_EXCEPTION;
        blue = (unsigned char)_blue;
        auto __arg2 = blue;

        unsigned char alpha;
        int32_t _alpha;
        if (JS_ToInt32(ctx, &_alpha, argv[3]))
            return JS_EXCEPTION;
        alpha = (unsigned char)_alpha;
        auto __arg3 = alpha;

        instance = new Ozone::Color(__arg0, __arg1, __arg2, __arg3);

        goto wrap;
    }

    // Color(unsigned long colRGB)
overload2:
    {
        unsigned long colRGB;
        uint32_t _colRGB;
        if (JS_ToUint32(ctx, &_colRGB, argv[0]))
            return JS_EXCEPTION;
        colRGB = (unsigned long)_colRGB;
        auto __arg0 = colRGB;

        instance = new Ozone::Color(__arg0);

        goto wrap;
    }

    // Color(const char* colourName)
overload3:
    {
        const char* colourName;
        colourName = JS_ToCString(ctx, argv[0]);
        if (!colourName)
            return JS_EXCEPTION;
        auto __arg0 = colourName;

        instance = new Ozone::Color(__arg0);

        JS_FreeCString(ctx, colourName);

        goto wrap;
    }

    // Color(const wchar_t* colourName)
overload4:
    {
        const char* colourName;
        colourName = JS_ToCString(ctx, argv[0]);
        if (!colourName)
            return JS_EXCEPTION;
        auto __arg0 = colourName;

        instance = new Ozone::Color(__arg0);

        JS_FreeCString(ctx, colourName);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_Color);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_Color);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::Color::operator==
static JSValue callback_method_Ozone_Color_operator_EqualEqual(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool operator==(const ::Ozone::Color& col) const
overload0:
    {
        Ozone::Color* col_instance = (Ozone::Color*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Color, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *col_instance;

        bool __ret = instance->operator==(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Color::operator!=
static JSValue callback_method_Ozone_Color_operator_ExclaimEqual(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool operator!=(const ::Ozone::Color& col) const
overload0:
    {
        Ozone::Color* col_instance = (Ozone::Color*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Color, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *col_instance;

        bool __ret = instance->operator!=(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Color::Red
static JSValue callback_method_Ozone_Color_Red(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    unsigned char __ret = instance->Red();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Color::Green
static JSValue callback_method_Ozone_Color_Green(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    unsigned char __ret = instance->Green();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Color::Blue
static JSValue callback_method_Ozone_Color_Blue(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    unsigned char __ret = instance->Blue();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Color::Alpha
static JSValue callback_method_Ozone_Color_Alpha(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    unsigned char __ret = instance->Alpha();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Color::Set
static JSValue callback_method_Ozone_Color_Set(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 4)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    if (JS_IsUInt8(argv[0]))
        goto typecheck1;

    if (JS_IsString(argv[0]) || JS_IsNull(argv[0]))
        goto overload1;

    if (JS_IsUInt32(argv[0]))
        goto overload2;

    goto error;

typecheck1:
    if (JS_IsUInt8(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsUInt8(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsUInt8(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Set(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha)
overload0:
    {
        unsigned char red;
        int32_t _red;
        if (JS_ToInt32(ctx, &_red, argv[0]))
            return JS_EXCEPTION;
        red = (unsigned char)_red;
        auto __arg0 = red;

        unsigned char green;
        int32_t _green;
        if (JS_ToInt32(ctx, &_green, argv[1]))
            return JS_EXCEPTION;
        green = (unsigned char)_green;
        auto __arg1 = green;

        unsigned char blue;
        int32_t _blue;
        if (JS_ToInt32(ctx, &_blue, argv[2]))
            return JS_EXCEPTION;
        blue = (unsigned char)_blue;
        auto __arg2 = blue;

        unsigned char alpha;
        int32_t _alpha;
        if (JS_ToInt32(ctx, &_alpha, argv[3]))
            return JS_EXCEPTION;
        alpha = (unsigned char)_alpha;
        auto __arg3 = alpha;

        instance->Set(__arg0, __arg1, __arg2, __arg3);


        return JS_UNDEFINED;
    }

    // bool Set(const char* str)
overload1:
    {
        const char* str;
        str = JS_ToCString(ctx, argv[0]);
        if (!str)
            return JS_EXCEPTION;
        auto __arg0 = str;

        bool __ret = instance->Set(__arg0);

        JS_FreeCString(ctx, str);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // void Set(unsigned long colRGB)
overload2:
    {
        unsigned long colRGB;
        uint32_t _colRGB;
        if (JS_ToUint32(ctx, &_colRGB, argv[0]))
            return JS_EXCEPTION;
        colRGB = (unsigned long)_colRGB;
        auto __arg0 = colRGB;

        instance->Set(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Color::IsSolid
static JSValue callback_method_Ozone_Color_IsSolid(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsSolid();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::Color::GetAsString
static JSValue callback_method_Ozone_Color_GetAsString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // char* GetAsString(long flags) const
overload0:
    {
        long flags;
        int32_t _flags;
        if (JS_ToInt32(ctx, &_flags, argv[0]))
            return JS_EXCEPTION;
        flags = (long)_flags;
        auto __arg0 = flags;

        const char* __ret = instance->GetAsString(__arg0);

        JSValue ____ret = JS_NewString(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Color::SetRGB
static JSValue callback_method_Ozone_Color_SetRGB(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    if (JS_IsUInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetRGB(unsigned int colRGB)
overload0:
    {
        unsigned int colRGB;
        uint32_t _colRGB;
        if (JS_ToUint32(ctx, &_colRGB, argv[0]))
            return JS_EXCEPTION;
        colRGB = (unsigned int)_colRGB;
        auto __arg0 = colRGB;

        instance->SetRGB(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Color::SetRGBA
static JSValue callback_method_Ozone_Color_SetRGBA(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    if (JS_IsUInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetRGBA(unsigned int colRGBA)
overload0:
    {
        unsigned int colRGBA;
        uint32_t _colRGBA;
        if (JS_ToUint32(ctx, &_colRGBA, argv[0]))
            return JS_EXCEPTION;
        colRGBA = (unsigned int)_colRGBA;
        auto __arg0 = colRGBA;

        instance->SetRGBA(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Color::GetRGB
static JSValue callback_method_Ozone_Color_GetRGB(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    unsigned int __ret = instance->GetRGB();

    JSValue ____ret = JS_NewUint32(ctx, __ret);

    return ____ret;
}

// Ozone::Color::GetRGBA
static JSValue callback_method_Ozone_Color_GetRGBA(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    unsigned int __ret = instance->GetRGBA();

    JSValue ____ret = JS_NewUint32(ctx, __ret);

    return ____ret;
}

// Ozone::Color::GetLuminance
static JSValue callback_method_Ozone_Color_GetLuminance(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetLuminance();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::Color::ChangeLightness
static JSValue callback_method_Ozone_Color_ChangeLightness(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Color ChangeLightness(int ialpha) const
overload0:
    {
        int ialpha;
        int32_t _ialpha;
        if (JS_ToInt32(ctx, &_ialpha, argv[0]))
            return JS_EXCEPTION;
        ialpha = (int)_ialpha;
        auto __arg0 = ialpha;

        ::Ozone::Color __ret = instance->ChangeLightness(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Color, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

        return ____ret;
    }
}

// Ozone::Color::AlphaBlend
static JSValue callback_method_Ozone_Color_AlphaBlend(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 3)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    if (JS_IsUInt8(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsUInt8(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsFloat(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // unsigned char AlphaBlend(unsigned char fg, unsigned char bg, double alpha)
overload0:
    {
        unsigned char fg;
        int32_t _fg;
        if (JS_ToInt32(ctx, &_fg, argv[0]))
            return JS_EXCEPTION;
        fg = (unsigned char)_fg;
        auto __arg0 = fg;

        unsigned char bg;
        int32_t _bg;
        if (JS_ToInt32(ctx, &_bg, argv[1]))
            return JS_EXCEPTION;
        bg = (unsigned char)_bg;
        auto __arg1 = bg;

        double alpha;
        if (JS_ToFloat64(ctx, &alpha, argv[2]))
            return JS_EXCEPTION;
        auto __arg2 = alpha;

        unsigned char __ret = ::Ozone::Color::AlphaBlend(__arg0, __arg1, __arg2);

        JSValue ____ret = JS_NewInt32(ctx, __ret);

        return ____ret;
    }
}

static JSValue callback_class_Ozone_Color_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "Color");
}

void finalizer_Ozone_Color(JSRuntime *rt, JSValue val)
{
    Ozone::Color* instance = (Ozone::Color*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_Color
{
    "Color",
    .finalizer = finalizer_Ozone_Color
};

static JSCFunctionListEntry funcDef_Ozone_Color[]
{
    JS_CFUNC_DEF("operator==", 1, callback_method_Ozone_Color_operator_EqualEqual),
    JS_CFUNC_DEF("operator!=", 1, callback_method_Ozone_Color_operator_ExclaimEqual),
    JS_CFUNC_DEF("Red", 0, callback_method_Ozone_Color_Red),
    JS_CFUNC_DEF("Green", 0, callback_method_Ozone_Color_Green),
    JS_CFUNC_DEF("Blue", 0, callback_method_Ozone_Color_Blue),
    JS_CFUNC_DEF("Alpha", 0, callback_method_Ozone_Color_Alpha),
    JS_CFUNC_DEF("Set", 4, callback_method_Ozone_Color_Set),
    JS_CFUNC_DEF("IsSolid", 0, callback_method_Ozone_Color_IsSolid),
    JS_CFUNC_DEF("GetAsString", 1, callback_method_Ozone_Color_GetAsString),
    JS_CFUNC_DEF("SetRGB", 1, callback_method_Ozone_Color_SetRGB),
    JS_CFUNC_DEF("SetRGBA", 1, callback_method_Ozone_Color_SetRGBA),
    JS_CFUNC_DEF("GetRGB", 0, callback_method_Ozone_Color_GetRGB),
    JS_CFUNC_DEF("GetRGBA", 0, callback_method_Ozone_Color_GetRGBA),
    JS_CFUNC_DEF("GetLuminance", 0, callback_method_Ozone_Color_GetLuminance),
    JS_CFUNC_DEF("ChangeLightness", 1, callback_method_Ozone_Color_ChangeLightness),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_Color_toString),
};

static JSCFunctionListEntry funcDef_Ozone_Color_statics[]
{
    JS_CFUNC_DEF("operator==", 1, callback_method_Ozone_Color_operator_EqualEqual),
    JS_CFUNC_DEF("operator!=", 1, callback_method_Ozone_Color_operator_ExclaimEqual),
    JS_CFUNC_DEF("Red", 0, callback_method_Ozone_Color_Red),
    JS_CFUNC_DEF("Green", 0, callback_method_Ozone_Color_Green),
    JS_CFUNC_DEF("Blue", 0, callback_method_Ozone_Color_Blue),
    JS_CFUNC_DEF("Alpha", 0, callback_method_Ozone_Color_Alpha),
    JS_CFUNC_DEF("Set", 4, callback_method_Ozone_Color_Set),
    JS_CFUNC_DEF("IsSolid", 0, callback_method_Ozone_Color_IsSolid),
    JS_CFUNC_DEF("GetAsString", 1, callback_method_Ozone_Color_GetAsString),
    JS_CFUNC_DEF("SetRGB", 1, callback_method_Ozone_Color_SetRGB),
    JS_CFUNC_DEF("SetRGBA", 1, callback_method_Ozone_Color_SetRGBA),
    JS_CFUNC_DEF("GetRGB", 0, callback_method_Ozone_Color_GetRGB),
    JS_CFUNC_DEF("GetRGBA", 0, callback_method_Ozone_Color_GetRGBA),
    JS_CFUNC_DEF("GetLuminance", 0, callback_method_Ozone_Color_GetLuminance),
    JS_CFUNC_DEF("ChangeLightness", 1, callback_method_Ozone_Color_ChangeLightness),
    JS_CFUNC_DEF("AlphaBlend", 3, callback_method_Ozone_Color_AlphaBlend),
};

static void register_class_Ozone_Color(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "Color");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_Color);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_Color, &classDef_Ozone_Color);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_Color, countof(funcDef_Ozone_Color));
        JS_SetClassProto(ctx, classId_Ozone_Color, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_Color_Color, "Color", 4, JS_CFUNC_constructor, 0);
        JS_SetPropertyFunctionList(ctx, ctor, funcDef_Ozone_Color_statics, countof(funcDef_Ozone_Color_statics));
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "Color", ctor);
    }
}

void register_ozone_colour(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (phase == 0)
    {
        register_enum_Ozone_C2S(ctx, m, set);
    }

    register_class_Ozone_Color(ctx, m, set, phase);
}

} // extern "C"
