// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <CppSharp_QuickJS.h>
#include <assert.h>
#include <ozone/dc.h>

extern "C" {

extern JSClassID classId_Ozone_FontMetrics;
extern JSClassID classId_Ozone_DC;
extern JSClassID classId_Ozone_Object;
extern JSClassID classId_Ozone_GraphicsContext;
extern JSClassID classId_Ozone_Window;
extern JSClassID classId_Ozone_Size;
extern JSClassID classId_Ozone_Pen;
extern JSClassID classId_Ozone_Brush;
extern JSClassID classId_Ozone_Color;
extern JSClassID classId_Ozone_Point;
extern JSClassID classId_Ozone_Rect;
extern JSClassID classId__Signal;

static void register_enum_Ozone_RasterOperationMode(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "RasterOperationMode");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // CLEAR
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "CLEAR", __item);
    }

    // XOR
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "XOR", __item);
    }

    // INVERT
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "INVERT", __item);
    }

    // OR_REVERSE
    {
        JSValue __item = JS_NewUint32(ctx, 3);
        JS_SetPropertyStr(ctx, val, "OR_REVERSE", __item);
    }

    // AND_REVERSE
    {
        JSValue __item = JS_NewUint32(ctx, 4);
        JS_SetPropertyStr(ctx, val, "AND_REVERSE", __item);
    }

    // COPY
    {
        JSValue __item = JS_NewUint32(ctx, 5);
        JS_SetPropertyStr(ctx, val, "COPY", __item);
    }

    // AND
    {
        JSValue __item = JS_NewUint32(ctx, 6);
        JS_SetPropertyStr(ctx, val, "AND", __item);
    }

    // AND_INVERT
    {
        JSValue __item = JS_NewUint32(ctx, 7);
        JS_SetPropertyStr(ctx, val, "AND_INVERT", __item);
    }

    // NO_OP
    {
        JSValue __item = JS_NewUint32(ctx, 8);
        JS_SetPropertyStr(ctx, val, "NO_OP", __item);
    }

    // NOR
    {
        JSValue __item = JS_NewUint32(ctx, 9);
        JS_SetPropertyStr(ctx, val, "NOR", __item);
    }

    // EQUIV
    {
        JSValue __item = JS_NewUint32(ctx, 10);
        JS_SetPropertyStr(ctx, val, "EQUIV", __item);
    }

    // SRC_INVERT
    {
        JSValue __item = JS_NewUint32(ctx, 11);
        JS_SetPropertyStr(ctx, val, "SRC_INVERT", __item);
    }

    // OR_INVERT
    {
        JSValue __item = JS_NewUint32(ctx, 12);
        JS_SetPropertyStr(ctx, val, "OR_INVERT", __item);
    }

    // NAND
    {
        JSValue __item = JS_NewUint32(ctx, 13);
        JS_SetPropertyStr(ctx, val, "NAND", __item);
    }

    // OR
    {
        JSValue __item = JS_NewUint32(ctx, 14);
        JS_SetPropertyStr(ctx, val, "OR", __item);
    }

    // SET
    {
        JSValue __item = JS_NewUint32(ctx, 15);
        JS_SetPropertyStr(ctx, val, "SET", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "RasterOperationMode", val);
    assert(status != -1);
}

static void register_enum_Ozone_MappingMode(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "MappingMode");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // MM_TEXT
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "MM_TEXT", __item);
    }

    // MM_METRIC
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "MM_METRIC", __item);
    }

    // MM_LOMETRIC
    {
        JSValue __item = JS_NewUint32(ctx, 3);
        JS_SetPropertyStr(ctx, val, "MM_LOMETRIC", __item);
    }

    // MM_TWIPS
    {
        JSValue __item = JS_NewUint32(ctx, 4);
        JS_SetPropertyStr(ctx, val, "MM_TWIPS", __item);
    }

    // MM_POINTS
    {
        JSValue __item = JS_NewUint32(ctx, 5);
        JS_SetPropertyStr(ctx, val, "MM_POINTS", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "MappingMode", val);
    assert(status != -1);
}

static void register_enum_Ozone_FloodFillStyle(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "FloodFillStyle");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // FLOOD_SURFACE
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "FLOOD_SURFACE", __item);
    }

    // FLOOD_BORDER
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "FLOOD_BORDER", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "FloodFillStyle", val);
    assert(status != -1);
}

JSClassID classId_Ozone_FontMetrics;

// Ozone::FontMetrics::FontMetrics
static JSValue callback_method_Ozone_FontMetrics_FontMetrics(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance;

    instance = new Ozone::FontMetrics();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_FontMetrics);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_FontMetrics);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::FontMetrics::get_height
static JSValue callback_method_Ozone_FontMetrics_get_height(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_height();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::FontMetrics::set_height
static JSValue callback_method_Ozone_FontMetrics_set_height(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_height(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_height(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::FontMetrics::get_ascent
static JSValue callback_method_Ozone_FontMetrics_get_ascent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_ascent();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::FontMetrics::set_ascent
static JSValue callback_method_Ozone_FontMetrics_set_ascent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_ascent(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_ascent(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::FontMetrics::get_descent
static JSValue callback_method_Ozone_FontMetrics_get_descent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_descent();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::FontMetrics::set_descent
static JSValue callback_method_Ozone_FontMetrics_set_descent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_descent(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_descent(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::FontMetrics::get_internalLeading
static JSValue callback_method_Ozone_FontMetrics_get_internalLeading(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_internalLeading();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::FontMetrics::set_internalLeading
static JSValue callback_method_Ozone_FontMetrics_set_internalLeading(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_internalLeading(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_internalLeading(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::FontMetrics::get_externalLeading
static JSValue callback_method_Ozone_FontMetrics_get_externalLeading(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_externalLeading();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::FontMetrics::set_externalLeading
static JSValue callback_method_Ozone_FontMetrics_set_externalLeading(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_externalLeading(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_externalLeading(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::FontMetrics::get_averageWidth
static JSValue callback_method_Ozone_FontMetrics_get_averageWidth(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_averageWidth();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::FontMetrics::set_averageWidth
static JSValue callback_method_Ozone_FontMetrics_set_averageWidth(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_averageWidth(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_averageWidth(__arg0);

        return JS_UNDEFINED;
    }
}

static JSValue callback_class_Ozone_FontMetrics_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "FontMetrics");
}

void finalizer_Ozone_FontMetrics(JSRuntime *rt, JSValue val)
{
    Ozone::FontMetrics* instance = (Ozone::FontMetrics*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_FontMetrics
{
    "FontMetrics",
    .finalizer = finalizer_Ozone_FontMetrics
};

static JSCFunctionListEntry funcDef_Ozone_FontMetrics[]
{
    JS_CFUNC_DEF("get_height", 0, callback_method_Ozone_FontMetrics_get_height),
    JS_CFUNC_DEF("set_height", 1, callback_method_Ozone_FontMetrics_set_height),
    JS_CFUNC_DEF("get_ascent", 0, callback_method_Ozone_FontMetrics_get_ascent),
    JS_CFUNC_DEF("set_ascent", 1, callback_method_Ozone_FontMetrics_set_ascent),
    JS_CFUNC_DEF("get_descent", 0, callback_method_Ozone_FontMetrics_get_descent),
    JS_CFUNC_DEF("set_descent", 1, callback_method_Ozone_FontMetrics_set_descent),
    JS_CFUNC_DEF("get_internalLeading", 0, callback_method_Ozone_FontMetrics_get_internalLeading),
    JS_CFUNC_DEF("set_internalLeading", 1, callback_method_Ozone_FontMetrics_set_internalLeading),
    JS_CFUNC_DEF("get_externalLeading", 0, callback_method_Ozone_FontMetrics_get_externalLeading),
    JS_CFUNC_DEF("set_externalLeading", 1, callback_method_Ozone_FontMetrics_set_externalLeading),
    JS_CFUNC_DEF("get_averageWidth", 0, callback_method_Ozone_FontMetrics_get_averageWidth),
    JS_CFUNC_DEF("set_averageWidth", 1, callback_method_Ozone_FontMetrics_set_averageWidth),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_FontMetrics_toString),
};

static void register_class_Ozone_FontMetrics(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "FontMetrics");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_FontMetrics);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_FontMetrics, &classDef_Ozone_FontMetrics);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_FontMetrics, sizeof(funcDef_Ozone_FontMetrics) / sizeof(funcDef_Ozone_FontMetrics[0]));
        JS_SetClassProto(ctx, classId_Ozone_FontMetrics, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_FontMetrics_FontMetrics, "FontMetrics", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "FontMetrics", ctor);
    }
}

JSClassID classId_Ozone_DC;

// Ozone::DC::GetResolution
static JSValue callback_method_Ozone_DC_GetResolution(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetResolution();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::DC::GetGraphicsContext
static JSValue callback_method_Ozone_DC_GetGraphicsContext(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    ::Ozone::GraphicsContext* __ret = instance->GetGraphicsContext();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::DC::SetGraphicsContext
static JSValue callback_method_Ozone_DC_SetGraphicsContext(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetGraphicsContext(::Ozone::GraphicsContext* ctx)
overload0:
    {
        Ozone::GraphicsContext* ctx_instance = (Ozone::GraphicsContext*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsContext);

        auto __arg0 = ctx_instance;
        instance->SetGraphicsContext(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::CopyAttributes
static JSValue callback_method_Ozone_DC_CopyAttributes(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void CopyAttributes(const ::Ozone::DC& dc)
overload0:
    {
        Ozone::DC* dc_instance = (Ozone::DC*) JS_GetOpaque(argv[0], classId_Ozone_DC);

        auto &__arg0 = *dc_instance;
        instance->CopyAttributes(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::GetWindow
static JSValue callback_method_Ozone_DC_GetWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->GetWindow();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::DC::IsOk
static JSValue callback_method_Ozone_DC_IsOk(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsOk();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::DC::CanDrawBitmap
static JSValue callback_method_Ozone_DC_CanDrawBitmap(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->CanDrawBitmap();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::DC::CanGetTextExtent
static JSValue callback_method_Ozone_DC_CanGetTextExtent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->CanGetTextExtent();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::DC::GetSize
static JSValue callback_method_Ozone_DC_GetSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetSize();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::DC::GetSizeMM
static JSValue callback_method_Ozone_DC_GetSizeMM(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetSizeMM();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::DC::GetDepth
static JSValue callback_method_Ozone_DC_GetDepth(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetDepth();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::DC::GetPPI
static JSValue callback_method_Ozone_DC_GetPPI(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetPPI();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::DC::GetContentScaleFactor
static JSValue callback_method_Ozone_DC_GetContentScaleFactor(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetContentScaleFactor();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::DC::StartDoc
static JSValue callback_method_Ozone_DC_StartDoc(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsString(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool StartDoc(const char* message)
overload0:
    {
        const char* message;
        message = JS_ToCString(ctx, argv[0]);
        if (!message)
            return JS_EXCEPTION;

        auto __arg0 = message;
        bool __ret = instance->StartDoc(__arg0);

        JS_FreeCString(ctx, message);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::EndDoc
static JSValue callback_method_Ozone_DC_EndDoc(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    instance->EndDoc();

    return JS_UNDEFINED;
}

// Ozone::DC::StartPage
static JSValue callback_method_Ozone_DC_StartPage(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    instance->StartPage();

    return JS_UNDEFINED;
}

// Ozone::DC::EndPage
static JSValue callback_method_Ozone_DC_EndPage(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    instance->EndPage();

    return JS_UNDEFINED;
}

// Ozone::DC::CalcBoundingBox
static JSValue callback_method_Ozone_DC_CalcBoundingBox(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void CalcBoundingBox(int x, int y)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        instance->CalcBoundingBox(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::ResetBoundingBox
static JSValue callback_method_Ozone_DC_ResetBoundingBox(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    instance->ResetBoundingBox();

    return JS_UNDEFINED;
}

// Ozone::DC::MinX
static JSValue callback_method_Ozone_DC_MinX(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    int __ret = instance->MinX();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::DC::MaxX
static JSValue callback_method_Ozone_DC_MaxX(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    int __ret = instance->MaxX();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::DC::MinY
static JSValue callback_method_Ozone_DC_MinY(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    int __ret = instance->MinY();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::DC::MaxY
static JSValue callback_method_Ozone_DC_MaxY(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    int __ret = instance->MaxY();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::DC::SetPen
static JSValue callback_method_Ozone_DC_SetPen(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPen(const ::Ozone::Pen& pen)
overload0:
    {
        Ozone::Pen* pen_instance = (Ozone::Pen*) JS_GetOpaque(argv[0], classId_Ozone_Pen);

        auto &__arg0 = *pen_instance;
        instance->SetPen(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::SetBrush
static JSValue callback_method_Ozone_DC_SetBrush(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetBrush(const ::Ozone::Brush& brush)
overload0:
    {
        Ozone::Brush* brush_instance = (Ozone::Brush*) JS_GetOpaque(argv[0], classId_Ozone_Brush);

        auto &__arg0 = *brush_instance;
        instance->SetBrush(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::SetBackground
static JSValue callback_method_Ozone_DC_SetBackground(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetBackground(const ::Ozone::Brush& brush)
overload0:
    {
        Ozone::Brush* brush_instance = (Ozone::Brush*) JS_GetOpaque(argv[0], classId_Ozone_Brush);

        auto &__arg0 = *brush_instance;
        instance->SetBackground(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::SetBackgroundMode
static JSValue callback_method_Ozone_DC_SetBackgroundMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetBackgroundMode(int mode)
overload0:
    {
        int mode;
        if (JS_ToInt32(ctx, (int32_t*) &mode, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = mode;
        instance->SetBackgroundMode(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::GetBackgroundMode
static JSValue callback_method_Ozone_DC_GetBackgroundMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetBackgroundMode();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::DC::SetTextForeground
static JSValue callback_method_Ozone_DC_SetTextForeground(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetTextForeground(const ::Ozone::Color& colour)
overload0:
    {
        Ozone::Color* colour_instance = (Ozone::Color*) JS_GetOpaque(argv[0], classId_Ozone_Color);

        auto &__arg0 = *colour_instance;
        instance->SetTextForeground(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::SetTextBackground
static JSValue callback_method_Ozone_DC_SetTextBackground(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetTextBackground(const ::Ozone::Color& colour)
overload0:
    {
        Ozone::Color* colour_instance = (Ozone::Color*) JS_GetOpaque(argv[0], classId_Ozone_Color);

        auto &__arg0 = *colour_instance;
        instance->SetTextBackground(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::SetLogicalFunction
static JSValue callback_method_Ozone_DC_SetLogicalFunction(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetLogicalFunction(::Ozone::RasterOperationMode function)
overload0:
    {
        unsigned int function;
        if (JS_ToUint32(ctx, (uint32_t*) &function, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = (::Ozone::RasterOperationMode)function;
        instance->SetLogicalFunction(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::GetLogicalFunction
static JSValue callback_method_Ozone_DC_GetLogicalFunction(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    ::Ozone::RasterOperationMode __ret = instance->GetLogicalFunction();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::DC::GetCharHeight
static JSValue callback_method_Ozone_DC_GetCharHeight(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetCharHeight();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::DC::GetCharWidth
static JSValue callback_method_Ozone_DC_GetCharWidth(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetCharWidth();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::DC::GetFontMetrics
static JSValue callback_method_Ozone_DC_GetFontMetrics(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    ::Ozone::FontMetrics __ret = instance->GetFontMetrics();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::DC::GetMultiLineTextExtent
static JSValue callback_method_Ozone_DC_GetMultiLineTextExtent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsString(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Size GetMultiLineTextExtent(const char* string) const
overload0:
    {
        const char* string;
        string = JS_ToCString(ctx, argv[0]);
        if (!string)
            return JS_EXCEPTION;

        auto __arg0 = string;
        ::Ozone::Size __ret = instance->GetMultiLineTextExtent(__arg0);

        JS_FreeCString(ctx, string);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::DC::Clear
static JSValue callback_method_Ozone_DC_Clear(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    instance->Clear();

    return JS_UNDEFINED;
}

// Ozone::DC::SetClippingRegion
static JSValue callback_method_Ozone_DC_SetClippingRegion(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsObject(argv[0]))
        goto overload2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto overload1;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetClippingRegion(int x, int y, int width, int height)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        int width;
        if (JS_ToInt32(ctx, (int32_t*) &width, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = width;
        int height;
        if (JS_ToInt32(ctx, (int32_t*) &height, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = height;
        instance->SetClippingRegion(__arg0, __arg1, __arg2, __arg3);


        return JS_UNDEFINED;
    }

    // void SetClippingRegion(const ::Ozone::Point& pt, const ::Ozone::Size& sz)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        Ozone::Size* sz_instance = (Ozone::Size*) JS_GetOpaque(argv[1], classId_Ozone_Size);

        auto &__arg1 = *sz_instance;
        instance->SetClippingRegion(__arg0, __arg1);


        return JS_UNDEFINED;
    }

    // void SetClippingRegion(const ::Ozone::Rect& rect)
overload2:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        instance->SetClippingRegion(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DestroyClippingRegion
static JSValue callback_method_Ozone_DC_DestroyClippingRegion(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    instance->DestroyClippingRegion();

    return JS_UNDEFINED;
}

// Ozone::DC::GetClippingBox
static JSValue callback_method_Ozone_DC_GetClippingBox(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool GetClippingBox(::Ozone::Rect& rect) const
overload0:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        bool __ret = instance->GetClippingBox(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::DeviceToLogicalX
static JSValue callback_method_Ozone_DC_DeviceToLogicalX(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // int DeviceToLogicalX(int x) const
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int __ret = instance->DeviceToLogicalX(__arg0);

        JSValue ____ret = JS_NewInt32(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::DeviceToLogicalY
static JSValue callback_method_Ozone_DC_DeviceToLogicalY(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // int DeviceToLogicalY(int y) const
overload0:
    {
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = y;
        int __ret = instance->DeviceToLogicalY(__arg0);

        JSValue ____ret = JS_NewInt32(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::DeviceToLogicalXRel
static JSValue callback_method_Ozone_DC_DeviceToLogicalXRel(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // int DeviceToLogicalXRel(int x) const
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int __ret = instance->DeviceToLogicalXRel(__arg0);

        JSValue ____ret = JS_NewInt32(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::DeviceToLogicalYRel
static JSValue callback_method_Ozone_DC_DeviceToLogicalYRel(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // int DeviceToLogicalYRel(int y) const
overload0:
    {
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = y;
        int __ret = instance->DeviceToLogicalYRel(__arg0);

        JSValue ____ret = JS_NewInt32(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::DeviceToLogical
static JSValue callback_method_Ozone_DC_DeviceToLogical(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Point DeviceToLogical(const ::Ozone::Point& pt) const
overload0:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        ::Ozone::Point __ret = instance->DeviceToLogical(__arg0);


        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }

    // ::Ozone::Point DeviceToLogical(int x, int y) const
overload1:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        ::Ozone::Point __ret = instance->DeviceToLogical(__arg0, __arg1);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::DC::DeviceToLogicalRel
static JSValue callback_method_Ozone_DC_DeviceToLogicalRel(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Size DeviceToLogicalRel(const ::Ozone::Size& dim) const
overload0:
    {
        Ozone::Size* dim_instance = (Ozone::Size*) JS_GetOpaque(argv[0], classId_Ozone_Size);

        auto &__arg0 = *dim_instance;
        ::Ozone::Size __ret = instance->DeviceToLogicalRel(__arg0);


        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }

    // ::Ozone::Size DeviceToLogicalRel(int x, int y) const
overload1:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        ::Ozone::Size __ret = instance->DeviceToLogicalRel(__arg0, __arg1);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::DC::LogicalToDeviceX
static JSValue callback_method_Ozone_DC_LogicalToDeviceX(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // int LogicalToDeviceX(int x) const
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int __ret = instance->LogicalToDeviceX(__arg0);

        JSValue ____ret = JS_NewInt32(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::LogicalToDeviceY
static JSValue callback_method_Ozone_DC_LogicalToDeviceY(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // int LogicalToDeviceY(int y) const
overload0:
    {
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = y;
        int __ret = instance->LogicalToDeviceY(__arg0);

        JSValue ____ret = JS_NewInt32(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::LogicalToDeviceXRel
static JSValue callback_method_Ozone_DC_LogicalToDeviceXRel(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // int LogicalToDeviceXRel(int x) const
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int __ret = instance->LogicalToDeviceXRel(__arg0);

        JSValue ____ret = JS_NewInt32(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::LogicalToDeviceYRel
static JSValue callback_method_Ozone_DC_LogicalToDeviceYRel(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // int LogicalToDeviceYRel(int y) const
overload0:
    {
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = y;
        int __ret = instance->LogicalToDeviceYRel(__arg0);

        JSValue ____ret = JS_NewInt32(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::LogicalToDevice
static JSValue callback_method_Ozone_DC_LogicalToDevice(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Point LogicalToDevice(const ::Ozone::Point& pt) const
overload0:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        ::Ozone::Point __ret = instance->LogicalToDevice(__arg0);


        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }

    // ::Ozone::Point LogicalToDevice(int x, int y) const
overload1:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        ::Ozone::Point __ret = instance->LogicalToDevice(__arg0, __arg1);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::DC::LogicalToDeviceRel
static JSValue callback_method_Ozone_DC_LogicalToDeviceRel(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Size LogicalToDeviceRel(const ::Ozone::Size& dim) const
overload0:
    {
        Ozone::Size* dim_instance = (Ozone::Size*) JS_GetOpaque(argv[0], classId_Ozone_Size);

        auto &__arg0 = *dim_instance;
        ::Ozone::Size __ret = instance->LogicalToDeviceRel(__arg0);


        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }

    // ::Ozone::Size LogicalToDeviceRel(int x, int y) const
overload1:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        ::Ozone::Size __ret = instance->LogicalToDeviceRel(__arg0, __arg1);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::DC::SetMapMode
static JSValue callback_method_Ozone_DC_SetMapMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetMapMode(::Ozone::MappingMode mode)
overload0:
    {
        unsigned int mode;
        if (JS_ToUint32(ctx, (uint32_t*) &mode, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = (::Ozone::MappingMode)mode;
        instance->SetMapMode(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::GetMapMode
static JSValue callback_method_Ozone_DC_GetMapMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    ::Ozone::MappingMode __ret = instance->GetMapMode();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::DC::SetUserScale
static JSValue callback_method_Ozone_DC_SetUserScale(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetUserScale(double x, double y)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        instance->SetUserScale(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::SetLogicalScale
static JSValue callback_method_Ozone_DC_SetLogicalScale(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetLogicalScale(double x, double y)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        instance->SetLogicalScale(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::SetLogicalOrigin
static JSValue callback_method_Ozone_DC_SetLogicalOrigin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetLogicalOrigin(int x, int y)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        instance->SetLogicalOrigin(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::GetLogicalOrigin
static JSValue callback_method_Ozone_DC_GetLogicalOrigin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    ::Ozone::Point __ret = instance->GetLogicalOrigin();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::DC::SetDeviceOrigin
static JSValue callback_method_Ozone_DC_SetDeviceOrigin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetDeviceOrigin(int x, int y)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        instance->SetDeviceOrigin(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::GetDeviceOrigin
static JSValue callback_method_Ozone_DC_GetDeviceOrigin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    ::Ozone::Point __ret = instance->GetDeviceOrigin();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::DC::SetAxisOrientation
static JSValue callback_method_Ozone_DC_SetAxisOrientation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsBool(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetAxisOrientation(bool xLeftRight, bool yBottomUp)
overload0:
    {
        bool xLeftRight;
        xLeftRight = JS_ToBool(ctx, argv[0]);
        if (xLeftRight == -1)
            return JS_EXCEPTION;

        auto __arg0 = xLeftRight;
        bool yBottomUp;
        yBottomUp = JS_ToBool(ctx, argv[1]);
        if (yBottomUp == -1)
            return JS_EXCEPTION;

        auto __arg1 = yBottomUp;
        instance->SetAxisOrientation(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::CanUseTransformMatrix
static JSValue callback_method_Ozone_DC_CanUseTransformMatrix(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->CanUseTransformMatrix();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::DC::ResetTransformMatrix
static JSValue callback_method_Ozone_DC_ResetTransformMatrix(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    instance->ResetTransformMatrix();

    return JS_UNDEFINED;
}

// Ozone::DC::SetDeviceLocalOrigin
static JSValue callback_method_Ozone_DC_SetDeviceLocalOrigin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetDeviceLocalOrigin(int x, int y)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        instance->SetDeviceLocalOrigin(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::FloodFill
static JSValue callback_method_Ozone_DC_FloodFill(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto typecheck4;

    goto error;

typecheck3:
    if (JS_IsObject(argv[2]))
        goto typecheck5;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[2]))
        goto overload1;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool FloodFill(int x, int y, const ::Ozone::Color& col, ::Ozone::FloodFillStyle style)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        Ozone::Color* col_instance = (Ozone::Color*) JS_GetOpaque(argv[2], classId_Ozone_Color);

        auto &__arg2 = *col_instance;
        unsigned int style;
        if (JS_ToUint32(ctx, (uint32_t*) &style, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = (::Ozone::FloodFillStyle)style;
        bool __ret = instance->FloodFill(__arg0, __arg1, __arg2, __arg3);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool FloodFill(const ::Ozone::Point& pt, const ::Ozone::Color& col, ::Ozone::FloodFillStyle style)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        Ozone::Color* col_instance = (Ozone::Color*) JS_GetOpaque(argv[1], classId_Ozone_Color);

        auto &__arg1 = *col_instance;
        unsigned int style;
        if (JS_ToUint32(ctx, (uint32_t*) &style, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = (::Ozone::FloodFillStyle)style;
        bool __ret = instance->FloodFill(__arg0, __arg1, __arg2);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::GradientFillConcentric
static JSValue callback_method_Ozone_DC_GradientFillConcentric(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsObject(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void GradientFillConcentric(const ::Ozone::Rect& rect, const ::Ozone::Color& initialColour, const ::Ozone::Color& destColour)
overload0:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        Ozone::Color* initialColour_instance = (Ozone::Color*) JS_GetOpaque(argv[1], classId_Ozone_Color);

        auto &__arg1 = *initialColour_instance;
        Ozone::Color* destColour_instance = (Ozone::Color*) JS_GetOpaque(argv[2], classId_Ozone_Color);

        auto &__arg2 = *destColour_instance;
        instance->GradientFillConcentric(__arg0, __arg1, __arg2);


        return JS_UNDEFINED;
    }

    // void GradientFillConcentric(const ::Ozone::Rect& rect, const ::Ozone::Color& initialColour, const ::Ozone::Color& destColour, const ::Ozone::Point& circleCenter)
overload1:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        Ozone::Color* initialColour_instance = (Ozone::Color*) JS_GetOpaque(argv[1], classId_Ozone_Color);

        auto &__arg1 = *initialColour_instance;
        Ozone::Color* destColour_instance = (Ozone::Color*) JS_GetOpaque(argv[2], classId_Ozone_Color);

        auto &__arg2 = *destColour_instance;
        Ozone::Point* circleCenter_instance = (Ozone::Point*) JS_GetOpaque(argv[3], classId_Ozone_Point);

        auto &__arg3 = *circleCenter_instance;
        instance->GradientFillConcentric(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::GradientFillLinear
static JSValue callback_method_Ozone_DC_GradientFillLinear(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsObject(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void GradientFillLinear(const ::Ozone::Rect& rect, const ::Ozone::Color& initialColour, const ::Ozone::Color& destColour, ::Ozone::Direction nDirection)
overload0:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        Ozone::Color* initialColour_instance = (Ozone::Color*) JS_GetOpaque(argv[1], classId_Ozone_Color);

        auto &__arg1 = *initialColour_instance;
        Ozone::Color* destColour_instance = (Ozone::Color*) JS_GetOpaque(argv[2], classId_Ozone_Color);

        auto &__arg2 = *destColour_instance;
        unsigned int nDirection;
        if (JS_ToUint32(ctx, (uint32_t*) &nDirection, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = (::Ozone::Direction)nDirection;
        instance->GradientFillLinear(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::GetPixel
static JSValue callback_method_Ozone_DC_GetPixel(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto overload1;

    goto error;

typecheck3:
    if (JS_IsObject(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool GetPixel(int x, int y, ::Ozone::Color* col) const
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        Ozone::Color* col_instance = (Ozone::Color*) JS_GetOpaque(argv[2], classId_Ozone_Color);

        auto __arg2 = col_instance;
        bool __ret = instance->GetPixel(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool GetPixel(const ::Ozone::Point& pt, ::Ozone::Color* col) const
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        Ozone::Color* col_instance = (Ozone::Color*) JS_GetOpaque(argv[1], classId_Ozone_Color);

        auto __arg1 = col_instance;
        bool __ret = instance->GetPixel(__arg0, __arg1);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::DrawLine
static JSValue callback_method_Ozone_DC_DrawLine(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto overload1;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawLine(int x1, int y1, int x2, int y2)
overload0:
    {
        int x1;
        if (JS_ToInt32(ctx, (int32_t*) &x1, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x1;
        int y1;
        if (JS_ToInt32(ctx, (int32_t*) &y1, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y1;
        int x2;
        if (JS_ToInt32(ctx, (int32_t*) &x2, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = x2;
        int y2;
        if (JS_ToInt32(ctx, (int32_t*) &y2, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = y2;
        instance->DrawLine(__arg0, __arg1, __arg2, __arg3);


        return JS_UNDEFINED;
    }

    // void DrawLine(const ::Ozone::Point& pt1, const ::Ozone::Point& pt2)
overload1:
    {
        Ozone::Point* pt1_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt1_instance;
        Ozone::Point* pt2_instance = (Ozone::Point*) JS_GetOpaque(argv[1], classId_Ozone_Point);

        auto &__arg1 = *pt2_instance;
        instance->DrawLine(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::CrossHair
static JSValue callback_method_Ozone_DC_CrossHair(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto overload1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void CrossHair(int x, int y)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        instance->CrossHair(__arg0, __arg1);


        return JS_UNDEFINED;
    }

    // void CrossHair(const ::Ozone::Point& pt)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        instance->CrossHair(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawArc
static JSValue callback_method_Ozone_DC_DrawArc(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto typecheck4;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto typecheck5;

    goto error;

typecheck4:
    if (JS_IsObject(argv[2]))
        goto overload1;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[3]))
        goto typecheck6;

    goto error;

typecheck6:
    if (JS_IsNumber(argv[4]))
        goto typecheck7;

    goto error;

typecheck7:
    if (JS_IsNumber(argv[5]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawArc(int x1, int y1, int x2, int y2, int xc, int yc)
overload0:
    {
        int x1;
        if (JS_ToInt32(ctx, (int32_t*) &x1, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x1;
        int y1;
        if (JS_ToInt32(ctx, (int32_t*) &y1, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y1;
        int x2;
        if (JS_ToInt32(ctx, (int32_t*) &x2, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = x2;
        int y2;
        if (JS_ToInt32(ctx, (int32_t*) &y2, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = y2;
        int xc;
        if (JS_ToInt32(ctx, (int32_t*) &xc, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = xc;
        int yc;
        if (JS_ToInt32(ctx, (int32_t*) &yc, argv[5]))
            return JS_EXCEPTION;

        auto __arg5 = yc;
        instance->DrawArc(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);


        return JS_UNDEFINED;
    }

    // void DrawArc(const ::Ozone::Point& pt1, const ::Ozone::Point& pt2, const ::Ozone::Point& centre)
overload1:
    {
        Ozone::Point* pt1_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt1_instance;
        Ozone::Point* pt2_instance = (Ozone::Point*) JS_GetOpaque(argv[1], classId_Ozone_Point);

        auto &__arg1 = *pt2_instance;
        Ozone::Point* centre_instance = (Ozone::Point*) JS_GetOpaque(argv[2], classId_Ozone_Point);

        auto &__arg2 = *centre_instance;
        instance->DrawArc(__arg0, __arg1, __arg2);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawCheckMark
static JSValue callback_method_Ozone_DC_DrawCheckMark(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto overload1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawCheckMark(int x, int y, int width, int height)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        int width;
        if (JS_ToInt32(ctx, (int32_t*) &width, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = width;
        int height;
        if (JS_ToInt32(ctx, (int32_t*) &height, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = height;
        instance->DrawCheckMark(__arg0, __arg1, __arg2, __arg3);


        return JS_UNDEFINED;
    }

    // void DrawCheckMark(const ::Ozone::Rect& rect)
overload1:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        instance->DrawCheckMark(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawEllipticArc
static JSValue callback_method_Ozone_DC_DrawEllipticArc(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto typecheck4;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto typecheck5;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[2]))
        goto typecheck6;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[3]))
        goto typecheck7;

    goto error;

typecheck6:
    if (JS_IsNumber(argv[3]))
        goto overload1;

    goto error;

typecheck7:
    if (JS_IsNumber(argv[4]))
        goto typecheck8;

    goto error;

typecheck8:
    if (JS_IsNumber(argv[5]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawEllipticArc(int x, int y, int w, int h, double sa, double ea)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        int w;
        if (JS_ToInt32(ctx, (int32_t*) &w, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = w;
        int h;
        if (JS_ToInt32(ctx, (int32_t*) &h, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = h;
        double sa;
        if (JS_ToFloat64(ctx, &sa, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = sa;
        double ea;
        if (JS_ToFloat64(ctx, &ea, argv[5]))
            return JS_EXCEPTION;

        auto __arg5 = ea;
        instance->DrawEllipticArc(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);


        return JS_UNDEFINED;
    }

    // void DrawEllipticArc(const ::Ozone::Point& pt, const ::Ozone::Size& sz, double sa, double ea)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        Ozone::Size* sz_instance = (Ozone::Size*) JS_GetOpaque(argv[1], classId_Ozone_Size);

        auto &__arg1 = *sz_instance;
        double sa;
        if (JS_ToFloat64(ctx, &sa, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = sa;
        double ea;
        if (JS_ToFloat64(ctx, &ea, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = ea;
        instance->DrawEllipticArc(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawPoint
static JSValue callback_method_Ozone_DC_DrawPoint(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto overload1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawPoint(int x, int y)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        instance->DrawPoint(__arg0, __arg1);


        return JS_UNDEFINED;
    }

    // void DrawPoint(const ::Ozone::Point& pt)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        instance->DrawPoint(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawLines
static JSValue callback_method_Ozone_DC_DrawLines(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsArray(ctx, argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawLines(int n, ::Ozone::Point points[], int xoffset, int yoffset)
overload0:
    {
        int n;
        if (JS_ToInt32(ctx, (int32_t*) &n, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = n;
        auto __arg1 = nullptr;
        int xoffset;
        if (JS_ToInt32(ctx, (int32_t*) &xoffset, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = xoffset;
        int yoffset;
        if (JS_ToInt32(ctx, (int32_t*) &yoffset, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = yoffset;
        instance->DrawLines(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawPolygon
static JSValue callback_method_Ozone_DC_DrawPolygon(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 5 || argc > 5)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsArray(ctx, argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawPolygon(int n, ::Ozone::Point points[], int xoffset, int yoffset, ::Ozone::PolygonFillMode fillStyle)
overload0:
    {
        int n;
        if (JS_ToInt32(ctx, (int32_t*) &n, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = n;
        auto __arg1 = nullptr;
        int xoffset;
        if (JS_ToInt32(ctx, (int32_t*) &xoffset, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = xoffset;
        int yoffset;
        if (JS_ToInt32(ctx, (int32_t*) &yoffset, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = yoffset;
        unsigned int fillStyle;
        if (JS_ToUint32(ctx, (uint32_t*) &fillStyle, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = (::Ozone::PolygonFillMode)fillStyle;
        instance->DrawPolygon(__arg0, __arg1, __arg2, __arg3, __arg4);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawPolyPolygon
static JSValue callback_method_Ozone_DC_DrawPolyPolygon(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 6 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsArray(ctx, argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsArray(ctx, argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[5]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawPolyPolygon(int n, int count[], ::Ozone::Point points[], int xoffset, int yoffset, ::Ozone::PolygonFillMode fillStyle)
overload0:
    {
        int n;
        if (JS_ToInt32(ctx, (int32_t*) &n, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = n;
        auto __arg1 = nullptr;
        auto __arg2 = nullptr;
        int xoffset;
        if (JS_ToInt32(ctx, (int32_t*) &xoffset, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = xoffset;
        int yoffset;
        if (JS_ToInt32(ctx, (int32_t*) &yoffset, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = yoffset;
        unsigned int fillStyle;
        if (JS_ToUint32(ctx, (uint32_t*) &fillStyle, argv[5]))
            return JS_EXCEPTION;

        auto __arg5 = (::Ozone::PolygonFillMode)fillStyle;
        instance->DrawPolyPolygon(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawRectangle
static JSValue callback_method_Ozone_DC_DrawRectangle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsObject(argv[0]))
        goto overload2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto overload1;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawRectangle(int x, int y, int width, int height)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        int width;
        if (JS_ToInt32(ctx, (int32_t*) &width, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = width;
        int height;
        if (JS_ToInt32(ctx, (int32_t*) &height, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = height;
        instance->DrawRectangle(__arg0, __arg1, __arg2, __arg3);


        return JS_UNDEFINED;
    }

    // void DrawRectangle(const ::Ozone::Point& pt, const ::Ozone::Size& sz)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        Ozone::Size* sz_instance = (Ozone::Size*) JS_GetOpaque(argv[1], classId_Ozone_Size);

        auto &__arg1 = *sz_instance;
        instance->DrawRectangle(__arg0, __arg1);


        return JS_UNDEFINED;
    }

    // void DrawRectangle(const ::Ozone::Rect& rect)
overload2:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        instance->DrawRectangle(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawRoundedRectangle
static JSValue callback_method_Ozone_DC_DrawRoundedRectangle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 5)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsObject(argv[0]))
        goto typecheck3;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck4;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto typecheck5;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[1]))
        goto overload2;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[2]))
        goto typecheck6;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[2]))
        goto overload1;

    goto error;

typecheck6:
    if (JS_IsNumber(argv[3]))
        goto typecheck7;

    goto error;

typecheck7:
    if (JS_IsNumber(argv[4]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawRoundedRectangle(int x, int y, int width, int height, double radius)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        int width;
        if (JS_ToInt32(ctx, (int32_t*) &width, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = width;
        int height;
        if (JS_ToInt32(ctx, (int32_t*) &height, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = height;
        double radius;
        if (JS_ToFloat64(ctx, &radius, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = radius;
        instance->DrawRoundedRectangle(__arg0, __arg1, __arg2, __arg3, __arg4);


        return JS_UNDEFINED;
    }

    // void DrawRoundedRectangle(const ::Ozone::Point& pt, const ::Ozone::Size& sz, double radius)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        Ozone::Size* sz_instance = (Ozone::Size*) JS_GetOpaque(argv[1], classId_Ozone_Size);

        auto &__arg1 = *sz_instance;
        double radius;
        if (JS_ToFloat64(ctx, &radius, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = radius;
        instance->DrawRoundedRectangle(__arg0, __arg1, __arg2);


        return JS_UNDEFINED;
    }

    // void DrawRoundedRectangle(const ::Ozone::Rect& r, double radius)
overload2:
    {
        Ozone::Rect* r_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *r_instance;
        double radius;
        if (JS_ToFloat64(ctx, &radius, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = radius;
        instance->DrawRoundedRectangle(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawCircle
static JSValue callback_method_Ozone_DC_DrawCircle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[1]))
        goto overload1;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawCircle(int x, int y, int radius)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        int radius;
        if (JS_ToInt32(ctx, (int32_t*) &radius, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = radius;
        instance->DrawCircle(__arg0, __arg1, __arg2);


        return JS_UNDEFINED;
    }

    // void DrawCircle(const ::Ozone::Point& pt, int radius)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        int radius;
        if (JS_ToInt32(ctx, (int32_t*) &radius, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = radius;
        instance->DrawCircle(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawEllipse
static JSValue callback_method_Ozone_DC_DrawEllipse(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsObject(argv[0]))
        goto overload2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto overload1;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawEllipse(int x, int y, int width, int height)
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        int width;
        if (JS_ToInt32(ctx, (int32_t*) &width, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = width;
        int height;
        if (JS_ToInt32(ctx, (int32_t*) &height, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = height;
        instance->DrawEllipse(__arg0, __arg1, __arg2, __arg3);


        return JS_UNDEFINED;
    }

    // void DrawEllipse(const ::Ozone::Point& pt, const ::Ozone::Size& sz)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        Ozone::Size* sz_instance = (Ozone::Size*) JS_GetOpaque(argv[1], classId_Ozone_Size);

        auto &__arg1 = *sz_instance;
        instance->DrawEllipse(__arg0, __arg1);


        return JS_UNDEFINED;
    }

    // void DrawEllipse(const ::Ozone::Rect& rect)
overload2:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        instance->DrawEllipse(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawText
static JSValue callback_method_Ozone_DC_DrawText(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsString(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    if (JS_IsObject(argv[1]))
        goto overload1;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawText(const char* text, int x, int y)
overload0:
    {
        const char* text;
        text = JS_ToCString(ctx, argv[0]);
        if (!text)
            return JS_EXCEPTION;

        auto __arg0 = text;
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = y;
        instance->DrawText(__arg0, __arg1, __arg2);

        JS_FreeCString(ctx, text);


        return JS_UNDEFINED;
    }

    // void DrawText(const char* text, const ::Ozone::Point& pt)
overload1:
    {
        const char* text;
        text = JS_ToCString(ctx, argv[0]);
        if (!text)
            return JS_EXCEPTION;

        auto __arg0 = text;
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[1], classId_Ozone_Point);

        auto &__arg1 = *pt_instance;
        instance->DrawText(__arg0, __arg1);

        JS_FreeCString(ctx, text);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawRotatedText
static JSValue callback_method_Ozone_DC_DrawRotatedText(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsString(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    if (JS_IsObject(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck4;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto overload1;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawRotatedText(const char* text, int x, int y, double angle)
overload0:
    {
        const char* text;
        text = JS_ToCString(ctx, argv[0]);
        if (!text)
            return JS_EXCEPTION;

        auto __arg0 = text;
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = y;
        double angle;
        if (JS_ToFloat64(ctx, &angle, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = angle;
        instance->DrawRotatedText(__arg0, __arg1, __arg2, __arg3);

        JS_FreeCString(ctx, text);


        return JS_UNDEFINED;
    }

    // void DrawRotatedText(const char* text, const ::Ozone::Point& pt, double angle)
overload1:
    {
        const char* text;
        text = JS_ToCString(ctx, argv[0]);
        if (!text)
            return JS_EXCEPTION;

        auto __arg0 = text;
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[1], classId_Ozone_Point);

        auto &__arg1 = *pt_instance;
        double angle;
        if (JS_ToFloat64(ctx, &angle, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = angle;
        instance->DrawRotatedText(__arg0, __arg1, __arg2);

        JS_FreeCString(ctx, text);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::DrawLabel
static JSValue callback_method_Ozone_DC_DrawLabel(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsString(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawLabel(const char* text, const ::Ozone::Rect& rect, int alignment, int indexAccel)
overload0:
    {
        const char* text;
        text = JS_ToCString(ctx, argv[0]);
        if (!text)
            return JS_EXCEPTION;

        auto __arg0 = text;
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[1], classId_Ozone_Rect);

        auto &__arg1 = *rect_instance;
        int alignment;
        if (JS_ToInt32(ctx, (int32_t*) &alignment, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = alignment;
        int indexAccel;
        if (JS_ToInt32(ctx, (int32_t*) &indexAccel, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = indexAccel;
        instance->DrawLabel(__arg0, __arg1, __arg2, __arg3);

        JS_FreeCString(ctx, text);

        return JS_UNDEFINED;
    }
}

// Ozone::DC::Blit
static JSValue callback_method_Ozone_DC_Blit(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 7 || argc > 11)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto typecheck4;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto typecheck5;

    goto error;

typecheck4:
    if (JS_IsObject(argv[2]))
        goto typecheck6;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[3]))
        goto typecheck7;

    goto error;

typecheck6:
    if (JS_IsObject(argv[3]))
        goto typecheck8;

    goto error;

typecheck7:
    if (JS_IsObject(argv[4]))
        goto typecheck9;

    goto error;

typecheck8:
    if (JS_IsNumber(argv[4]))
        goto typecheck10;

    goto error;

typecheck9:
    if (JS_IsNumber(argv[5]))
        goto typecheck11;

    goto error;

typecheck10:
    if (JS_IsBool(argv[5]))
        goto typecheck12;

    goto error;

typecheck11:
    if (JS_IsNumber(argv[6]))
        goto typecheck13;

    goto error;

typecheck12:
    if (JS_IsObject(argv[6]))
        goto overload1;

    goto error;

typecheck13:
    if (JS_IsNumber(argv[7]))
        goto typecheck14;

    goto error;

typecheck14:
    if (JS_IsBool(argv[8]))
        goto typecheck15;

    goto error;

typecheck15:
    if (JS_IsNumber(argv[9]))
        goto typecheck16;

    goto error;

typecheck16:
    if (JS_IsNumber(argv[10]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Blit(int xdest, int ydest, int width, int height, ::Ozone::DC* source, int xsrc, int ysrc, ::Ozone::RasterOperationMode rop, bool useMask, int xsrcMask, int ysrcMask)
overload0:
    {
        int xdest;
        if (JS_ToInt32(ctx, (int32_t*) &xdest, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = xdest;
        int ydest;
        if (JS_ToInt32(ctx, (int32_t*) &ydest, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = ydest;
        int width;
        if (JS_ToInt32(ctx, (int32_t*) &width, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = width;
        int height;
        if (JS_ToInt32(ctx, (int32_t*) &height, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = height;
        Ozone::DC* source_instance = (Ozone::DC*) JS_GetOpaque(argv[4], classId_Ozone_DC);

        auto __arg4 = source_instance;
        int xsrc;
        if (JS_ToInt32(ctx, (int32_t*) &xsrc, argv[5]))
            return JS_EXCEPTION;

        auto __arg5 = xsrc;
        int ysrc;
        if (JS_ToInt32(ctx, (int32_t*) &ysrc, argv[6]))
            return JS_EXCEPTION;

        auto __arg6 = ysrc;
        unsigned int rop;
        if (JS_ToUint32(ctx, (uint32_t*) &rop, argv[7]))
            return JS_EXCEPTION;

        auto __arg7 = (::Ozone::RasterOperationMode)rop;
        bool useMask;
        useMask = JS_ToBool(ctx, argv[8]);
        if (useMask == -1)
            return JS_EXCEPTION;

        auto __arg8 = useMask;
        int xsrcMask;
        if (JS_ToInt32(ctx, (int32_t*) &xsrcMask, argv[9]))
            return JS_EXCEPTION;

        auto __arg9 = xsrcMask;
        int ysrcMask;
        if (JS_ToInt32(ctx, (int32_t*) &ysrcMask, argv[10]))
            return JS_EXCEPTION;

        auto __arg10 = ysrcMask;
        bool __ret = instance->Blit(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7, __arg8, __arg9, __arg10);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Blit(const ::Ozone::Point& destPt, const ::Ozone::Size& sz, ::Ozone::DC* source, const ::Ozone::Point& srcPt, ::Ozone::RasterOperationMode rop, bool useMask, const ::Ozone::Point& srcPtMask)
overload1:
    {
        Ozone::Point* destPt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *destPt_instance;
        Ozone::Size* sz_instance = (Ozone::Size*) JS_GetOpaque(argv[1], classId_Ozone_Size);

        auto &__arg1 = *sz_instance;
        Ozone::DC* source_instance = (Ozone::DC*) JS_GetOpaque(argv[2], classId_Ozone_DC);

        auto __arg2 = source_instance;
        Ozone::Point* srcPt_instance = (Ozone::Point*) JS_GetOpaque(argv[3], classId_Ozone_Point);

        auto &__arg3 = *srcPt_instance;
        unsigned int rop;
        if (JS_ToUint32(ctx, (uint32_t*) &rop, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = (::Ozone::RasterOperationMode)rop;
        bool useMask;
        useMask = JS_ToBool(ctx, argv[5]);
        if (useMask == -1)
            return JS_EXCEPTION;

        auto __arg5 = useMask;
        Ozone::Point* srcPtMask_instance = (Ozone::Point*) JS_GetOpaque(argv[6], classId_Ozone_Point);

        auto &__arg6 = *srcPtMask_instance;
        bool __ret = instance->Blit(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::StretchBlit
static JSValue callback_method_Ozone_DC_StretchBlit(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 8 || argc > 13)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto typecheck4;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto typecheck5;

    goto error;

typecheck4:
    if (JS_IsObject(argv[2]))
        goto typecheck6;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[3]))
        goto typecheck7;

    goto error;

typecheck6:
    if (JS_IsObject(argv[3]))
        goto typecheck8;

    goto error;

typecheck7:
    if (JS_IsObject(argv[4]))
        goto typecheck9;

    goto error;

typecheck8:
    if (JS_IsObject(argv[4]))
        goto typecheck10;

    goto error;

typecheck9:
    if (JS_IsNumber(argv[5]))
        goto typecheck11;

    goto error;

typecheck10:
    if (JS_IsNumber(argv[5]))
        goto typecheck12;

    goto error;

typecheck11:
    if (JS_IsNumber(argv[6]))
        goto typecheck13;

    goto error;

typecheck12:
    if (JS_IsBool(argv[6]))
        goto typecheck14;

    goto error;

typecheck13:
    if (JS_IsNumber(argv[7]))
        goto typecheck15;

    goto error;

typecheck14:
    if (JS_IsObject(argv[7]))
        goto overload1;

    goto error;

typecheck15:
    if (JS_IsNumber(argv[8]))
        goto typecheck16;

    goto error;

typecheck16:
    if (JS_IsNumber(argv[9]))
        goto typecheck17;

    goto error;

typecheck17:
    if (JS_IsBool(argv[10]))
        goto typecheck18;

    goto error;

typecheck18:
    if (JS_IsNumber(argv[11]))
        goto typecheck19;

    goto error;

typecheck19:
    if (JS_IsNumber(argv[12]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool StretchBlit(int dstX, int dstY, int dstWidth, int dstHeight, ::Ozone::DC* source, int srcX, int srcY, int srcWidth, int srcHeight, ::Ozone::RasterOperationMode rop, bool useMask, int srcMaskX, int srcMaskY)
overload0:
    {
        int dstX;
        if (JS_ToInt32(ctx, (int32_t*) &dstX, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = dstX;
        int dstY;
        if (JS_ToInt32(ctx, (int32_t*) &dstY, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = dstY;
        int dstWidth;
        if (JS_ToInt32(ctx, (int32_t*) &dstWidth, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = dstWidth;
        int dstHeight;
        if (JS_ToInt32(ctx, (int32_t*) &dstHeight, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = dstHeight;
        Ozone::DC* source_instance = (Ozone::DC*) JS_GetOpaque(argv[4], classId_Ozone_DC);

        auto __arg4 = source_instance;
        int srcX;
        if (JS_ToInt32(ctx, (int32_t*) &srcX, argv[5]))
            return JS_EXCEPTION;

        auto __arg5 = srcX;
        int srcY;
        if (JS_ToInt32(ctx, (int32_t*) &srcY, argv[6]))
            return JS_EXCEPTION;

        auto __arg6 = srcY;
        int srcWidth;
        if (JS_ToInt32(ctx, (int32_t*) &srcWidth, argv[7]))
            return JS_EXCEPTION;

        auto __arg7 = srcWidth;
        int srcHeight;
        if (JS_ToInt32(ctx, (int32_t*) &srcHeight, argv[8]))
            return JS_EXCEPTION;

        auto __arg8 = srcHeight;
        unsigned int rop;
        if (JS_ToUint32(ctx, (uint32_t*) &rop, argv[9]))
            return JS_EXCEPTION;

        auto __arg9 = (::Ozone::RasterOperationMode)rop;
        bool useMask;
        useMask = JS_ToBool(ctx, argv[10]);
        if (useMask == -1)
            return JS_EXCEPTION;

        auto __arg10 = useMask;
        int srcMaskX;
        if (JS_ToInt32(ctx, (int32_t*) &srcMaskX, argv[11]))
            return JS_EXCEPTION;

        auto __arg11 = srcMaskX;
        int srcMaskY;
        if (JS_ToInt32(ctx, (int32_t*) &srcMaskY, argv[12]))
            return JS_EXCEPTION;

        auto __arg12 = srcMaskY;
        bool __ret = instance->StretchBlit(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7, __arg8, __arg9, __arg10, __arg11, __arg12);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool StretchBlit(const ::Ozone::Point& dstPt, const ::Ozone::Size& dstSize, ::Ozone::DC* source, const ::Ozone::Point& srcPt, const ::Ozone::Size& srcSize, ::Ozone::RasterOperationMode rop, bool useMask, const ::Ozone::Point& srcMaskPt)
overload1:
    {
        Ozone::Point* dstPt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *dstPt_instance;
        Ozone::Size* dstSize_instance = (Ozone::Size*) JS_GetOpaque(argv[1], classId_Ozone_Size);

        auto &__arg1 = *dstSize_instance;
        Ozone::DC* source_instance = (Ozone::DC*) JS_GetOpaque(argv[2], classId_Ozone_DC);

        auto __arg2 = source_instance;
        Ozone::Point* srcPt_instance = (Ozone::Point*) JS_GetOpaque(argv[3], classId_Ozone_Point);

        auto &__arg3 = *srcPt_instance;
        Ozone::Size* srcSize_instance = (Ozone::Size*) JS_GetOpaque(argv[4], classId_Ozone_Size);

        auto &__arg4 = *srcSize_instance;
        unsigned int rop;
        if (JS_ToUint32(ctx, (uint32_t*) &rop, argv[5]))
            return JS_EXCEPTION;

        auto __arg5 = (::Ozone::RasterOperationMode)rop;
        bool useMask;
        useMask = JS_ToBool(ctx, argv[6]);
        if (useMask == -1)
            return JS_EXCEPTION;

        auto __arg6 = useMask;
        Ozone::Point* srcMaskPt_instance = (Ozone::Point*) JS_GetOpaque(argv[7], classId_Ozone_Point);

        auto &__arg7 = *srcMaskPt_instance;
        bool __ret = instance->StretchBlit(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::DC::DrawSpline
static JSValue callback_method_Ozone_DC_DrawSpline(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    if (JS_IsArray(ctx, argv[1]))
        goto overload1;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[5]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawSpline(int x1, int y1, int x2, int y2, int x3, int y3)
overload0:
    {
        int x1;
        if (JS_ToInt32(ctx, (int32_t*) &x1, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x1;
        int y1;
        if (JS_ToInt32(ctx, (int32_t*) &y1, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y1;
        int x2;
        if (JS_ToInt32(ctx, (int32_t*) &x2, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = x2;
        int y2;
        if (JS_ToInt32(ctx, (int32_t*) &y2, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = y2;
        int x3;
        if (JS_ToInt32(ctx, (int32_t*) &x3, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = x3;
        int y3;
        if (JS_ToInt32(ctx, (int32_t*) &y3, argv[5]))
            return JS_EXCEPTION;

        auto __arg5 = y3;
        instance->DrawSpline(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);


        return JS_UNDEFINED;
    }

    // void DrawSpline(int n, ::Ozone::Point points[])
overload1:
    {
        int n;
        if (JS_ToInt32(ctx, (int32_t*) &n, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = n;
        auto __arg1 = nullptr;
        instance->DrawSpline(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

static JSValue callback_class_Ozone_DC_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "DC");
}

void finalizer_Ozone_DC(JSRuntime *rt, JSValue val)
{
    Ozone::DC* instance = (Ozone::DC*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_DC
{
    "DC",
    .finalizer = finalizer_Ozone_DC
};

static JSCFunctionListEntry funcDef_Ozone_DC[]
{
    JS_CFUNC_DEF("GetResolution", 0, callback_method_Ozone_DC_GetResolution),
    JS_CFUNC_DEF("GetGraphicsContext", 0, callback_method_Ozone_DC_GetGraphicsContext),
    JS_CFUNC_DEF("SetGraphicsContext", 1, callback_method_Ozone_DC_SetGraphicsContext),
    JS_CFUNC_DEF("CopyAttributes", 1, callback_method_Ozone_DC_CopyAttributes),
    JS_CFUNC_DEF("GetWindow", 0, callback_method_Ozone_DC_GetWindow),
    JS_CFUNC_DEF("IsOk", 0, callback_method_Ozone_DC_IsOk),
    JS_CFUNC_DEF("CanDrawBitmap", 0, callback_method_Ozone_DC_CanDrawBitmap),
    JS_CFUNC_DEF("CanGetTextExtent", 0, callback_method_Ozone_DC_CanGetTextExtent),
    JS_CFUNC_DEF("GetSize", 0, callback_method_Ozone_DC_GetSize),
    JS_CFUNC_DEF("GetSizeMM", 0, callback_method_Ozone_DC_GetSizeMM),
    JS_CFUNC_DEF("GetDepth", 0, callback_method_Ozone_DC_GetDepth),
    JS_CFUNC_DEF("GetPPI", 0, callback_method_Ozone_DC_GetPPI),
    JS_CFUNC_DEF("GetContentScaleFactor", 0, callback_method_Ozone_DC_GetContentScaleFactor),
    JS_CFUNC_DEF("StartDoc", 1, callback_method_Ozone_DC_StartDoc),
    JS_CFUNC_DEF("EndDoc", 0, callback_method_Ozone_DC_EndDoc),
    JS_CFUNC_DEF("StartPage", 0, callback_method_Ozone_DC_StartPage),
    JS_CFUNC_DEF("EndPage", 0, callback_method_Ozone_DC_EndPage),
    JS_CFUNC_DEF("CalcBoundingBox", 2, callback_method_Ozone_DC_CalcBoundingBox),
    JS_CFUNC_DEF("ResetBoundingBox", 0, callback_method_Ozone_DC_ResetBoundingBox),
    JS_CFUNC_DEF("MinX", 0, callback_method_Ozone_DC_MinX),
    JS_CFUNC_DEF("MaxX", 0, callback_method_Ozone_DC_MaxX),
    JS_CFUNC_DEF("MinY", 0, callback_method_Ozone_DC_MinY),
    JS_CFUNC_DEF("MaxY", 0, callback_method_Ozone_DC_MaxY),
    JS_CFUNC_DEF("SetPen", 1, callback_method_Ozone_DC_SetPen),
    JS_CFUNC_DEF("SetBrush", 1, callback_method_Ozone_DC_SetBrush),
    JS_CFUNC_DEF("SetBackground", 1, callback_method_Ozone_DC_SetBackground),
    JS_CFUNC_DEF("SetBackgroundMode", 1, callback_method_Ozone_DC_SetBackgroundMode),
    JS_CFUNC_DEF("GetBackgroundMode", 0, callback_method_Ozone_DC_GetBackgroundMode),
    JS_CFUNC_DEF("SetTextForeground", 1, callback_method_Ozone_DC_SetTextForeground),
    JS_CFUNC_DEF("SetTextBackground", 1, callback_method_Ozone_DC_SetTextBackground),
    JS_CFUNC_DEF("SetLogicalFunction", 1, callback_method_Ozone_DC_SetLogicalFunction),
    JS_CFUNC_DEF("GetLogicalFunction", 0, callback_method_Ozone_DC_GetLogicalFunction),
    JS_CFUNC_DEF("GetCharHeight", 0, callback_method_Ozone_DC_GetCharHeight),
    JS_CFUNC_DEF("GetCharWidth", 0, callback_method_Ozone_DC_GetCharWidth),
    JS_CFUNC_DEF("GetFontMetrics", 0, callback_method_Ozone_DC_GetFontMetrics),
    JS_CFUNC_DEF("GetMultiLineTextExtent", 1, callback_method_Ozone_DC_GetMultiLineTextExtent),
    JS_CFUNC_DEF("Clear", 0, callback_method_Ozone_DC_Clear),
    JS_CFUNC_DEF("SetClippingRegion", 4, callback_method_Ozone_DC_SetClippingRegion),
    JS_CFUNC_DEF("DestroyClippingRegion", 0, callback_method_Ozone_DC_DestroyClippingRegion),
    JS_CFUNC_DEF("GetClippingBox", 1, callback_method_Ozone_DC_GetClippingBox),
    JS_CFUNC_DEF("DeviceToLogicalX", 1, callback_method_Ozone_DC_DeviceToLogicalX),
    JS_CFUNC_DEF("DeviceToLogicalY", 1, callback_method_Ozone_DC_DeviceToLogicalY),
    JS_CFUNC_DEF("DeviceToLogicalXRel", 1, callback_method_Ozone_DC_DeviceToLogicalXRel),
    JS_CFUNC_DEF("DeviceToLogicalYRel", 1, callback_method_Ozone_DC_DeviceToLogicalYRel),
    JS_CFUNC_DEF("DeviceToLogical", 2, callback_method_Ozone_DC_DeviceToLogical),
    JS_CFUNC_DEF("DeviceToLogicalRel", 2, callback_method_Ozone_DC_DeviceToLogicalRel),
    JS_CFUNC_DEF("LogicalToDeviceX", 1, callback_method_Ozone_DC_LogicalToDeviceX),
    JS_CFUNC_DEF("LogicalToDeviceY", 1, callback_method_Ozone_DC_LogicalToDeviceY),
    JS_CFUNC_DEF("LogicalToDeviceXRel", 1, callback_method_Ozone_DC_LogicalToDeviceXRel),
    JS_CFUNC_DEF("LogicalToDeviceYRel", 1, callback_method_Ozone_DC_LogicalToDeviceYRel),
    JS_CFUNC_DEF("LogicalToDevice", 2, callback_method_Ozone_DC_LogicalToDevice),
    JS_CFUNC_DEF("LogicalToDeviceRel", 2, callback_method_Ozone_DC_LogicalToDeviceRel),
    JS_CFUNC_DEF("SetMapMode", 1, callback_method_Ozone_DC_SetMapMode),
    JS_CFUNC_DEF("GetMapMode", 0, callback_method_Ozone_DC_GetMapMode),
    JS_CFUNC_DEF("SetUserScale", 2, callback_method_Ozone_DC_SetUserScale),
    JS_CFUNC_DEF("SetLogicalScale", 2, callback_method_Ozone_DC_SetLogicalScale),
    JS_CFUNC_DEF("SetLogicalOrigin", 2, callback_method_Ozone_DC_SetLogicalOrigin),
    JS_CFUNC_DEF("GetLogicalOrigin", 0, callback_method_Ozone_DC_GetLogicalOrigin),
    JS_CFUNC_DEF("SetDeviceOrigin", 2, callback_method_Ozone_DC_SetDeviceOrigin),
    JS_CFUNC_DEF("GetDeviceOrigin", 0, callback_method_Ozone_DC_GetDeviceOrigin),
    JS_CFUNC_DEF("SetAxisOrientation", 2, callback_method_Ozone_DC_SetAxisOrientation),
    JS_CFUNC_DEF("CanUseTransformMatrix", 0, callback_method_Ozone_DC_CanUseTransformMatrix),
    JS_CFUNC_DEF("ResetTransformMatrix", 0, callback_method_Ozone_DC_ResetTransformMatrix),
    JS_CFUNC_DEF("SetDeviceLocalOrigin", 2, callback_method_Ozone_DC_SetDeviceLocalOrigin),
    JS_CFUNC_DEF("FloodFill", 4, callback_method_Ozone_DC_FloodFill),
    JS_CFUNC_DEF("GradientFillConcentric", 4, callback_method_Ozone_DC_GradientFillConcentric),
    JS_CFUNC_DEF("GradientFillLinear", 4, callback_method_Ozone_DC_GradientFillLinear),
    JS_CFUNC_DEF("GetPixel", 3, callback_method_Ozone_DC_GetPixel),
    JS_CFUNC_DEF("DrawLine", 4, callback_method_Ozone_DC_DrawLine),
    JS_CFUNC_DEF("CrossHair", 2, callback_method_Ozone_DC_CrossHair),
    JS_CFUNC_DEF("DrawArc", 6, callback_method_Ozone_DC_DrawArc),
    JS_CFUNC_DEF("DrawCheckMark", 4, callback_method_Ozone_DC_DrawCheckMark),
    JS_CFUNC_DEF("DrawEllipticArc", 6, callback_method_Ozone_DC_DrawEllipticArc),
    JS_CFUNC_DEF("DrawPoint", 2, callback_method_Ozone_DC_DrawPoint),
    JS_CFUNC_DEF("DrawLines", 4, callback_method_Ozone_DC_DrawLines),
    JS_CFUNC_DEF("DrawPolygon", 5, callback_method_Ozone_DC_DrawPolygon),
    JS_CFUNC_DEF("DrawPolyPolygon", 6, callback_method_Ozone_DC_DrawPolyPolygon),
    JS_CFUNC_DEF("DrawRectangle", 4, callback_method_Ozone_DC_DrawRectangle),
    JS_CFUNC_DEF("DrawRoundedRectangle", 5, callback_method_Ozone_DC_DrawRoundedRectangle),
    JS_CFUNC_DEF("DrawCircle", 3, callback_method_Ozone_DC_DrawCircle),
    JS_CFUNC_DEF("DrawEllipse", 4, callback_method_Ozone_DC_DrawEllipse),
    JS_CFUNC_DEF("DrawText", 3, callback_method_Ozone_DC_DrawText),
    JS_CFUNC_DEF("DrawRotatedText", 4, callback_method_Ozone_DC_DrawRotatedText),
    JS_CFUNC_DEF("DrawLabel", 4, callback_method_Ozone_DC_DrawLabel),
    JS_CFUNC_DEF("Blit", 11, callback_method_Ozone_DC_Blit),
    JS_CFUNC_DEF("StretchBlit", 13, callback_method_Ozone_DC_StretchBlit),
    JS_CFUNC_DEF("DrawSpline", 6, callback_method_Ozone_DC_DrawSpline),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_DC_toString),
};

static void register_class_Ozone_DC(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "DC");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_DC);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_DC, &classDef_Ozone_DC);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_DC, sizeof(funcDef_Ozone_DC) / sizeof(funcDef_Ozone_DC[0]));
        JS_SetClassProto(ctx, classId_Ozone_DC, proto);

    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_DC);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Object);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

void register_ozone_dc(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (phase == 0)
    {
        register_enum_Ozone_RasterOperationMode(ctx, m, set);

        register_enum_Ozone_MappingMode(ctx, m, set);

        register_enum_Ozone_FloodFillStyle(ctx, m, set);
    }

    register_class_Ozone_FontMetrics(ctx, m, set, phase);

    register_class_Ozone_DC(ctx, m, set, phase);
}

} // extern "C"
