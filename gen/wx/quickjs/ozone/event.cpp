// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <CppSharp_QuickJS.h>
#include <assert.h>
#include <ozone/event.h>

extern "C" {

extern JSClassID classId_Ozone_EventTypeTag;
extern JSClassID classId_Ozone_Event;
extern JSClassID classId_Ozone_Object;
extern JSClassID classId_Ozone_EvtHandler;
extern JSClassID classId_Ozone_PropagateOnce;
extern JSClassID classId_Ozone_IdleEvent;
extern JSClassID classId_Ozone_ThreadEvent;
extern JSClassID classId_Ozone_AsyncMethodCallEvent;
extern JSClassID classId_Ozone_CommandEvent;
extern JSClassID classId_Ozone_NotifyEvent;
extern JSClassID classId_Ozone_ScrollEvent;
extern JSClassID classId_Ozone_ScrollWinEvent;
extern JSClassID classId_Ozone_MouseEvent;
extern JSClassID classId_Ozone_Point;
extern JSClassID classId_Ozone_DC;
extern JSClassID classId_Ozone_SetCursorEvent;
extern JSClassID classId_Ozone_GestureEvent;
extern JSClassID classId_Ozone_PanGestureEvent;
extern JSClassID classId_Ozone_ZoomGestureEvent;
extern JSClassID classId_Ozone_RotateGestureEvent;
extern JSClassID classId_Ozone_TwoFingerTapEvent;
extern JSClassID classId_Ozone_LongPressEvent;
extern JSClassID classId_Ozone_PressAndTapEvent;
extern JSClassID classId_Ozone_KeyEvent;
extern JSClassID classId_Ozone_SizeEvent;
extern JSClassID classId_Ozone_Size;
extern JSClassID classId_Ozone_Rect;
extern JSClassID classId_Ozone_MoveEvent;
extern JSClassID classId_Ozone_PaintEvent;
extern JSClassID classId_Ozone_NcPaintEvent;
extern JSClassID classId_Ozone_EraseEvent;
extern JSClassID classId_Ozone_FocusEvent;
extern JSClassID classId_Ozone_Window;
extern JSClassID classId_Ozone_ChildFocusEvent;
extern JSClassID classId_Ozone_ActivateEvent;
extern JSClassID classId_Ozone_InitDialogEvent;
extern JSClassID classId_Ozone_MenuEvent;
extern JSClassID classId_Ozone_CloseEvent;
extern JSClassID classId_Ozone_ShowEvent;
extern JSClassID classId_Ozone_IconizeEvent;
extern JSClassID classId_Ozone_MaximizeEvent;
extern JSClassID classId_Ozone_JoystickEvent;
extern JSClassID classId_Ozone_UpdateUIEvent;
extern JSClassID classId_Ozone_SysColourChangedEvent;
extern JSClassID classId_Ozone_MouseCaptureChangedEvent;
extern JSClassID classId_Ozone_MouseCaptureLostEvent;
extern JSClassID classId_Ozone_DisplayChangedEvent;
extern JSClassID classId_Ozone_DPIChangedEvent;
extern JSClassID classId_Ozone_PaletteChangedEvent;
extern JSClassID classId_Ozone_QueryNewPaletteEvent;
extern JSClassID classId_Ozone_NavigationKeyEvent;
extern JSClassID classId_Ozone_WindowCreateEvent;
extern JSClassID classId_Ozone_WindowDestroyEvent;
extern JSClassID classId_Ozone_HelpEvent;
extern JSClassID classId_Ozone_ClipboardTextEvent;
extern JSClassID classId_Ozone_ContextMenuEvent;
extern JSClassID classId_Ozone_Private_EventClassOf;
extern JSClassID classId__Signal;

static void register_enum_Ozone_EventCategory(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "EventCategory");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // UI
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "UI", __item);
    }

    // USER_INPUT
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "USER_INPUT", __item);
    }

    // SOCKET
    {
        JSValue __item = JS_NewUint32(ctx, 4);
        JS_SetPropertyStr(ctx, val, "SOCKET", __item);
    }

    // TIMER
    {
        JSValue __item = JS_NewUint32(ctx, 8);
        JS_SetPropertyStr(ctx, val, "TIMER", __item);
    }

    // THREAD
    {
        JSValue __item = JS_NewUint32(ctx, 16);
        JS_SetPropertyStr(ctx, val, "THREAD", __item);
    }

    // UNKNOWN
    {
        JSValue __item = JS_NewUint32(ctx, 32);
        JS_SetPropertyStr(ctx, val, "UNKNOWN", __item);
    }

    // CLIPBOARD
    {
        JSValue __item = JS_NewUint32(ctx, 64);
        JS_SetPropertyStr(ctx, val, "CLIPBOARD", __item);
    }

    // NATIVE_EVENTS
    {
        JSValue __item = JS_NewUint32(ctx, 3);
        JS_SetPropertyStr(ctx, val, "NATIVE_EVENTS", __item);
    }

    // ALL
    {
        JSValue __item = JS_NewUint32(ctx, 127);
        JS_SetPropertyStr(ctx, val, "ALL", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "EventCategory", val);
    assert(status != -1);
}

static void register_enum_Ozone_IdleMode(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "IdleMode");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // PROCESS_ALL
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "PROCESS_ALL", __item);
    }

    // PROCESS_SPECIFIED
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "PROCESS_SPECIFIED", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "IdleMode", val);
    assert(status != -1);
}

static void register_enum_Ozone_MouseWheelAxis(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "MouseWheelAxis");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // VERTICAL
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "VERTICAL", __item);
    }

    // HORIZONTAL
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "HORIZONTAL", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "MouseWheelAxis", val);
    assert(status != -1);
}

static void register_enum_Ozone_UpdateUIMode(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "UpdateUIMode");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // PROCESS_ALL
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "PROCESS_ALL", __item);
    }

    // PROCESS_SPECIFIED
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "PROCESS_SPECIFIED", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "UpdateUIMode", val);
    assert(status != -1);
}

static void register_enum_Ozone_EventPropagation(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "EventPropagation");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // NONE
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "NONE", __item);
    }

    // MAX
    {
        JSValue __item = JS_NewUint32(ctx, 2147483647);
        JS_SetPropertyStr(ctx, val, "MAX", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "EventPropagation", val);
    assert(status != -1);
}

static void register_enum_Ozone_JoystickButton(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "JoystickButton");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // BUTTON_ANY
    {
        JSValue __item = JS_NewInt32(ctx, -1);
        JS_SetPropertyStr(ctx, val, "BUTTON_ANY", __item);
    }

    // BUTTON1
    {
        JSValue __item = JS_NewInt32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "BUTTON1", __item);
    }

    // BUTTON2
    {
        JSValue __item = JS_NewInt32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "BUTTON2", __item);
    }

    // BUTTON3
    {
        JSValue __item = JS_NewInt32(ctx, 4);
        JS_SetPropertyStr(ctx, val, "BUTTON3", __item);
    }

    // BUTTON4
    {
        JSValue __item = JS_NewInt32(ctx, 8);
        JS_SetPropertyStr(ctx, val, "BUTTON4", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "JoystickButton", val);
    assert(status != -1);
}

static void register_enum_Ozone_JoystickId(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "JoystickId");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // JOYSTICK1
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "JOYSTICK1", __item);
    }

    // JOYSTICK2
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "JOYSTICK2", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "JoystickId", val);
    assert(status != -1);
}

static void register_enum_Ozone_KeyCategoryFlags(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "KeyCategoryFlags");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // CATEGORY_ARROW
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "CATEGORY_ARROW", __item);
    }

    // CATEGORY_PAGING
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "CATEGORY_PAGING", __item);
    }

    // CATEGORY_JUMP
    {
        JSValue __item = JS_NewUint32(ctx, 4);
        JS_SetPropertyStr(ctx, val, "CATEGORY_JUMP", __item);
    }

    // CATEGORY_TAB
    {
        JSValue __item = JS_NewUint32(ctx, 8);
        JS_SetPropertyStr(ctx, val, "CATEGORY_TAB", __item);
    }

    // CATEGORY_CUT
    {
        JSValue __item = JS_NewUint32(ctx, 16);
        JS_SetPropertyStr(ctx, val, "CATEGORY_CUT", __item);
    }

    // CATEGORY_NAVIGATION
    {
        JSValue __item = JS_NewUint32(ctx, 7);
        JS_SetPropertyStr(ctx, val, "CATEGORY_NAVIGATION", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "KeyCategoryFlags", val);
    assert(status != -1);
}

JSClassID classId_Ozone_Event;

// Ozone::Event::Event
static JSValue callback_method_Ozone_Event_Event(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // Event(int winid, int commandType)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        int commandType;
        int32_t _commandType;
        if (JS_ToInt32(ctx, &_commandType, argv[1]))
            return JS_EXCEPTION;
        commandType = (int)_commandType;
        auto __arg1 = commandType;

        instance = new Ozone::Event(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_Event);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_Event);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::Event::SetEventType
static JSValue callback_method_Ozone_Event_SetEventType(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetEventType(int typ)
overload0:
    {
        int typ;
        int32_t _typ;
        if (JS_ToInt32(ctx, &_typ, argv[0]))
            return JS_EXCEPTION;
        typ = (int)_typ;
        auto __arg0 = typ;

        instance->SetEventType(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Event::GetEventType
static JSValue callback_method_Ozone_Event_GetEventType(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetEventType();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Event::GetEventObject
static JSValue callback_method_Ozone_Event_GetEventObject(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    ::Ozone::Object* __ret = instance->GetEventObject();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::Event::SetEventObject
static JSValue callback_method_Ozone_Event_SetEventObject(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetEventObject(::Ozone::Object* obj)
overload0:
    {
        Ozone::Object* obj_instance = (Ozone::Object*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = obj_instance;

        instance->SetEventObject(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Event::GetTimestamp
static JSValue callback_method_Ozone_Event_GetTimestamp(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    long __ret = instance->GetTimestamp();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Event::SetTimestamp
static JSValue callback_method_Ozone_Event_SetTimestamp(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetTimestamp(long ts)
overload0:
    {
        long ts;
        int32_t _ts;
        if (JS_ToInt32(ctx, &_ts, argv[0]))
            return JS_EXCEPTION;
        ts = (long)_ts;
        auto __arg0 = ts;

        instance->SetTimestamp(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Event::GetId
static JSValue callback_method_Ozone_Event_GetId(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetId();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Event::SetId
static JSValue callback_method_Ozone_Event_SetId(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetId(int Id)
overload0:
    {
        int Id;
        int32_t _Id;
        if (JS_ToInt32(ctx, &_Id, argv[0]))
            return JS_EXCEPTION;
        Id = (int)_Id;
        auto __arg0 = Id;

        instance->SetId(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Event::GetEventUserData
static JSValue callback_method_Ozone_Event_GetEventUserData(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    ::Ozone::Object* __ret = instance->GetEventUserData();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::Event::Skip
static JSValue callback_method_Ozone_Event_Skip(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Skip(bool skip)
overload0:
    {
        bool skip;
        skip = JS_ToBool(ctx, argv[0]);
        if (skip == -1)
            return JS_EXCEPTION;
        auto __arg0 = skip;

        instance->Skip(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Event::GetSkipped
static JSValue callback_method_Ozone_Event_GetSkipped(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetSkipped();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::Event::Clone
static JSValue callback_method_Ozone_Event_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::Event::GetEventCategory
static JSValue callback_method_Ozone_Event_GetEventCategory(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    ::Ozone::EventCategory __ret = instance->GetEventCategory();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::Event::IsCommandEvent
static JSValue callback_method_Ozone_Event_IsCommandEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsCommandEvent();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::Event::ShouldPropagate
static JSValue callback_method_Ozone_Event_ShouldPropagate(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->ShouldPropagate();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::Event::StopPropagation
static JSValue callback_method_Ozone_Event_StopPropagation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    int __ret = instance->StopPropagation();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Event::ResumePropagation
static JSValue callback_method_Ozone_Event_ResumePropagation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void ResumePropagation(int propagationLevel)
overload0:
    {
        int propagationLevel;
        int32_t _propagationLevel;
        if (JS_ToInt32(ctx, &_propagationLevel, argv[0]))
            return JS_EXCEPTION;
        propagationLevel = (int)_propagationLevel;
        auto __arg0 = propagationLevel;

        instance->ResumePropagation(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Event::GetPropagatedFrom
static JSValue callback_method_Ozone_Event_GetPropagatedFrom(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    ::Ozone::EvtHandler* __ret = instance->GetPropagatedFrom();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_EvtHandler, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::Event::WasProcessed
static JSValue callback_method_Ozone_Event_WasProcessed(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->WasProcessed();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::Event::SetWillBeProcessedAgain
static JSValue callback_method_Ozone_Event_SetWillBeProcessedAgain(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    instance->SetWillBeProcessedAgain();

    return JS_UNDEFINED;
}

// Ozone::Event::WillBeProcessedAgain
static JSValue callback_method_Ozone_Event_WillBeProcessedAgain(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->WillBeProcessedAgain();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::Event::ShouldProcessOnlyIn
static JSValue callback_method_Ozone_Event_ShouldProcessOnlyIn(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool ShouldProcessOnlyIn(::Ozone::EvtHandler* h) const
overload0:
    {
        Ozone::EvtHandler* h_instance = (Ozone::EvtHandler*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_EvtHandler, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = h_instance;

        bool __ret = instance->ShouldProcessOnlyIn(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Event::DidntHonourProcessOnlyIn
static JSValue callback_method_Ozone_Event_DidntHonourProcessOnlyIn(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    instance->DidntHonourProcessOnlyIn();

    return JS_UNDEFINED;
}

// Ozone::Event::get_m_callbackUserData
static JSValue callback_method_Ozone_Event_get_m_callbackUserData(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    ::Ozone::Object* __ret = instance->get_m_callbackUserData();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::Event::set_m_callbackUserData
static JSValue callback_method_Ozone_Event_set_m_callbackUserData(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_callbackUserData(::Ozone::Object* value)
overload0:
    {
        Ozone::Object* value_instance = (Ozone::Object*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = value_instance;

        instance->set_m_callbackUserData(__arg0);

        return JS_UNDEFINED;
    }
}

static JSValue callback_class_Ozone_Event_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "Event");
}

void finalizer_Ozone_Event(JSRuntime *rt, JSValue val)
{
    Ozone::Event* instance = (Ozone::Event*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_Event
{
    "Event",
    .finalizer = finalizer_Ozone_Event
};

static JSCFunctionListEntry funcDef_Ozone_Event[]
{
    JS_CFUNC_DEF("SetEventType", 1, callback_method_Ozone_Event_SetEventType),
    JS_CFUNC_DEF("GetEventType", 0, callback_method_Ozone_Event_GetEventType),
    JS_CFUNC_DEF("GetEventObject", 0, callback_method_Ozone_Event_GetEventObject),
    JS_CFUNC_DEF("SetEventObject", 1, callback_method_Ozone_Event_SetEventObject),
    JS_CFUNC_DEF("GetTimestamp", 0, callback_method_Ozone_Event_GetTimestamp),
    JS_CFUNC_DEF("SetTimestamp", 1, callback_method_Ozone_Event_SetTimestamp),
    JS_CFUNC_DEF("GetId", 0, callback_method_Ozone_Event_GetId),
    JS_CFUNC_DEF("SetId", 1, callback_method_Ozone_Event_SetId),
    JS_CFUNC_DEF("GetEventUserData", 0, callback_method_Ozone_Event_GetEventUserData),
    JS_CFUNC_DEF("Skip", 1, callback_method_Ozone_Event_Skip),
    JS_CFUNC_DEF("GetSkipped", 0, callback_method_Ozone_Event_GetSkipped),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_Event_Clone),
    JS_CFUNC_DEF("GetEventCategory", 0, callback_method_Ozone_Event_GetEventCategory),
    JS_CFUNC_DEF("IsCommandEvent", 0, callback_method_Ozone_Event_IsCommandEvent),
    JS_CFUNC_DEF("ShouldPropagate", 0, callback_method_Ozone_Event_ShouldPropagate),
    JS_CFUNC_DEF("StopPropagation", 0, callback_method_Ozone_Event_StopPropagation),
    JS_CFUNC_DEF("ResumePropagation", 1, callback_method_Ozone_Event_ResumePropagation),
    JS_CFUNC_DEF("GetPropagatedFrom", 0, callback_method_Ozone_Event_GetPropagatedFrom),
    JS_CFUNC_DEF("WasProcessed", 0, callback_method_Ozone_Event_WasProcessed),
    JS_CFUNC_DEF("SetWillBeProcessedAgain", 0, callback_method_Ozone_Event_SetWillBeProcessedAgain),
    JS_CFUNC_DEF("WillBeProcessedAgain", 0, callback_method_Ozone_Event_WillBeProcessedAgain),
    JS_CFUNC_DEF("ShouldProcessOnlyIn", 1, callback_method_Ozone_Event_ShouldProcessOnlyIn),
    JS_CFUNC_DEF("DidntHonourProcessOnlyIn", 0, callback_method_Ozone_Event_DidntHonourProcessOnlyIn),
    JS_CFUNC_DEF("get_m_callbackUserData", 0, callback_method_Ozone_Event_get_m_callbackUserData),
    JS_CFUNC_DEF("set_m_callbackUserData", 1, callback_method_Ozone_Event_set_m_callbackUserData),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_Event_toString),
};

static void register_class_Ozone_Event(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "Event");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_Event);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_Event, &classDef_Ozone_Event);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_Event, sizeof(funcDef_Ozone_Event) / sizeof(funcDef_Ozone_Event[0]));
        JS_SetClassProto(ctx, classId_Ozone_Event, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_Event_Event, "Event", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "Event", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_Event);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Object);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_PropagateOnce;

// Ozone::PropagateOnce::PropagateOnce
static JSValue callback_method_Ozone_PropagateOnce_PropagateOnce(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PropagateOnce* instance;

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]) || JS_IsNull(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // PropagateOnce(::Ozone::Event& event, ::Ozone::EvtHandler* handler)
overload0:
    {
        Ozone::Event* event_instance = (Ozone::Event*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *event_instance;

        Ozone::EvtHandler* handler_instance = (Ozone::EvtHandler*) JS_Interop_GetInstance(argv[1], \
            classId_Ozone_EvtHandler, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg1 = handler_instance;

        instance = new Ozone::PropagateOnce(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_PropagateOnce);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_PropagateOnce);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

static JSValue callback_class_Ozone_PropagateOnce_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "PropagateOnce");
}

void finalizer_Ozone_PropagateOnce(JSRuntime *rt, JSValue val)
{
    Ozone::PropagateOnce* instance = (Ozone::PropagateOnce*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_PropagateOnce
{
    "PropagateOnce",
    .finalizer = finalizer_Ozone_PropagateOnce
};

static JSCFunctionListEntry funcDef_Ozone_PropagateOnce[]
{
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_PropagateOnce_toString),
};

static void register_class_Ozone_PropagateOnce(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "PropagateOnce");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_PropagateOnce);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_PropagateOnce, &classDef_Ozone_PropagateOnce);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_PropagateOnce, sizeof(funcDef_Ozone_PropagateOnce) / sizeof(funcDef_Ozone_PropagateOnce[0]));
        JS_SetClassProto(ctx, classId_Ozone_PropagateOnce, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_PropagateOnce_PropagateOnce, "PropagateOnce", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "PropagateOnce", ctor);
    }
}

JSClassID classId_Ozone_IdleEvent;

// Ozone::IdleEvent::IdleEvent
static JSValue callback_method_Ozone_IdleEvent_IdleEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::IdleEvent* instance;

    instance = new Ozone::IdleEvent();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_IdleEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_IdleEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::IdleEvent::RequestMore
static JSValue callback_method_Ozone_IdleEvent_RequestMore(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::IdleEvent* instance = (Ozone::IdleEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void RequestMore(bool needMore)
overload0:
    {
        bool needMore;
        needMore = JS_ToBool(ctx, argv[0]);
        if (needMore == -1)
            return JS_EXCEPTION;
        auto __arg0 = needMore;

        instance->RequestMore(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::IdleEvent::MoreRequested
static JSValue callback_method_Ozone_IdleEvent_MoreRequested(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::IdleEvent* instance = (Ozone::IdleEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->MoreRequested();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::IdleEvent::Clone
static JSValue callback_method_Ozone_IdleEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::IdleEvent* instance = (Ozone::IdleEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::IdleEvent::SetMode
static JSValue callback_method_Ozone_IdleEvent_SetMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetMode(::Ozone::IdleMode mode)
overload0:
    {
        unsigned int mode;
        uint32_t _mode;
        if (JS_ToUint32(ctx, &_mode, argv[0]))
            return JS_EXCEPTION;
        mode = (unsigned int)_mode;
        auto __arg0 = (::Ozone::IdleMode)mode;

        ::Ozone::IdleEvent::SetMode(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::IdleEvent::GetMode
static JSValue callback_method_Ozone_IdleEvent_GetMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    ::Ozone::IdleMode __ret = ::Ozone::IdleEvent::GetMode();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_IdleEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "IdleEvent");
}

void finalizer_Ozone_IdleEvent(JSRuntime *rt, JSValue val)
{
    Ozone::IdleEvent* instance = (Ozone::IdleEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_IdleEvent
{
    "IdleEvent",
    .finalizer = finalizer_Ozone_IdleEvent
};

static JSCFunctionListEntry funcDef_Ozone_IdleEvent[]
{
    JS_CFUNC_DEF("RequestMore", 1, callback_method_Ozone_IdleEvent_RequestMore),
    JS_CFUNC_DEF("MoreRequested", 0, callback_method_Ozone_IdleEvent_MoreRequested),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_IdleEvent_Clone),
    JS_CFUNC_DEF("SetMode", 1, callback_method_Ozone_IdleEvent_SetMode),
    JS_CFUNC_DEF("GetMode", 0, callback_method_Ozone_IdleEvent_GetMode),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_IdleEvent_toString),
};

static void register_class_Ozone_IdleEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "IdleEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_IdleEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_IdleEvent, &classDef_Ozone_IdleEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_IdleEvent, sizeof(funcDef_Ozone_IdleEvent) / sizeof(funcDef_Ozone_IdleEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_IdleEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_IdleEvent_IdleEvent, "IdleEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "IdleEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_IdleEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_ThreadEvent;

// Ozone::ThreadEvent::ThreadEvent
static JSValue callback_method_Ozone_ThreadEvent_ThreadEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ThreadEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ThreadEvent(int eventType, int id)
overload0:
    {
        int eventType;
        int32_t _eventType;
        if (JS_ToInt32(ctx, &_eventType, argv[0]))
            return JS_EXCEPTION;
        eventType = (int)_eventType;
        auto __arg0 = eventType;

        int id;
        int32_t _id;
        if (JS_ToInt32(ctx, &_id, argv[1]))
            return JS_EXCEPTION;
        id = (int)_id;
        auto __arg1 = id;

        instance = new Ozone::ThreadEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_ThreadEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_ThreadEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::ThreadEvent::Clone
static JSValue callback_method_Ozone_ThreadEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ThreadEvent* instance = (Ozone::ThreadEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::ThreadEvent::GetEventCategory
static JSValue callback_method_Ozone_ThreadEvent_GetEventCategory(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ThreadEvent* instance = (Ozone::ThreadEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::EventCategory __ret = instance->GetEventCategory();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_ThreadEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "ThreadEvent");
}

void finalizer_Ozone_ThreadEvent(JSRuntime *rt, JSValue val)
{
    Ozone::ThreadEvent* instance = (Ozone::ThreadEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_ThreadEvent
{
    "ThreadEvent",
    .finalizer = finalizer_Ozone_ThreadEvent
};

static JSCFunctionListEntry funcDef_Ozone_ThreadEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_ThreadEvent_Clone),
    JS_CFUNC_DEF("GetEventCategory", 0, callback_method_Ozone_ThreadEvent_GetEventCategory),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_ThreadEvent_toString),
};

static void register_class_Ozone_ThreadEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "ThreadEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_ThreadEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_ThreadEvent, &classDef_Ozone_ThreadEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_ThreadEvent, sizeof(funcDef_Ozone_ThreadEvent) / sizeof(funcDef_Ozone_ThreadEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_ThreadEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_ThreadEvent_ThreadEvent, "ThreadEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "ThreadEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_ThreadEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_AsyncMethodCallEvent;

// Ozone::AsyncMethodCallEvent::AsyncMethodCallEvent
static JSValue callback_method_Ozone_AsyncMethodCallEvent_AsyncMethodCallEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::AsyncMethodCallEvent* instance;

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // AsyncMethodCallEvent(::Ozone::Object* object)
overload0:
    {
        Ozone::Object* object_instance = (Ozone::Object*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = object_instance;

        instance = new Ozone::AsyncMethodCallEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_AsyncMethodCallEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_AsyncMethodCallEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::AsyncMethodCallEvent::Execute
static JSValue callback_method_Ozone_AsyncMethodCallEvent_Execute(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::AsyncMethodCallEvent* instance = (Ozone::AsyncMethodCallEvent*) JS_GetOpaque(this_val, 0);

    instance->Execute();

    return JS_UNDEFINED;
}

static JSValue callback_class_Ozone_AsyncMethodCallEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "AsyncMethodCallEvent");
}

void finalizer_Ozone_AsyncMethodCallEvent(JSRuntime *rt, JSValue val)
{
    Ozone::AsyncMethodCallEvent* instance = (Ozone::AsyncMethodCallEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_AsyncMethodCallEvent
{
    "AsyncMethodCallEvent",
    .finalizer = finalizer_Ozone_AsyncMethodCallEvent
};

static JSCFunctionListEntry funcDef_Ozone_AsyncMethodCallEvent[]
{
    JS_CFUNC_DEF("Execute", 0, callback_method_Ozone_AsyncMethodCallEvent_Execute),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_AsyncMethodCallEvent_toString),
};

static void register_class_Ozone_AsyncMethodCallEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "AsyncMethodCallEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_AsyncMethodCallEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_AsyncMethodCallEvent, &classDef_Ozone_AsyncMethodCallEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_AsyncMethodCallEvent, sizeof(funcDef_Ozone_AsyncMethodCallEvent) / sizeof(funcDef_Ozone_AsyncMethodCallEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_AsyncMethodCallEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_AsyncMethodCallEvent_AsyncMethodCallEvent, "AsyncMethodCallEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "AsyncMethodCallEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_AsyncMethodCallEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_CommandEvent;

// Ozone::CommandEvent::CommandEvent
static JSValue callback_method_Ozone_CommandEvent_CommandEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CommandEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // CommandEvent(int commandType, int winid)
overload0:
    {
        int commandType;
        int32_t _commandType;
        if (JS_ToInt32(ctx, &_commandType, argv[0]))
            return JS_EXCEPTION;
        commandType = (int)_commandType;
        auto __arg0 = commandType;

        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[1]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg1 = winid;

        instance = new Ozone::CommandEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_CommandEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_CommandEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::CommandEvent::GetString
static JSValue callback_method_Ozone_CommandEvent_GetString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CommandEvent* instance = (Ozone::CommandEvent*) JS_GetOpaque(this_val, 0);

    const char* __ret = instance->GetString();

    JSValue ____ret = JS_NewString(ctx, __ret);

    return ____ret;
}

// Ozone::CommandEvent::GetSelection
static JSValue callback_method_Ozone_CommandEvent_GetSelection(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CommandEvent* instance = (Ozone::CommandEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetSelection();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::CommandEvent::IsChecked
static JSValue callback_method_Ozone_CommandEvent_IsChecked(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CommandEvent* instance = (Ozone::CommandEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsChecked();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::CommandEvent::IsSelection
static JSValue callback_method_Ozone_CommandEvent_IsSelection(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CommandEvent* instance = (Ozone::CommandEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsSelection();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::CommandEvent::Clone
static JSValue callback_method_Ozone_CommandEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CommandEvent* instance = (Ozone::CommandEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::CommandEvent::GetEventCategory
static JSValue callback_method_Ozone_CommandEvent_GetEventCategory(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CommandEvent* instance = (Ozone::CommandEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::EventCategory __ret = instance->GetEventCategory();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_CommandEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "CommandEvent");
}

void finalizer_Ozone_CommandEvent(JSRuntime *rt, JSValue val)
{
    Ozone::CommandEvent* instance = (Ozone::CommandEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_CommandEvent
{
    "CommandEvent",
    .finalizer = finalizer_Ozone_CommandEvent
};

static JSCFunctionListEntry funcDef_Ozone_CommandEvent[]
{
    JS_CFUNC_DEF("GetString", 0, callback_method_Ozone_CommandEvent_GetString),
    JS_CFUNC_DEF("GetSelection", 0, callback_method_Ozone_CommandEvent_GetSelection),
    JS_CFUNC_DEF("IsChecked", 0, callback_method_Ozone_CommandEvent_IsChecked),
    JS_CFUNC_DEF("IsSelection", 0, callback_method_Ozone_CommandEvent_IsSelection),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_CommandEvent_Clone),
    JS_CFUNC_DEF("GetEventCategory", 0, callback_method_Ozone_CommandEvent_GetEventCategory),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_CommandEvent_toString),
};

static void register_class_Ozone_CommandEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "CommandEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_CommandEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_CommandEvent, &classDef_Ozone_CommandEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_CommandEvent, sizeof(funcDef_Ozone_CommandEvent) / sizeof(funcDef_Ozone_CommandEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_CommandEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_CommandEvent_CommandEvent, "CommandEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "CommandEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_CommandEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_NotifyEvent;

// Ozone::NotifyEvent::NotifyEvent
static JSValue callback_method_Ozone_NotifyEvent_NotifyEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NotifyEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // NotifyEvent(int commandType, int winid)
overload0:
    {
        int commandType;
        int32_t _commandType;
        if (JS_ToInt32(ctx, &_commandType, argv[0]))
            return JS_EXCEPTION;
        commandType = (int)_commandType;
        auto __arg0 = commandType;

        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[1]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg1 = winid;

        instance = new Ozone::NotifyEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_NotifyEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_NotifyEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::NotifyEvent::Veto
static JSValue callback_method_Ozone_NotifyEvent_Veto(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NotifyEvent* instance = (Ozone::NotifyEvent*) JS_GetOpaque(this_val, 0);

    instance->Veto();

    return JS_UNDEFINED;
}

// Ozone::NotifyEvent::Allow
static JSValue callback_method_Ozone_NotifyEvent_Allow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NotifyEvent* instance = (Ozone::NotifyEvent*) JS_GetOpaque(this_val, 0);

    instance->Allow();

    return JS_UNDEFINED;
}

// Ozone::NotifyEvent::IsAllowed
static JSValue callback_method_Ozone_NotifyEvent_IsAllowed(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NotifyEvent* instance = (Ozone::NotifyEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsAllowed();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::NotifyEvent::Clone
static JSValue callback_method_Ozone_NotifyEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NotifyEvent* instance = (Ozone::NotifyEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_NotifyEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "NotifyEvent");
}

void finalizer_Ozone_NotifyEvent(JSRuntime *rt, JSValue val)
{
    Ozone::NotifyEvent* instance = (Ozone::NotifyEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_NotifyEvent
{
    "NotifyEvent",
    .finalizer = finalizer_Ozone_NotifyEvent
};

static JSCFunctionListEntry funcDef_Ozone_NotifyEvent[]
{
    JS_CFUNC_DEF("Veto", 0, callback_method_Ozone_NotifyEvent_Veto),
    JS_CFUNC_DEF("Allow", 0, callback_method_Ozone_NotifyEvent_Allow),
    JS_CFUNC_DEF("IsAllowed", 0, callback_method_Ozone_NotifyEvent_IsAllowed),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_NotifyEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_NotifyEvent_toString),
};

static void register_class_Ozone_NotifyEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "NotifyEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_NotifyEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_NotifyEvent, &classDef_Ozone_NotifyEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_NotifyEvent, sizeof(funcDef_Ozone_NotifyEvent) / sizeof(funcDef_Ozone_NotifyEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_NotifyEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_NotifyEvent_NotifyEvent, "NotifyEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "NotifyEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_NotifyEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_CommandEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_ScrollEvent;

// Ozone::ScrollEvent::ScrollEvent
static JSValue callback_method_Ozone_ScrollEvent_ScrollEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 4)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsInt32(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsInt32(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ScrollEvent(int commandType, int winid, int pos, int orient)
overload0:
    {
        int commandType;
        int32_t _commandType;
        if (JS_ToInt32(ctx, &_commandType, argv[0]))
            return JS_EXCEPTION;
        commandType = (int)_commandType;
        auto __arg0 = commandType;

        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[1]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg1 = winid;

        int pos;
        int32_t _pos;
        if (JS_ToInt32(ctx, &_pos, argv[2]))
            return JS_EXCEPTION;
        pos = (int)_pos;
        auto __arg2 = pos;

        int orient;
        int32_t _orient;
        if (JS_ToInt32(ctx, &_orient, argv[3]))
            return JS_EXCEPTION;
        orient = (int)_orient;
        auto __arg3 = orient;

        instance = new Ozone::ScrollEvent(__arg0, __arg1, __arg2, __arg3);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_ScrollEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_ScrollEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::ScrollEvent::GetOrientation
static JSValue callback_method_Ozone_ScrollEvent_GetOrientation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollEvent* instance = (Ozone::ScrollEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetOrientation();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::ScrollEvent::GetPosition
static JSValue callback_method_Ozone_ScrollEvent_GetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollEvent* instance = (Ozone::ScrollEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetPosition();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::ScrollEvent::SetOrientation
static JSValue callback_method_Ozone_ScrollEvent_SetOrientation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollEvent* instance = (Ozone::ScrollEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetOrientation(int orient)
overload0:
    {
        int orient;
        int32_t _orient;
        if (JS_ToInt32(ctx, &_orient, argv[0]))
            return JS_EXCEPTION;
        orient = (int)_orient;
        auto __arg0 = orient;

        instance->SetOrientation(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::ScrollEvent::SetPosition
static JSValue callback_method_Ozone_ScrollEvent_SetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollEvent* instance = (Ozone::ScrollEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPosition(int pos)
overload0:
    {
        int pos;
        int32_t _pos;
        if (JS_ToInt32(ctx, &_pos, argv[0]))
            return JS_EXCEPTION;
        pos = (int)_pos;
        auto __arg0 = pos;

        instance->SetPosition(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::ScrollEvent::Clone
static JSValue callback_method_Ozone_ScrollEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollEvent* instance = (Ozone::ScrollEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_ScrollEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "ScrollEvent");
}

void finalizer_Ozone_ScrollEvent(JSRuntime *rt, JSValue val)
{
    Ozone::ScrollEvent* instance = (Ozone::ScrollEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_ScrollEvent
{
    "ScrollEvent",
    .finalizer = finalizer_Ozone_ScrollEvent
};

static JSCFunctionListEntry funcDef_Ozone_ScrollEvent[]
{
    JS_CFUNC_DEF("GetOrientation", 0, callback_method_Ozone_ScrollEvent_GetOrientation),
    JS_CFUNC_DEF("GetPosition", 0, callback_method_Ozone_ScrollEvent_GetPosition),
    JS_CFUNC_DEF("SetOrientation", 1, callback_method_Ozone_ScrollEvent_SetOrientation),
    JS_CFUNC_DEF("SetPosition", 1, callback_method_Ozone_ScrollEvent_SetPosition),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_ScrollEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_ScrollEvent_toString),
};

static void register_class_Ozone_ScrollEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "ScrollEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_ScrollEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_ScrollEvent, &classDef_Ozone_ScrollEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_ScrollEvent, sizeof(funcDef_Ozone_ScrollEvent) / sizeof(funcDef_Ozone_ScrollEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_ScrollEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_ScrollEvent_ScrollEvent, "ScrollEvent", 4, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "ScrollEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_ScrollEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_CommandEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_ScrollWinEvent;

// Ozone::ScrollWinEvent::ScrollWinEvent
static JSValue callback_method_Ozone_ScrollWinEvent_ScrollWinEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 3)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollWinEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsInt32(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ScrollWinEvent(int commandType, int pos, int orient)
overload0:
    {
        int commandType;
        int32_t _commandType;
        if (JS_ToInt32(ctx, &_commandType, argv[0]))
            return JS_EXCEPTION;
        commandType = (int)_commandType;
        auto __arg0 = commandType;

        int pos;
        int32_t _pos;
        if (JS_ToInt32(ctx, &_pos, argv[1]))
            return JS_EXCEPTION;
        pos = (int)_pos;
        auto __arg1 = pos;

        int orient;
        int32_t _orient;
        if (JS_ToInt32(ctx, &_orient, argv[2]))
            return JS_EXCEPTION;
        orient = (int)_orient;
        auto __arg2 = orient;

        instance = new Ozone::ScrollWinEvent(__arg0, __arg1, __arg2);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_ScrollWinEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_ScrollWinEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::ScrollWinEvent::GetOrientation
static JSValue callback_method_Ozone_ScrollWinEvent_GetOrientation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollWinEvent* instance = (Ozone::ScrollWinEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetOrientation();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::ScrollWinEvent::GetPosition
static JSValue callback_method_Ozone_ScrollWinEvent_GetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollWinEvent* instance = (Ozone::ScrollWinEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetPosition();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::ScrollWinEvent::SetOrientation
static JSValue callback_method_Ozone_ScrollWinEvent_SetOrientation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollWinEvent* instance = (Ozone::ScrollWinEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetOrientation(int orient)
overload0:
    {
        int orient;
        int32_t _orient;
        if (JS_ToInt32(ctx, &_orient, argv[0]))
            return JS_EXCEPTION;
        orient = (int)_orient;
        auto __arg0 = orient;

        instance->SetOrientation(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::ScrollWinEvent::SetPosition
static JSValue callback_method_Ozone_ScrollWinEvent_SetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollWinEvent* instance = (Ozone::ScrollWinEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPosition(int pos)
overload0:
    {
        int pos;
        int32_t _pos;
        if (JS_ToInt32(ctx, &_pos, argv[0]))
            return JS_EXCEPTION;
        pos = (int)_pos;
        auto __arg0 = pos;

        instance->SetPosition(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::ScrollWinEvent::Clone
static JSValue callback_method_Ozone_ScrollWinEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ScrollWinEvent* instance = (Ozone::ScrollWinEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_ScrollWinEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "ScrollWinEvent");
}

void finalizer_Ozone_ScrollWinEvent(JSRuntime *rt, JSValue val)
{
    Ozone::ScrollWinEvent* instance = (Ozone::ScrollWinEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_ScrollWinEvent
{
    "ScrollWinEvent",
    .finalizer = finalizer_Ozone_ScrollWinEvent
};

static JSCFunctionListEntry funcDef_Ozone_ScrollWinEvent[]
{
    JS_CFUNC_DEF("GetOrientation", 0, callback_method_Ozone_ScrollWinEvent_GetOrientation),
    JS_CFUNC_DEF("GetPosition", 0, callback_method_Ozone_ScrollWinEvent_GetPosition),
    JS_CFUNC_DEF("SetOrientation", 1, callback_method_Ozone_ScrollWinEvent_SetOrientation),
    JS_CFUNC_DEF("SetPosition", 1, callback_method_Ozone_ScrollWinEvent_SetPosition),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_ScrollWinEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_ScrollWinEvent_toString),
};

static void register_class_Ozone_ScrollWinEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "ScrollWinEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_ScrollWinEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_ScrollWinEvent, &classDef_Ozone_ScrollWinEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_ScrollWinEvent, sizeof(funcDef_Ozone_ScrollWinEvent) / sizeof(funcDef_Ozone_ScrollWinEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_ScrollWinEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_ScrollWinEvent_ScrollWinEvent, "ScrollWinEvent", 3, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "ScrollWinEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_ScrollWinEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_MouseEvent;

// Ozone::MouseEvent::MouseEvent
static JSValue callback_method_Ozone_MouseEvent_MouseEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // MouseEvent(int mouseType)
overload0:
    {
        int mouseType;
        int32_t _mouseType;
        if (JS_ToInt32(ctx, &_mouseType, argv[0]))
            return JS_EXCEPTION;
        mouseType = (int)_mouseType;
        auto __arg0 = mouseType;

        instance = new Ozone::MouseEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_MouseEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_MouseEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::MouseEvent::IsButton
static JSValue callback_method_Ozone_MouseEvent_IsButton(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsButton();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::ButtonDown
static JSValue callback_method_Ozone_MouseEvent_ButtonDown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool ButtonDown(int but) const
overload0:
    {
        int but;
        int32_t _but;
        if (JS_ToInt32(ctx, &_but, argv[0]))
            return JS_EXCEPTION;
        but = (int)_but;
        auto __arg0 = but;

        bool __ret = instance->ButtonDown(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::MouseEvent::ButtonDClick
static JSValue callback_method_Ozone_MouseEvent_ButtonDClick(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool ButtonDClick(int but) const
overload0:
    {
        int but;
        int32_t _but;
        if (JS_ToInt32(ctx, &_but, argv[0]))
            return JS_EXCEPTION;
        but = (int)_but;
        auto __arg0 = but;

        bool __ret = instance->ButtonDClick(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::MouseEvent::ButtonUp
static JSValue callback_method_Ozone_MouseEvent_ButtonUp(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool ButtonUp(int but) const
overload0:
    {
        int but;
        int32_t _but;
        if (JS_ToInt32(ctx, &_but, argv[0]))
            return JS_EXCEPTION;
        but = (int)_but;
        auto __arg0 = but;

        bool __ret = instance->ButtonUp(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::MouseEvent::Button
static JSValue callback_method_Ozone_MouseEvent_Button(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Button(int but) const
overload0:
    {
        int but;
        int32_t _but;
        if (JS_ToInt32(ctx, &_but, argv[0]))
            return JS_EXCEPTION;
        but = (int)_but;
        auto __arg0 = but;

        bool __ret = instance->Button(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::MouseEvent::GetButton
static JSValue callback_method_Ozone_MouseEvent_GetButton(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetButton();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::LeftDown
static JSValue callback_method_Ozone_MouseEvent_LeftDown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->LeftDown();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::MiddleDown
static JSValue callback_method_Ozone_MouseEvent_MiddleDown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->MiddleDown();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::RightDown
static JSValue callback_method_Ozone_MouseEvent_RightDown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->RightDown();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Aux1Down
static JSValue callback_method_Ozone_MouseEvent_Aux1Down(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->Aux1Down();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Aux2Down
static JSValue callback_method_Ozone_MouseEvent_Aux2Down(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->Aux2Down();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::LeftUp
static JSValue callback_method_Ozone_MouseEvent_LeftUp(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->LeftUp();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::MiddleUp
static JSValue callback_method_Ozone_MouseEvent_MiddleUp(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->MiddleUp();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::RightUp
static JSValue callback_method_Ozone_MouseEvent_RightUp(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->RightUp();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Aux1Up
static JSValue callback_method_Ozone_MouseEvent_Aux1Up(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->Aux1Up();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Aux2Up
static JSValue callback_method_Ozone_MouseEvent_Aux2Up(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->Aux2Up();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::LeftDClick
static JSValue callback_method_Ozone_MouseEvent_LeftDClick(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->LeftDClick();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::MiddleDClick
static JSValue callback_method_Ozone_MouseEvent_MiddleDClick(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->MiddleDClick();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::RightDClick
static JSValue callback_method_Ozone_MouseEvent_RightDClick(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->RightDClick();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Aux1DClick
static JSValue callback_method_Ozone_MouseEvent_Aux1DClick(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->Aux1DClick();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Aux2DClick
static JSValue callback_method_Ozone_MouseEvent_Aux2DClick(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->Aux2DClick();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Magnify
static JSValue callback_method_Ozone_MouseEvent_Magnify(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->Magnify();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Dragging
static JSValue callback_method_Ozone_MouseEvent_Dragging(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->Dragging();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Moving
static JSValue callback_method_Ozone_MouseEvent_Moving(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->Moving();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Entering
static JSValue callback_method_Ozone_MouseEvent_Entering(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->Entering();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Leaving
static JSValue callback_method_Ozone_MouseEvent_Leaving(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->Leaving();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::GetClickCount
static JSValue callback_method_Ozone_MouseEvent_GetClickCount(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetClickCount();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::GetLogicalPosition
static JSValue callback_method_Ozone_MouseEvent_GetLogicalPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Point GetLogicalPosition(const ::Ozone::DC& dc) const
overload0:
    {
        Ozone::DC* dc_instance = (Ozone::DC*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_DC, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *dc_instance;

        ::Ozone::Point __ret = instance->GetLogicalPosition(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

        return ____ret;
    }
}

// Ozone::MouseEvent::GetWheelRotation
static JSValue callback_method_Ozone_MouseEvent_GetWheelRotation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetWheelRotation();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::GetWheelDelta
static JSValue callback_method_Ozone_MouseEvent_GetWheelDelta(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetWheelDelta();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::IsWheelInverted
static JSValue callback_method_Ozone_MouseEvent_IsWheelInverted(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsWheelInverted();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::GetWheelAxis
static JSValue callback_method_Ozone_MouseEvent_GetWheelAxis(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::MouseWheelAxis __ret = instance->GetWheelAxis();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::MouseEvent::GetLinesPerAction
static JSValue callback_method_Ozone_MouseEvent_GetLinesPerAction(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetLinesPerAction();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::GetColumnsPerAction
static JSValue callback_method_Ozone_MouseEvent_GetColumnsPerAction(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetColumnsPerAction();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::IsPageScroll
static JSValue callback_method_Ozone_MouseEvent_IsPageScroll(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsPageScroll();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::GetMagnification
static JSValue callback_method_Ozone_MouseEvent_GetMagnification(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    float __ret = instance->GetMagnification();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::Clone
static JSValue callback_method_Ozone_MouseEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::MouseEvent::GetEventCategory
static JSValue callback_method_Ozone_MouseEvent_GetEventCategory(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::EventCategory __ret = instance->GetEventCategory();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::MouseEvent::get_m_clickCount
static JSValue callback_method_Ozone_MouseEvent_get_m_clickCount(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_m_clickCount();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::set_m_clickCount
static JSValue callback_method_Ozone_MouseEvent_set_m_clickCount(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_clickCount(int value)
overload0:
    {
        int value;
        int32_t _value;
        if (JS_ToInt32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (int)_value;
        auto __arg0 = value;

        instance->set_m_clickCount(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::MouseEvent::get_m_wheelAxis
static JSValue callback_method_Ozone_MouseEvent_get_m_wheelAxis(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::MouseWheelAxis __ret = instance->get_m_wheelAxis();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::MouseEvent::set_m_wheelAxis
static JSValue callback_method_Ozone_MouseEvent_set_m_wheelAxis(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_wheelAxis(::Ozone::MouseWheelAxis value)
overload0:
    {
        unsigned int value;
        uint32_t _value;
        if (JS_ToUint32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (unsigned int)_value;
        auto __arg0 = (::Ozone::MouseWheelAxis)value;

        instance->set_m_wheelAxis(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::MouseEvent::get_m_wheelRotation
static JSValue callback_method_Ozone_MouseEvent_get_m_wheelRotation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_m_wheelRotation();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::set_m_wheelRotation
static JSValue callback_method_Ozone_MouseEvent_set_m_wheelRotation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_wheelRotation(int value)
overload0:
    {
        int value;
        int32_t _value;
        if (JS_ToInt32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (int)_value;
        auto __arg0 = value;

        instance->set_m_wheelRotation(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::MouseEvent::get_m_wheelDelta
static JSValue callback_method_Ozone_MouseEvent_get_m_wheelDelta(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_m_wheelDelta();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::set_m_wheelDelta
static JSValue callback_method_Ozone_MouseEvent_set_m_wheelDelta(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_wheelDelta(int value)
overload0:
    {
        int value;
        int32_t _value;
        if (JS_ToInt32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (int)_value;
        auto __arg0 = value;

        instance->set_m_wheelDelta(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::MouseEvent::get_m_wheelInverted
static JSValue callback_method_Ozone_MouseEvent_get_m_wheelInverted(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->get_m_wheelInverted();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::set_m_wheelInverted
static JSValue callback_method_Ozone_MouseEvent_set_m_wheelInverted(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_wheelInverted(bool value)
overload0:
    {
        bool value;
        value = JS_ToBool(ctx, argv[0]);
        if (value == -1)
            return JS_EXCEPTION;
        auto __arg0 = value;

        instance->set_m_wheelInverted(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::MouseEvent::get_m_linesPerAction
static JSValue callback_method_Ozone_MouseEvent_get_m_linesPerAction(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_m_linesPerAction();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::set_m_linesPerAction
static JSValue callback_method_Ozone_MouseEvent_set_m_linesPerAction(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_linesPerAction(int value)
overload0:
    {
        int value;
        int32_t _value;
        if (JS_ToInt32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (int)_value;
        auto __arg0 = value;

        instance->set_m_linesPerAction(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::MouseEvent::get_m_columnsPerAction
static JSValue callback_method_Ozone_MouseEvent_get_m_columnsPerAction(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_m_columnsPerAction();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::set_m_columnsPerAction
static JSValue callback_method_Ozone_MouseEvent_set_m_columnsPerAction(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_columnsPerAction(int value)
overload0:
    {
        int value;
        int32_t _value;
        if (JS_ToInt32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (int)_value;
        auto __arg0 = value;

        instance->set_m_columnsPerAction(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::MouseEvent::get_m_magnification
static JSValue callback_method_Ozone_MouseEvent_get_m_magnification(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    float __ret = instance->get_m_magnification();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::MouseEvent::set_m_magnification
static JSValue callback_method_Ozone_MouseEvent_set_m_magnification(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsFloat(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_magnification(float value)
overload0:
    {
        float value;
        double _value;
        if (JS_ToFloat64(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (float)_value;
        auto __arg0 = value;

        instance->set_m_magnification(__arg0);

        return JS_UNDEFINED;
    }
}

static JSValue callback_class_Ozone_MouseEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "MouseEvent");
}

void finalizer_Ozone_MouseEvent(JSRuntime *rt, JSValue val)
{
    Ozone::MouseEvent* instance = (Ozone::MouseEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_MouseEvent
{
    "MouseEvent",
    .finalizer = finalizer_Ozone_MouseEvent
};

static JSCFunctionListEntry funcDef_Ozone_MouseEvent[]
{
    JS_CFUNC_DEF("IsButton", 0, callback_method_Ozone_MouseEvent_IsButton),
    JS_CFUNC_DEF("ButtonDown", 1, callback_method_Ozone_MouseEvent_ButtonDown),
    JS_CFUNC_DEF("ButtonDClick", 1, callback_method_Ozone_MouseEvent_ButtonDClick),
    JS_CFUNC_DEF("ButtonUp", 1, callback_method_Ozone_MouseEvent_ButtonUp),
    JS_CFUNC_DEF("Button", 1, callback_method_Ozone_MouseEvent_Button),
    JS_CFUNC_DEF("GetButton", 0, callback_method_Ozone_MouseEvent_GetButton),
    JS_CFUNC_DEF("LeftDown", 0, callback_method_Ozone_MouseEvent_LeftDown),
    JS_CFUNC_DEF("MiddleDown", 0, callback_method_Ozone_MouseEvent_MiddleDown),
    JS_CFUNC_DEF("RightDown", 0, callback_method_Ozone_MouseEvent_RightDown),
    JS_CFUNC_DEF("Aux1Down", 0, callback_method_Ozone_MouseEvent_Aux1Down),
    JS_CFUNC_DEF("Aux2Down", 0, callback_method_Ozone_MouseEvent_Aux2Down),
    JS_CFUNC_DEF("LeftUp", 0, callback_method_Ozone_MouseEvent_LeftUp),
    JS_CFUNC_DEF("MiddleUp", 0, callback_method_Ozone_MouseEvent_MiddleUp),
    JS_CFUNC_DEF("RightUp", 0, callback_method_Ozone_MouseEvent_RightUp),
    JS_CFUNC_DEF("Aux1Up", 0, callback_method_Ozone_MouseEvent_Aux1Up),
    JS_CFUNC_DEF("Aux2Up", 0, callback_method_Ozone_MouseEvent_Aux2Up),
    JS_CFUNC_DEF("LeftDClick", 0, callback_method_Ozone_MouseEvent_LeftDClick),
    JS_CFUNC_DEF("MiddleDClick", 0, callback_method_Ozone_MouseEvent_MiddleDClick),
    JS_CFUNC_DEF("RightDClick", 0, callback_method_Ozone_MouseEvent_RightDClick),
    JS_CFUNC_DEF("Aux1DClick", 0, callback_method_Ozone_MouseEvent_Aux1DClick),
    JS_CFUNC_DEF("Aux2DClick", 0, callback_method_Ozone_MouseEvent_Aux2DClick),
    JS_CFUNC_DEF("Magnify", 0, callback_method_Ozone_MouseEvent_Magnify),
    JS_CFUNC_DEF("Dragging", 0, callback_method_Ozone_MouseEvent_Dragging),
    JS_CFUNC_DEF("Moving", 0, callback_method_Ozone_MouseEvent_Moving),
    JS_CFUNC_DEF("Entering", 0, callback_method_Ozone_MouseEvent_Entering),
    JS_CFUNC_DEF("Leaving", 0, callback_method_Ozone_MouseEvent_Leaving),
    JS_CFUNC_DEF("GetClickCount", 0, callback_method_Ozone_MouseEvent_GetClickCount),
    JS_CFUNC_DEF("GetLogicalPosition", 1, callback_method_Ozone_MouseEvent_GetLogicalPosition),
    JS_CFUNC_DEF("GetWheelRotation", 0, callback_method_Ozone_MouseEvent_GetWheelRotation),
    JS_CFUNC_DEF("GetWheelDelta", 0, callback_method_Ozone_MouseEvent_GetWheelDelta),
    JS_CFUNC_DEF("IsWheelInverted", 0, callback_method_Ozone_MouseEvent_IsWheelInverted),
    JS_CFUNC_DEF("GetWheelAxis", 0, callback_method_Ozone_MouseEvent_GetWheelAxis),
    JS_CFUNC_DEF("GetLinesPerAction", 0, callback_method_Ozone_MouseEvent_GetLinesPerAction),
    JS_CFUNC_DEF("GetColumnsPerAction", 0, callback_method_Ozone_MouseEvent_GetColumnsPerAction),
    JS_CFUNC_DEF("IsPageScroll", 0, callback_method_Ozone_MouseEvent_IsPageScroll),
    JS_CFUNC_DEF("GetMagnification", 0, callback_method_Ozone_MouseEvent_GetMagnification),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_MouseEvent_Clone),
    JS_CFUNC_DEF("GetEventCategory", 0, callback_method_Ozone_MouseEvent_GetEventCategory),
    JS_CFUNC_DEF("get_m_clickCount", 0, callback_method_Ozone_MouseEvent_get_m_clickCount),
    JS_CFUNC_DEF("set_m_clickCount", 1, callback_method_Ozone_MouseEvent_set_m_clickCount),
    JS_CFUNC_DEF("get_m_wheelAxis", 0, callback_method_Ozone_MouseEvent_get_m_wheelAxis),
    JS_CFUNC_DEF("set_m_wheelAxis", 1, callback_method_Ozone_MouseEvent_set_m_wheelAxis),
    JS_CFUNC_DEF("get_m_wheelRotation", 0, callback_method_Ozone_MouseEvent_get_m_wheelRotation),
    JS_CFUNC_DEF("set_m_wheelRotation", 1, callback_method_Ozone_MouseEvent_set_m_wheelRotation),
    JS_CFUNC_DEF("get_m_wheelDelta", 0, callback_method_Ozone_MouseEvent_get_m_wheelDelta),
    JS_CFUNC_DEF("set_m_wheelDelta", 1, callback_method_Ozone_MouseEvent_set_m_wheelDelta),
    JS_CFUNC_DEF("get_m_wheelInverted", 0, callback_method_Ozone_MouseEvent_get_m_wheelInverted),
    JS_CFUNC_DEF("set_m_wheelInverted", 1, callback_method_Ozone_MouseEvent_set_m_wheelInverted),
    JS_CFUNC_DEF("get_m_linesPerAction", 0, callback_method_Ozone_MouseEvent_get_m_linesPerAction),
    JS_CFUNC_DEF("set_m_linesPerAction", 1, callback_method_Ozone_MouseEvent_set_m_linesPerAction),
    JS_CFUNC_DEF("get_m_columnsPerAction", 0, callback_method_Ozone_MouseEvent_get_m_columnsPerAction),
    JS_CFUNC_DEF("set_m_columnsPerAction", 1, callback_method_Ozone_MouseEvent_set_m_columnsPerAction),
    JS_CFUNC_DEF("get_m_magnification", 0, callback_method_Ozone_MouseEvent_get_m_magnification),
    JS_CFUNC_DEF("set_m_magnification", 1, callback_method_Ozone_MouseEvent_set_m_magnification),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_MouseEvent_toString),
};

static void register_class_Ozone_MouseEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "MouseEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_MouseEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_MouseEvent, &classDef_Ozone_MouseEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_MouseEvent, sizeof(funcDef_Ozone_MouseEvent) / sizeof(funcDef_Ozone_MouseEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_MouseEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_MouseEvent_MouseEvent, "MouseEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "MouseEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_MouseEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_SetCursorEvent;

// Ozone::SetCursorEvent::SetCursorEvent
static JSValue callback_method_Ozone_SetCursorEvent_SetCursorEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SetCursorEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // SetCursorEvent(int x, int y)
overload0:
    {
        int x;
        int32_t _x;
        if (JS_ToInt32(ctx, &_x, argv[0]))
            return JS_EXCEPTION;
        x = (int)_x;
        auto __arg0 = x;

        int y;
        int32_t _y;
        if (JS_ToInt32(ctx, &_y, argv[1]))
            return JS_EXCEPTION;
        y = (int)_y;
        auto __arg1 = y;

        instance = new Ozone::SetCursorEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_SetCursorEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_SetCursorEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::SetCursorEvent::GetX
static JSValue callback_method_Ozone_SetCursorEvent_GetX(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SetCursorEvent* instance = (Ozone::SetCursorEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetX();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::SetCursorEvent::GetY
static JSValue callback_method_Ozone_SetCursorEvent_GetY(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SetCursorEvent* instance = (Ozone::SetCursorEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetY();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::SetCursorEvent::HasCursor
static JSValue callback_method_Ozone_SetCursorEvent_HasCursor(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SetCursorEvent* instance = (Ozone::SetCursorEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->HasCursor();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::SetCursorEvent::Clone
static JSValue callback_method_Ozone_SetCursorEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SetCursorEvent* instance = (Ozone::SetCursorEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_SetCursorEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "SetCursorEvent");
}

void finalizer_Ozone_SetCursorEvent(JSRuntime *rt, JSValue val)
{
    Ozone::SetCursorEvent* instance = (Ozone::SetCursorEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_SetCursorEvent
{
    "SetCursorEvent",
    .finalizer = finalizer_Ozone_SetCursorEvent
};

static JSCFunctionListEntry funcDef_Ozone_SetCursorEvent[]
{
    JS_CFUNC_DEF("GetX", 0, callback_method_Ozone_SetCursorEvent_GetX),
    JS_CFUNC_DEF("GetY", 0, callback_method_Ozone_SetCursorEvent_GetY),
    JS_CFUNC_DEF("HasCursor", 0, callback_method_Ozone_SetCursorEvent_HasCursor),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_SetCursorEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_SetCursorEvent_toString),
};

static void register_class_Ozone_SetCursorEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "SetCursorEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_SetCursorEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_SetCursorEvent, &classDef_Ozone_SetCursorEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_SetCursorEvent, sizeof(funcDef_Ozone_SetCursorEvent) / sizeof(funcDef_Ozone_SetCursorEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_SetCursorEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_SetCursorEvent_SetCursorEvent, "SetCursorEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "SetCursorEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_SetCursorEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_GestureEvent;

// Ozone::GestureEvent::GestureEvent
static JSValue callback_method_Ozone_GestureEvent_GestureEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::GestureEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // GestureEvent(int winid, int type)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        int type;
        int32_t _type;
        if (JS_ToInt32(ctx, &_type, argv[1]))
            return JS_EXCEPTION;
        type = (int)_type;
        auto __arg1 = type;

        instance = new Ozone::GestureEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GestureEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GestureEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::GestureEvent::SetPosition
static JSValue callback_method_Ozone_GestureEvent_SetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::GestureEvent* instance = (Ozone::GestureEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPosition(const ::Ozone::Point& pos)
overload0:
    {
        Ozone::Point* pos_instance = (Ozone::Point*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *pos_instance;

        instance->SetPosition(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GestureEvent::IsGestureStart
static JSValue callback_method_Ozone_GestureEvent_IsGestureStart(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::GestureEvent* instance = (Ozone::GestureEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsGestureStart();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::GestureEvent::SetGestureStart
static JSValue callback_method_Ozone_GestureEvent_SetGestureStart(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::GestureEvent* instance = (Ozone::GestureEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetGestureStart(bool isStart)
overload0:
    {
        bool isStart;
        isStart = JS_ToBool(ctx, argv[0]);
        if (isStart == -1)
            return JS_EXCEPTION;
        auto __arg0 = isStart;

        instance->SetGestureStart(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GestureEvent::IsGestureEnd
static JSValue callback_method_Ozone_GestureEvent_IsGestureEnd(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::GestureEvent* instance = (Ozone::GestureEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsGestureEnd();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::GestureEvent::SetGestureEnd
static JSValue callback_method_Ozone_GestureEvent_SetGestureEnd(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::GestureEvent* instance = (Ozone::GestureEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetGestureEnd(bool isEnd)
overload0:
    {
        bool isEnd;
        isEnd = JS_ToBool(ctx, argv[0]);
        if (isEnd == -1)
            return JS_EXCEPTION;
        auto __arg0 = isEnd;

        instance->SetGestureEnd(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GestureEvent::Clone
static JSValue callback_method_Ozone_GestureEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::GestureEvent* instance = (Ozone::GestureEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_GestureEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GestureEvent");
}

void finalizer_Ozone_GestureEvent(JSRuntime *rt, JSValue val)
{
    Ozone::GestureEvent* instance = (Ozone::GestureEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GestureEvent
{
    "GestureEvent",
    .finalizer = finalizer_Ozone_GestureEvent
};

static JSCFunctionListEntry funcDef_Ozone_GestureEvent[]
{
    JS_CFUNC_DEF("SetPosition", 1, callback_method_Ozone_GestureEvent_SetPosition),
    JS_CFUNC_DEF("IsGestureStart", 0, callback_method_Ozone_GestureEvent_IsGestureStart),
    JS_CFUNC_DEF("SetGestureStart", 1, callback_method_Ozone_GestureEvent_SetGestureStart),
    JS_CFUNC_DEF("IsGestureEnd", 0, callback_method_Ozone_GestureEvent_IsGestureEnd),
    JS_CFUNC_DEF("SetGestureEnd", 1, callback_method_Ozone_GestureEvent_SetGestureEnd),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_GestureEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GestureEvent_toString),
};

static void register_class_Ozone_GestureEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GestureEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GestureEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GestureEvent, &classDef_Ozone_GestureEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GestureEvent, sizeof(funcDef_Ozone_GestureEvent) / sizeof(funcDef_Ozone_GestureEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_GestureEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GestureEvent_GestureEvent, "GestureEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GestureEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_GestureEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_PanGestureEvent;

// Ozone::PanGestureEvent::PanGestureEvent
static JSValue callback_method_Ozone_PanGestureEvent_PanGestureEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PanGestureEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // PanGestureEvent(int winid)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        instance = new Ozone::PanGestureEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_PanGestureEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_PanGestureEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::PanGestureEvent::GetDelta
static JSValue callback_method_Ozone_PanGestureEvent_GetDelta(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PanGestureEvent* instance = (Ozone::PanGestureEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Point __ret = instance->GetDelta();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::PanGestureEvent::SetDelta
static JSValue callback_method_Ozone_PanGestureEvent_SetDelta(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PanGestureEvent* instance = (Ozone::PanGestureEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetDelta(const ::Ozone::Point& delta)
overload0:
    {
        Ozone::Point* delta_instance = (Ozone::Point*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *delta_instance;

        instance->SetDelta(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::PanGestureEvent::Clone
static JSValue callback_method_Ozone_PanGestureEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PanGestureEvent* instance = (Ozone::PanGestureEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_PanGestureEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "PanGestureEvent");
}

void finalizer_Ozone_PanGestureEvent(JSRuntime *rt, JSValue val)
{
    Ozone::PanGestureEvent* instance = (Ozone::PanGestureEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_PanGestureEvent
{
    "PanGestureEvent",
    .finalizer = finalizer_Ozone_PanGestureEvent
};

static JSCFunctionListEntry funcDef_Ozone_PanGestureEvent[]
{
    JS_CFUNC_DEF("GetDelta", 0, callback_method_Ozone_PanGestureEvent_GetDelta),
    JS_CFUNC_DEF("SetDelta", 1, callback_method_Ozone_PanGestureEvent_SetDelta),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_PanGestureEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_PanGestureEvent_toString),
};

static void register_class_Ozone_PanGestureEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "PanGestureEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_PanGestureEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_PanGestureEvent, &classDef_Ozone_PanGestureEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_PanGestureEvent, sizeof(funcDef_Ozone_PanGestureEvent) / sizeof(funcDef_Ozone_PanGestureEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_PanGestureEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_PanGestureEvent_PanGestureEvent, "PanGestureEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "PanGestureEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_PanGestureEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GestureEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_ZoomGestureEvent;

// Ozone::ZoomGestureEvent::ZoomGestureEvent
static JSValue callback_method_Ozone_ZoomGestureEvent_ZoomGestureEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ZoomGestureEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ZoomGestureEvent(int winid)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        instance = new Ozone::ZoomGestureEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_ZoomGestureEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_ZoomGestureEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::ZoomGestureEvent::GetZoomFactor
static JSValue callback_method_Ozone_ZoomGestureEvent_GetZoomFactor(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ZoomGestureEvent* instance = (Ozone::ZoomGestureEvent*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetZoomFactor();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::ZoomGestureEvent::SetZoomFactor
static JSValue callback_method_Ozone_ZoomGestureEvent_SetZoomFactor(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ZoomGestureEvent* instance = (Ozone::ZoomGestureEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsFloat(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetZoomFactor(double zoomFactor)
overload0:
    {
        double zoomFactor;
        if (JS_ToFloat64(ctx, &zoomFactor, argv[0]))
            return JS_EXCEPTION;
        auto __arg0 = zoomFactor;

        instance->SetZoomFactor(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::ZoomGestureEvent::Clone
static JSValue callback_method_Ozone_ZoomGestureEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ZoomGestureEvent* instance = (Ozone::ZoomGestureEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_ZoomGestureEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "ZoomGestureEvent");
}

void finalizer_Ozone_ZoomGestureEvent(JSRuntime *rt, JSValue val)
{
    Ozone::ZoomGestureEvent* instance = (Ozone::ZoomGestureEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_ZoomGestureEvent
{
    "ZoomGestureEvent",
    .finalizer = finalizer_Ozone_ZoomGestureEvent
};

static JSCFunctionListEntry funcDef_Ozone_ZoomGestureEvent[]
{
    JS_CFUNC_DEF("GetZoomFactor", 0, callback_method_Ozone_ZoomGestureEvent_GetZoomFactor),
    JS_CFUNC_DEF("SetZoomFactor", 1, callback_method_Ozone_ZoomGestureEvent_SetZoomFactor),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_ZoomGestureEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_ZoomGestureEvent_toString),
};

static void register_class_Ozone_ZoomGestureEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "ZoomGestureEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_ZoomGestureEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_ZoomGestureEvent, &classDef_Ozone_ZoomGestureEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_ZoomGestureEvent, sizeof(funcDef_Ozone_ZoomGestureEvent) / sizeof(funcDef_Ozone_ZoomGestureEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_ZoomGestureEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_ZoomGestureEvent_ZoomGestureEvent, "ZoomGestureEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "ZoomGestureEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_ZoomGestureEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GestureEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_RotateGestureEvent;

// Ozone::RotateGestureEvent::RotateGestureEvent
static JSValue callback_method_Ozone_RotateGestureEvent_RotateGestureEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::RotateGestureEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // RotateGestureEvent(int winid)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        instance = new Ozone::RotateGestureEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_RotateGestureEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_RotateGestureEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::RotateGestureEvent::GetRotationAngle
static JSValue callback_method_Ozone_RotateGestureEvent_GetRotationAngle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::RotateGestureEvent* instance = (Ozone::RotateGestureEvent*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetRotationAngle();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::RotateGestureEvent::SetRotationAngle
static JSValue callback_method_Ozone_RotateGestureEvent_SetRotationAngle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::RotateGestureEvent* instance = (Ozone::RotateGestureEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsFloat(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetRotationAngle(double rotationAngle)
overload0:
    {
        double rotationAngle;
        if (JS_ToFloat64(ctx, &rotationAngle, argv[0]))
            return JS_EXCEPTION;
        auto __arg0 = rotationAngle;

        instance->SetRotationAngle(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::RotateGestureEvent::Clone
static JSValue callback_method_Ozone_RotateGestureEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::RotateGestureEvent* instance = (Ozone::RotateGestureEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_RotateGestureEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "RotateGestureEvent");
}

void finalizer_Ozone_RotateGestureEvent(JSRuntime *rt, JSValue val)
{
    Ozone::RotateGestureEvent* instance = (Ozone::RotateGestureEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_RotateGestureEvent
{
    "RotateGestureEvent",
    .finalizer = finalizer_Ozone_RotateGestureEvent
};

static JSCFunctionListEntry funcDef_Ozone_RotateGestureEvent[]
{
    JS_CFUNC_DEF("GetRotationAngle", 0, callback_method_Ozone_RotateGestureEvent_GetRotationAngle),
    JS_CFUNC_DEF("SetRotationAngle", 1, callback_method_Ozone_RotateGestureEvent_SetRotationAngle),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_RotateGestureEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_RotateGestureEvent_toString),
};

static void register_class_Ozone_RotateGestureEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "RotateGestureEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_RotateGestureEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_RotateGestureEvent, &classDef_Ozone_RotateGestureEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_RotateGestureEvent, sizeof(funcDef_Ozone_RotateGestureEvent) / sizeof(funcDef_Ozone_RotateGestureEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_RotateGestureEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_RotateGestureEvent_RotateGestureEvent, "RotateGestureEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "RotateGestureEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_RotateGestureEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GestureEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_TwoFingerTapEvent;

// Ozone::TwoFingerTapEvent::TwoFingerTapEvent
static JSValue callback_method_Ozone_TwoFingerTapEvent_TwoFingerTapEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::TwoFingerTapEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // TwoFingerTapEvent(int winid)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        instance = new Ozone::TwoFingerTapEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_TwoFingerTapEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_TwoFingerTapEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::TwoFingerTapEvent::Clone
static JSValue callback_method_Ozone_TwoFingerTapEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::TwoFingerTapEvent* instance = (Ozone::TwoFingerTapEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_TwoFingerTapEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "TwoFingerTapEvent");
}

void finalizer_Ozone_TwoFingerTapEvent(JSRuntime *rt, JSValue val)
{
    Ozone::TwoFingerTapEvent* instance = (Ozone::TwoFingerTapEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_TwoFingerTapEvent
{
    "TwoFingerTapEvent",
    .finalizer = finalizer_Ozone_TwoFingerTapEvent
};

static JSCFunctionListEntry funcDef_Ozone_TwoFingerTapEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_TwoFingerTapEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_TwoFingerTapEvent_toString),
};

static void register_class_Ozone_TwoFingerTapEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "TwoFingerTapEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_TwoFingerTapEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_TwoFingerTapEvent, &classDef_Ozone_TwoFingerTapEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_TwoFingerTapEvent, sizeof(funcDef_Ozone_TwoFingerTapEvent) / sizeof(funcDef_Ozone_TwoFingerTapEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_TwoFingerTapEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_TwoFingerTapEvent_TwoFingerTapEvent, "TwoFingerTapEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "TwoFingerTapEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_TwoFingerTapEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GestureEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_LongPressEvent;

// Ozone::LongPressEvent::LongPressEvent
static JSValue callback_method_Ozone_LongPressEvent_LongPressEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::LongPressEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // LongPressEvent(int winid)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        instance = new Ozone::LongPressEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_LongPressEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_LongPressEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::LongPressEvent::Clone
static JSValue callback_method_Ozone_LongPressEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::LongPressEvent* instance = (Ozone::LongPressEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_LongPressEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "LongPressEvent");
}

void finalizer_Ozone_LongPressEvent(JSRuntime *rt, JSValue val)
{
    Ozone::LongPressEvent* instance = (Ozone::LongPressEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_LongPressEvent
{
    "LongPressEvent",
    .finalizer = finalizer_Ozone_LongPressEvent
};

static JSCFunctionListEntry funcDef_Ozone_LongPressEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_LongPressEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_LongPressEvent_toString),
};

static void register_class_Ozone_LongPressEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "LongPressEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_LongPressEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_LongPressEvent, &classDef_Ozone_LongPressEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_LongPressEvent, sizeof(funcDef_Ozone_LongPressEvent) / sizeof(funcDef_Ozone_LongPressEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_LongPressEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_LongPressEvent_LongPressEvent, "LongPressEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "LongPressEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_LongPressEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GestureEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_PressAndTapEvent;

// Ozone::PressAndTapEvent::PressAndTapEvent
static JSValue callback_method_Ozone_PressAndTapEvent_PressAndTapEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PressAndTapEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // PressAndTapEvent(int winid)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        instance = new Ozone::PressAndTapEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_PressAndTapEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_PressAndTapEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::PressAndTapEvent::Clone
static JSValue callback_method_Ozone_PressAndTapEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PressAndTapEvent* instance = (Ozone::PressAndTapEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_PressAndTapEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "PressAndTapEvent");
}

void finalizer_Ozone_PressAndTapEvent(JSRuntime *rt, JSValue val)
{
    Ozone::PressAndTapEvent* instance = (Ozone::PressAndTapEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_PressAndTapEvent
{
    "PressAndTapEvent",
    .finalizer = finalizer_Ozone_PressAndTapEvent
};

static JSCFunctionListEntry funcDef_Ozone_PressAndTapEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_PressAndTapEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_PressAndTapEvent_toString),
};

static void register_class_Ozone_PressAndTapEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "PressAndTapEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_PressAndTapEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_PressAndTapEvent, &classDef_Ozone_PressAndTapEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_PressAndTapEvent, sizeof(funcDef_Ozone_PressAndTapEvent) / sizeof(funcDef_Ozone_PressAndTapEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_PressAndTapEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_PressAndTapEvent_PressAndTapEvent, "PressAndTapEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "PressAndTapEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_PressAndTapEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GestureEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_KeyEvent;

// Ozone::KeyEvent::KeyEvent
static JSValue callback_method_Ozone_KeyEvent_KeyEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // KeyEvent(int keyType)
overload0:
    {
        int keyType;
        int32_t _keyType;
        if (JS_ToInt32(ctx, &_keyType, argv[0]))
            return JS_EXCEPTION;
        keyType = (int)_keyType;
        auto __arg0 = keyType;

        instance = new Ozone::KeyEvent(__arg0);

        goto wrap;
    }

    // KeyEvent(int eventType, const ::Ozone::KeyEvent& evt)
overload1:
    {
        int eventType;
        int32_t _eventType;
        if (JS_ToInt32(ctx, &_eventType, argv[0]))
            return JS_EXCEPTION;
        eventType = (int)_eventType;
        auto __arg0 = eventType;

        Ozone::KeyEvent* evt_instance = (Ozone::KeyEvent*) JS_Interop_GetInstance(argv[1], \
            classId_Ozone_KeyEvent, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *evt_instance;

        instance = new Ozone::KeyEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_KeyEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_KeyEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::KeyEvent::GetKeyCode
static JSValue callback_method_Ozone_KeyEvent_GetKeyCode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetKeyCode();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::IsKeyInCategory
static JSValue callback_method_Ozone_KeyEvent_IsKeyInCategory(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool IsKeyInCategory(int category) const
overload0:
    {
        int category;
        int32_t _category;
        if (JS_ToInt32(ctx, &_category, argv[0]))
            return JS_EXCEPTION;
        category = (int)_category;
        auto __arg0 = category;

        bool __ret = instance->IsKeyInCategory(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::KeyEvent::GetUnicodeKey
static JSValue callback_method_Ozone_KeyEvent_GetUnicodeKey(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    wchar_t __ret = instance->GetUnicodeKey();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::GetRawKeyCode
static JSValue callback_method_Ozone_KeyEvent_GetRawKeyCode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    unsigned int __ret = instance->GetRawKeyCode();

    JSValue ____ret = JS_NewUint32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::GetRawKeyFlags
static JSValue callback_method_Ozone_KeyEvent_GetRawKeyFlags(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    unsigned int __ret = instance->GetRawKeyFlags();

    JSValue ____ret = JS_NewUint32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::GetPosition
static JSValue callback_method_Ozone_KeyEvent_GetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Point __ret = instance->GetPosition();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::KeyEvent::GetX
static JSValue callback_method_Ozone_KeyEvent_GetX(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetX();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::GetY
static JSValue callback_method_Ozone_KeyEvent_GetY(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetY();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::DoAllowNextEvent
static JSValue callback_method_Ozone_KeyEvent_DoAllowNextEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    instance->DoAllowNextEvent();

    return JS_UNDEFINED;
}

// Ozone::KeyEvent::IsNextEventAllowed
static JSValue callback_method_Ozone_KeyEvent_IsNextEventAllowed(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsNextEventAllowed();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::Clone
static JSValue callback_method_Ozone_KeyEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::KeyEvent::GetEventCategory
static JSValue callback_method_Ozone_KeyEvent_GetEventCategory(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::EventCategory __ret = instance->GetEventCategory();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::KeyEvent::get_m_x
static JSValue callback_method_Ozone_KeyEvent_get_m_x(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_m_x();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::set_m_x
static JSValue callback_method_Ozone_KeyEvent_set_m_x(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_x(int value)
overload0:
    {
        int value;
        int32_t _value;
        if (JS_ToInt32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (int)_value;
        auto __arg0 = value;

        instance->set_m_x(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::KeyEvent::get_m_y
static JSValue callback_method_Ozone_KeyEvent_get_m_y(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->get_m_y();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::set_m_y
static JSValue callback_method_Ozone_KeyEvent_set_m_y(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_y(int value)
overload0:
    {
        int value;
        int32_t _value;
        if (JS_ToInt32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (int)_value;
        auto __arg0 = value;

        instance->set_m_y(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::KeyEvent::get_m_keyCode
static JSValue callback_method_Ozone_KeyEvent_get_m_keyCode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    long __ret = instance->get_m_keyCode();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::set_m_keyCode
static JSValue callback_method_Ozone_KeyEvent_set_m_keyCode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_keyCode(long value)
overload0:
    {
        long value;
        int32_t _value;
        if (JS_ToInt32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (long)_value;
        auto __arg0 = value;

        instance->set_m_keyCode(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::KeyEvent::get_m_uniChar
static JSValue callback_method_Ozone_KeyEvent_get_m_uniChar(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    wchar_t __ret = instance->get_m_uniChar();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::set_m_uniChar
static JSValue callback_method_Ozone_KeyEvent_set_m_uniChar(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsUInt16(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_uniChar(wchar_t value)
overload0:
    {
        wchar_t value;
        int32_t _value;
        if (JS_ToInt32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (wchar_t)_value;
        auto __arg0 = value;

        instance->set_m_uniChar(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::KeyEvent::get_m_rawCode
static JSValue callback_method_Ozone_KeyEvent_get_m_rawCode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    unsigned int __ret = instance->get_m_rawCode();

    JSValue ____ret = JS_NewUint32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::set_m_rawCode
static JSValue callback_method_Ozone_KeyEvent_set_m_rawCode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsUInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_rawCode(unsigned int value)
overload0:
    {
        unsigned int value;
        uint32_t _value;
        if (JS_ToUint32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (unsigned int)_value;
        auto __arg0 = value;

        instance->set_m_rawCode(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::KeyEvent::get_m_rawFlags
static JSValue callback_method_Ozone_KeyEvent_get_m_rawFlags(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    unsigned int __ret = instance->get_m_rawFlags();

    JSValue ____ret = JS_NewUint32(ctx, __ret);

    return ____ret;
}

// Ozone::KeyEvent::set_m_rawFlags
static JSValue callback_method_Ozone_KeyEvent_set_m_rawFlags(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsUInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_rawFlags(unsigned int value)
overload0:
    {
        unsigned int value;
        uint32_t _value;
        if (JS_ToUint32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (unsigned int)_value;
        auto __arg0 = value;

        instance->set_m_rawFlags(__arg0);

        return JS_UNDEFINED;
    }
}

static JSValue callback_class_Ozone_KeyEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "KeyEvent");
}

void finalizer_Ozone_KeyEvent(JSRuntime *rt, JSValue val)
{
    Ozone::KeyEvent* instance = (Ozone::KeyEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_KeyEvent
{
    "KeyEvent",
    .finalizer = finalizer_Ozone_KeyEvent
};

static JSCFunctionListEntry funcDef_Ozone_KeyEvent[]
{
    JS_CFUNC_DEF("GetKeyCode", 0, callback_method_Ozone_KeyEvent_GetKeyCode),
    JS_CFUNC_DEF("IsKeyInCategory", 1, callback_method_Ozone_KeyEvent_IsKeyInCategory),
    JS_CFUNC_DEF("GetUnicodeKey", 0, callback_method_Ozone_KeyEvent_GetUnicodeKey),
    JS_CFUNC_DEF("GetRawKeyCode", 0, callback_method_Ozone_KeyEvent_GetRawKeyCode),
    JS_CFUNC_DEF("GetRawKeyFlags", 0, callback_method_Ozone_KeyEvent_GetRawKeyFlags),
    JS_CFUNC_DEF("GetPosition", 0, callback_method_Ozone_KeyEvent_GetPosition),
    JS_CFUNC_DEF("GetX", 0, callback_method_Ozone_KeyEvent_GetX),
    JS_CFUNC_DEF("GetY", 0, callback_method_Ozone_KeyEvent_GetY),
    JS_CFUNC_DEF("DoAllowNextEvent", 0, callback_method_Ozone_KeyEvent_DoAllowNextEvent),
    JS_CFUNC_DEF("IsNextEventAllowed", 0, callback_method_Ozone_KeyEvent_IsNextEventAllowed),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_KeyEvent_Clone),
    JS_CFUNC_DEF("GetEventCategory", 0, callback_method_Ozone_KeyEvent_GetEventCategory),
    JS_CFUNC_DEF("get_m_x", 0, callback_method_Ozone_KeyEvent_get_m_x),
    JS_CFUNC_DEF("set_m_x", 1, callback_method_Ozone_KeyEvent_set_m_x),
    JS_CFUNC_DEF("get_m_y", 0, callback_method_Ozone_KeyEvent_get_m_y),
    JS_CFUNC_DEF("set_m_y", 1, callback_method_Ozone_KeyEvent_set_m_y),
    JS_CFUNC_DEF("get_m_keyCode", 0, callback_method_Ozone_KeyEvent_get_m_keyCode),
    JS_CFUNC_DEF("set_m_keyCode", 1, callback_method_Ozone_KeyEvent_set_m_keyCode),
    JS_CFUNC_DEF("get_m_uniChar", 0, callback_method_Ozone_KeyEvent_get_m_uniChar),
    JS_CFUNC_DEF("set_m_uniChar", 1, callback_method_Ozone_KeyEvent_set_m_uniChar),
    JS_CFUNC_DEF("get_m_rawCode", 0, callback_method_Ozone_KeyEvent_get_m_rawCode),
    JS_CFUNC_DEF("set_m_rawCode", 1, callback_method_Ozone_KeyEvent_set_m_rawCode),
    JS_CFUNC_DEF("get_m_rawFlags", 0, callback_method_Ozone_KeyEvent_get_m_rawFlags),
    JS_CFUNC_DEF("set_m_rawFlags", 1, callback_method_Ozone_KeyEvent_set_m_rawFlags),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_KeyEvent_toString),
};

static void register_class_Ozone_KeyEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "KeyEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_KeyEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_KeyEvent, &classDef_Ozone_KeyEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_KeyEvent, sizeof(funcDef_Ozone_KeyEvent) / sizeof(funcDef_Ozone_KeyEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_KeyEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_KeyEvent_KeyEvent, "KeyEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "KeyEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_KeyEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_SizeEvent;

// Ozone::SizeEvent::SizeEvent
static JSValue callback_method_Ozone_SizeEvent_SizeEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SizeEvent* instance;

    if (argc == 0)
        goto overload0;

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto overload1;

    goto error;

typecheck2:
    if (JS_IsInt32(argv[1]))
        goto overload2;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // SizeEvent()
overload0:
    {
        instance = new Ozone::SizeEvent();

        goto wrap;
    }

    // SizeEvent(const ::Ozone::Size& sz, int winid)
overload1:
    {
        Ozone::Size* sz_instance = (Ozone::Size*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *sz_instance;

        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[1]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg1 = winid;

        instance = new Ozone::SizeEvent(__arg0, __arg1);

        goto wrap;
    }

    // SizeEvent(const ::Ozone::Rect& rect, int id)
overload2:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Rect, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *rect_instance;

        int id;
        int32_t _id;
        if (JS_ToInt32(ctx, &_id, argv[1]))
            return JS_EXCEPTION;
        id = (int)_id;
        auto __arg1 = id;

        instance = new Ozone::SizeEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_SizeEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_SizeEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::SizeEvent::GetSize
static JSValue callback_method_Ozone_SizeEvent_GetSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SizeEvent* instance = (Ozone::SizeEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetSize();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizeEvent::SetSize
static JSValue callback_method_Ozone_SizeEvent_SetSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SizeEvent* instance = (Ozone::SizeEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetSize(::Ozone::Size size)
overload0:
    {
        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = *size_instance;

        instance->SetSize(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizeEvent::GetRect
static JSValue callback_method_Ozone_SizeEvent_GetRect(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SizeEvent* instance = (Ozone::SizeEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Rect __ret = instance->GetRect();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Rect, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizeEvent::SetRect
static JSValue callback_method_Ozone_SizeEvent_SetRect(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SizeEvent* instance = (Ozone::SizeEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetRect(const ::Ozone::Rect& rect)
overload0:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Rect, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *rect_instance;

        instance->SetRect(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizeEvent::Clone
static JSValue callback_method_Ozone_SizeEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SizeEvent* instance = (Ozone::SizeEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::SizeEvent::get_m_size
static JSValue callback_method_Ozone_SizeEvent_get_m_size(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SizeEvent* instance = (Ozone::SizeEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->get_m_size();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizeEvent::set_m_size
static JSValue callback_method_Ozone_SizeEvent_set_m_size(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SizeEvent* instance = (Ozone::SizeEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_size(::Ozone::Size value)
overload0:
    {
        Ozone::Size* value_instance = (Ozone::Size*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = *value_instance;

        instance->set_m_size(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizeEvent::get_m_rect
static JSValue callback_method_Ozone_SizeEvent_get_m_rect(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SizeEvent* instance = (Ozone::SizeEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Rect __ret = instance->get_m_rect();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Rect, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizeEvent::set_m_rect
static JSValue callback_method_Ozone_SizeEvent_set_m_rect(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SizeEvent* instance = (Ozone::SizeEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_rect(::Ozone::Rect value)
overload0:
    {
        Ozone::Rect* value_instance = (Ozone::Rect*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Rect, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = *value_instance;

        instance->set_m_rect(__arg0);

        return JS_UNDEFINED;
    }
}

static JSValue callback_class_Ozone_SizeEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "SizeEvent");
}

void finalizer_Ozone_SizeEvent(JSRuntime *rt, JSValue val)
{
    Ozone::SizeEvent* instance = (Ozone::SizeEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_SizeEvent
{
    "SizeEvent",
    .finalizer = finalizer_Ozone_SizeEvent
};

static JSCFunctionListEntry funcDef_Ozone_SizeEvent[]
{
    JS_CFUNC_DEF("GetSize", 0, callback_method_Ozone_SizeEvent_GetSize),
    JS_CFUNC_DEF("SetSize", 1, callback_method_Ozone_SizeEvent_SetSize),
    JS_CFUNC_DEF("GetRect", 0, callback_method_Ozone_SizeEvent_GetRect),
    JS_CFUNC_DEF("SetRect", 1, callback_method_Ozone_SizeEvent_SetRect),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_SizeEvent_Clone),
    JS_CFUNC_DEF("get_m_size", 0, callback_method_Ozone_SizeEvent_get_m_size),
    JS_CFUNC_DEF("set_m_size", 1, callback_method_Ozone_SizeEvent_set_m_size),
    JS_CFUNC_DEF("get_m_rect", 0, callback_method_Ozone_SizeEvent_get_m_rect),
    JS_CFUNC_DEF("set_m_rect", 1, callback_method_Ozone_SizeEvent_set_m_rect),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_SizeEvent_toString),
};

static void register_class_Ozone_SizeEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "SizeEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_SizeEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_SizeEvent, &classDef_Ozone_SizeEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_SizeEvent, sizeof(funcDef_Ozone_SizeEvent) / sizeof(funcDef_Ozone_SizeEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_SizeEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_SizeEvent_SizeEvent, "SizeEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "SizeEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_SizeEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_MoveEvent;

// Ozone::MoveEvent::MoveEvent
static JSValue callback_method_Ozone_MoveEvent_MoveEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MoveEvent* instance;

    if (argc == 0)
        goto overload0;

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto overload1;

    goto error;

typecheck2:
    if (JS_IsInt32(argv[1]))
        goto overload2;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // MoveEvent()
overload0:
    {
        instance = new Ozone::MoveEvent();

        goto wrap;
    }

    // MoveEvent(const ::Ozone::Point& pos, int winid)
overload1:
    {
        Ozone::Point* pos_instance = (Ozone::Point*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *pos_instance;

        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[1]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg1 = winid;

        instance = new Ozone::MoveEvent(__arg0, __arg1);

        goto wrap;
    }

    // MoveEvent(const ::Ozone::Rect& rect, int id)
overload2:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Rect, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *rect_instance;

        int id;
        int32_t _id;
        if (JS_ToInt32(ctx, &_id, argv[1]))
            return JS_EXCEPTION;
        id = (int)_id;
        auto __arg1 = id;

        instance = new Ozone::MoveEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_MoveEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_MoveEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::MoveEvent::GetPosition
static JSValue callback_method_Ozone_MoveEvent_GetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MoveEvent* instance = (Ozone::MoveEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Point __ret = instance->GetPosition();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::MoveEvent::SetPosition
static JSValue callback_method_Ozone_MoveEvent_SetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MoveEvent* instance = (Ozone::MoveEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPosition(const ::Ozone::Point& pos)
overload0:
    {
        Ozone::Point* pos_instance = (Ozone::Point*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *pos_instance;

        instance->SetPosition(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::MoveEvent::GetRect
static JSValue callback_method_Ozone_MoveEvent_GetRect(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MoveEvent* instance = (Ozone::MoveEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Rect __ret = instance->GetRect();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Rect, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::MoveEvent::SetRect
static JSValue callback_method_Ozone_MoveEvent_SetRect(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MoveEvent* instance = (Ozone::MoveEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetRect(const ::Ozone::Rect& rect)
overload0:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Rect, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *rect_instance;

        instance->SetRect(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::MoveEvent::Clone
static JSValue callback_method_Ozone_MoveEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MoveEvent* instance = (Ozone::MoveEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_MoveEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "MoveEvent");
}

void finalizer_Ozone_MoveEvent(JSRuntime *rt, JSValue val)
{
    Ozone::MoveEvent* instance = (Ozone::MoveEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_MoveEvent
{
    "MoveEvent",
    .finalizer = finalizer_Ozone_MoveEvent
};

static JSCFunctionListEntry funcDef_Ozone_MoveEvent[]
{
    JS_CFUNC_DEF("GetPosition", 0, callback_method_Ozone_MoveEvent_GetPosition),
    JS_CFUNC_DEF("SetPosition", 1, callback_method_Ozone_MoveEvent_SetPosition),
    JS_CFUNC_DEF("GetRect", 0, callback_method_Ozone_MoveEvent_GetRect),
    JS_CFUNC_DEF("SetRect", 1, callback_method_Ozone_MoveEvent_SetRect),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_MoveEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_MoveEvent_toString),
};

static void register_class_Ozone_MoveEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "MoveEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_MoveEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_MoveEvent, &classDef_Ozone_MoveEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_MoveEvent, sizeof(funcDef_Ozone_MoveEvent) / sizeof(funcDef_Ozone_MoveEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_MoveEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_MoveEvent_MoveEvent, "MoveEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "MoveEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_MoveEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_PaintEvent;

// Ozone::PaintEvent::Clone
static JSValue callback_method_Ozone_PaintEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PaintEvent* instance = (Ozone::PaintEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_PaintEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "PaintEvent");
}

void finalizer_Ozone_PaintEvent(JSRuntime *rt, JSValue val)
{
    Ozone::PaintEvent* instance = (Ozone::PaintEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_PaintEvent
{
    "PaintEvent",
    .finalizer = finalizer_Ozone_PaintEvent
};

static JSCFunctionListEntry funcDef_Ozone_PaintEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_PaintEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_PaintEvent_toString),
};

static void register_class_Ozone_PaintEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "PaintEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_PaintEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_PaintEvent, &classDef_Ozone_PaintEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_PaintEvent, sizeof(funcDef_Ozone_PaintEvent) / sizeof(funcDef_Ozone_PaintEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_PaintEvent, proto);

    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_PaintEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_NcPaintEvent;

// Ozone::NcPaintEvent::Clone
static JSValue callback_method_Ozone_NcPaintEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NcPaintEvent* instance = (Ozone::NcPaintEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_NcPaintEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "NcPaintEvent");
}

void finalizer_Ozone_NcPaintEvent(JSRuntime *rt, JSValue val)
{
    Ozone::NcPaintEvent* instance = (Ozone::NcPaintEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_NcPaintEvent
{
    "NcPaintEvent",
    .finalizer = finalizer_Ozone_NcPaintEvent
};

static JSCFunctionListEntry funcDef_Ozone_NcPaintEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_NcPaintEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_NcPaintEvent_toString),
};

static void register_class_Ozone_NcPaintEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "NcPaintEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_NcPaintEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_NcPaintEvent, &classDef_Ozone_NcPaintEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_NcPaintEvent, sizeof(funcDef_Ozone_NcPaintEvent) / sizeof(funcDef_Ozone_NcPaintEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_NcPaintEvent, proto);

    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_NcPaintEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_EraseEvent;

// Ozone::EraseEvent::EraseEvent
static JSValue callback_method_Ozone_EraseEvent_EraseEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EraseEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]) || JS_IsNull(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // EraseEvent(int Id, ::Ozone::DC* dc)
overload0:
    {
        int Id;
        int32_t _Id;
        if (JS_ToInt32(ctx, &_Id, argv[0]))
            return JS_EXCEPTION;
        Id = (int)_Id;
        auto __arg0 = Id;

        Ozone::DC* dc_instance = (Ozone::DC*) JS_Interop_GetInstance(argv[1], \
            classId_Ozone_DC, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg1 = dc_instance;

        instance = new Ozone::EraseEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_EraseEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_EraseEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::EraseEvent::GetDC
static JSValue callback_method_Ozone_EraseEvent_GetDC(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EraseEvent* instance = (Ozone::EraseEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::DC* __ret = instance->GetDC();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_DC, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::EraseEvent::Clone
static JSValue callback_method_Ozone_EraseEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EraseEvent* instance = (Ozone::EraseEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_EraseEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "EraseEvent");
}

void finalizer_Ozone_EraseEvent(JSRuntime *rt, JSValue val)
{
    Ozone::EraseEvent* instance = (Ozone::EraseEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_EraseEvent
{
    "EraseEvent",
    .finalizer = finalizer_Ozone_EraseEvent
};

static JSCFunctionListEntry funcDef_Ozone_EraseEvent[]
{
    JS_CFUNC_DEF("GetDC", 0, callback_method_Ozone_EraseEvent_GetDC),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_EraseEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_EraseEvent_toString),
};

static void register_class_Ozone_EraseEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "EraseEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_EraseEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_EraseEvent, &classDef_Ozone_EraseEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_EraseEvent, sizeof(funcDef_Ozone_EraseEvent) / sizeof(funcDef_Ozone_EraseEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_EraseEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_EraseEvent_EraseEvent, "EraseEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "EraseEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_EraseEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_FocusEvent;

// Ozone::FocusEvent::FocusEvent
static JSValue callback_method_Ozone_FocusEvent_FocusEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::FocusEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // FocusEvent(int type, int winid)
overload0:
    {
        int type;
        int32_t _type;
        if (JS_ToInt32(ctx, &_type, argv[0]))
            return JS_EXCEPTION;
        type = (int)_type;
        auto __arg0 = type;

        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[1]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg1 = winid;

        instance = new Ozone::FocusEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_FocusEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_FocusEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::FocusEvent::GetWindow
static JSValue callback_method_Ozone_FocusEvent_GetWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::FocusEvent* instance = (Ozone::FocusEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->GetWindow();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT, (void*) __ret);

    return ____ret;
}

// Ozone::FocusEvent::SetWindow
static JSValue callback_method_Ozone_FocusEvent_SetWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::FocusEvent* instance = (Ozone::FocusEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetWindow(::Ozone::Window* win)
overload0:
    {
        Ozone::Window* win_instance = (Ozone::Window*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = win_instance;

        instance->SetWindow(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::FocusEvent::Clone
static JSValue callback_method_Ozone_FocusEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::FocusEvent* instance = (Ozone::FocusEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_FocusEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "FocusEvent");
}

void finalizer_Ozone_FocusEvent(JSRuntime *rt, JSValue val)
{
    Ozone::FocusEvent* instance = (Ozone::FocusEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_FocusEvent
{
    "FocusEvent",
    .finalizer = finalizer_Ozone_FocusEvent
};

static JSCFunctionListEntry funcDef_Ozone_FocusEvent[]
{
    JS_CFUNC_DEF("GetWindow", 0, callback_method_Ozone_FocusEvent_GetWindow),
    JS_CFUNC_DEF("SetWindow", 1, callback_method_Ozone_FocusEvent_SetWindow),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_FocusEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_FocusEvent_toString),
};

static void register_class_Ozone_FocusEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "FocusEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_FocusEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_FocusEvent, &classDef_Ozone_FocusEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_FocusEvent, sizeof(funcDef_Ozone_FocusEvent) / sizeof(funcDef_Ozone_FocusEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_FocusEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_FocusEvent_FocusEvent, "FocusEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "FocusEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_FocusEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_ChildFocusEvent;

// Ozone::ChildFocusEvent::ChildFocusEvent
static JSValue callback_method_Ozone_ChildFocusEvent_ChildFocusEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ChildFocusEvent* instance;

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ChildFocusEvent(::Ozone::Window* win)
overload0:
    {
        Ozone::Window* win_instance = (Ozone::Window*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = win_instance;

        instance = new Ozone::ChildFocusEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_ChildFocusEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_ChildFocusEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::ChildFocusEvent::GetWindow
static JSValue callback_method_Ozone_ChildFocusEvent_GetWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ChildFocusEvent* instance = (Ozone::ChildFocusEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->GetWindow();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT, (void*) __ret);

    return ____ret;
}

// Ozone::ChildFocusEvent::Clone
static JSValue callback_method_Ozone_ChildFocusEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ChildFocusEvent* instance = (Ozone::ChildFocusEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_ChildFocusEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "ChildFocusEvent");
}

void finalizer_Ozone_ChildFocusEvent(JSRuntime *rt, JSValue val)
{
    Ozone::ChildFocusEvent* instance = (Ozone::ChildFocusEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_ChildFocusEvent
{
    "ChildFocusEvent",
    .finalizer = finalizer_Ozone_ChildFocusEvent
};

static JSCFunctionListEntry funcDef_Ozone_ChildFocusEvent[]
{
    JS_CFUNC_DEF("GetWindow", 0, callback_method_Ozone_ChildFocusEvent_GetWindow),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_ChildFocusEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_ChildFocusEvent_toString),
};

static void register_class_Ozone_ChildFocusEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "ChildFocusEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_ChildFocusEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_ChildFocusEvent, &classDef_Ozone_ChildFocusEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_ChildFocusEvent, sizeof(funcDef_Ozone_ChildFocusEvent) / sizeof(funcDef_Ozone_ChildFocusEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_ChildFocusEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_ChildFocusEvent_ChildFocusEvent, "ChildFocusEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "ChildFocusEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_ChildFocusEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_CommandEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_ActivateEvent;

enum class Reason : unsigned int
{
    Mouse = 0,
    Unknown = 1
};

// Ozone::ActivateEvent::ActivateEvent
static JSValue callback_method_Ozone_ActivateEvent_ActivateEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 4)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ActivateEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsBool(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsInt32(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsInt32(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ActivateEvent(int type, bool active, int Id, ::Ozone::ActivateEvent::Reason activationReason)
overload0:
    {
        int type;
        int32_t _type;
        if (JS_ToInt32(ctx, &_type, argv[0]))
            return JS_EXCEPTION;
        type = (int)_type;
        auto __arg0 = type;

        bool active;
        active = JS_ToBool(ctx, argv[1]);
        if (active == -1)
            return JS_EXCEPTION;
        auto __arg1 = active;

        int Id;
        int32_t _Id;
        if (JS_ToInt32(ctx, &_Id, argv[2]))
            return JS_EXCEPTION;
        Id = (int)_Id;
        auto __arg2 = Id;

        unsigned int activationReason;
        uint32_t _activationReason;
        if (JS_ToUint32(ctx, &_activationReason, argv[3]))
            return JS_EXCEPTION;
        activationReason = (unsigned int)_activationReason;
        auto __arg3 = (::Ozone::ActivateEvent::Reason)activationReason;

        instance = new Ozone::ActivateEvent(__arg0, __arg1, __arg2, __arg3);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_ActivateEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_ActivateEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::ActivateEvent::GetActive
static JSValue callback_method_Ozone_ActivateEvent_GetActive(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ActivateEvent* instance = (Ozone::ActivateEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetActive();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::ActivateEvent::GetActivationReason
static JSValue callback_method_Ozone_ActivateEvent_GetActivationReason(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ActivateEvent* instance = (Ozone::ActivateEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::ActivateEvent::Reason __ret = instance->GetActivationReason();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::ActivateEvent::Clone
static JSValue callback_method_Ozone_ActivateEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ActivateEvent* instance = (Ozone::ActivateEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_ActivateEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "ActivateEvent");
}

void finalizer_Ozone_ActivateEvent(JSRuntime *rt, JSValue val)
{
    Ozone::ActivateEvent* instance = (Ozone::ActivateEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_ActivateEvent
{
    "ActivateEvent",
    .finalizer = finalizer_Ozone_ActivateEvent
};

static JSCFunctionListEntry funcDef_Ozone_ActivateEvent[]
{
    JS_CFUNC_DEF("GetActive", 0, callback_method_Ozone_ActivateEvent_GetActive),
    JS_CFUNC_DEF("GetActivationReason", 0, callback_method_Ozone_ActivateEvent_GetActivationReason),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_ActivateEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_ActivateEvent_toString),
};

static void register_class_Ozone_ActivateEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "ActivateEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_ActivateEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_ActivateEvent, &classDef_Ozone_ActivateEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_ActivateEvent, sizeof(funcDef_Ozone_ActivateEvent) / sizeof(funcDef_Ozone_ActivateEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_ActivateEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_ActivateEvent_ActivateEvent, "ActivateEvent", 4, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "ActivateEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_ActivateEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_InitDialogEvent;

// Ozone::InitDialogEvent::InitDialogEvent
static JSValue callback_method_Ozone_InitDialogEvent_InitDialogEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::InitDialogEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // InitDialogEvent(int Id)
overload0:
    {
        int Id;
        int32_t _Id;
        if (JS_ToInt32(ctx, &_Id, argv[0]))
            return JS_EXCEPTION;
        Id = (int)_Id;
        auto __arg0 = Id;

        instance = new Ozone::InitDialogEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_InitDialogEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_InitDialogEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::InitDialogEvent::Clone
static JSValue callback_method_Ozone_InitDialogEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::InitDialogEvent* instance = (Ozone::InitDialogEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_InitDialogEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "InitDialogEvent");
}

void finalizer_Ozone_InitDialogEvent(JSRuntime *rt, JSValue val)
{
    Ozone::InitDialogEvent* instance = (Ozone::InitDialogEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_InitDialogEvent
{
    "InitDialogEvent",
    .finalizer = finalizer_Ozone_InitDialogEvent
};

static JSCFunctionListEntry funcDef_Ozone_InitDialogEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_InitDialogEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_InitDialogEvent_toString),
};

static void register_class_Ozone_InitDialogEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "InitDialogEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_InitDialogEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_InitDialogEvent, &classDef_Ozone_InitDialogEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_InitDialogEvent, sizeof(funcDef_Ozone_InitDialogEvent) / sizeof(funcDef_Ozone_InitDialogEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_InitDialogEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_InitDialogEvent_InitDialogEvent, "InitDialogEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "InitDialogEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_InitDialogEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_MenuEvent;

// Ozone::MenuEvent::GetMenuId
static JSValue callback_method_Ozone_MenuEvent_GetMenuId(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MenuEvent* instance = (Ozone::MenuEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetMenuId();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::MenuEvent::IsPopup
static JSValue callback_method_Ozone_MenuEvent_IsPopup(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MenuEvent* instance = (Ozone::MenuEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsPopup();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::MenuEvent::Clone
static JSValue callback_method_Ozone_MenuEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MenuEvent* instance = (Ozone::MenuEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_MenuEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "MenuEvent");
}

void finalizer_Ozone_MenuEvent(JSRuntime *rt, JSValue val)
{
    Ozone::MenuEvent* instance = (Ozone::MenuEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_MenuEvent
{
    "MenuEvent",
    .finalizer = finalizer_Ozone_MenuEvent
};

static JSCFunctionListEntry funcDef_Ozone_MenuEvent[]
{
    JS_CFUNC_DEF("GetMenuId", 0, callback_method_Ozone_MenuEvent_GetMenuId),
    JS_CFUNC_DEF("IsPopup", 0, callback_method_Ozone_MenuEvent_IsPopup),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_MenuEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_MenuEvent_toString),
};

static void register_class_Ozone_MenuEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "MenuEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_MenuEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_MenuEvent, &classDef_Ozone_MenuEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_MenuEvent, sizeof(funcDef_Ozone_MenuEvent) / sizeof(funcDef_Ozone_MenuEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_MenuEvent, proto);

    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_MenuEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_CloseEvent;

// Ozone::CloseEvent::CloseEvent
static JSValue callback_method_Ozone_CloseEvent_CloseEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CloseEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // CloseEvent(int type, int winid)
overload0:
    {
        int type;
        int32_t _type;
        if (JS_ToInt32(ctx, &_type, argv[0]))
            return JS_EXCEPTION;
        type = (int)_type;
        auto __arg0 = type;

        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[1]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg1 = winid;

        instance = new Ozone::CloseEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_CloseEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_CloseEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::CloseEvent::SetLoggingOff
static JSValue callback_method_Ozone_CloseEvent_SetLoggingOff(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CloseEvent* instance = (Ozone::CloseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetLoggingOff(bool logOff)
overload0:
    {
        bool logOff;
        logOff = JS_ToBool(ctx, argv[0]);
        if (logOff == -1)
            return JS_EXCEPTION;
        auto __arg0 = logOff;

        instance->SetLoggingOff(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::CloseEvent::GetLoggingOff
static JSValue callback_method_Ozone_CloseEvent_GetLoggingOff(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CloseEvent* instance = (Ozone::CloseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetLoggingOff();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::CloseEvent::Veto
static JSValue callback_method_Ozone_CloseEvent_Veto(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CloseEvent* instance = (Ozone::CloseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Veto(bool veto)
overload0:
    {
        bool veto;
        veto = JS_ToBool(ctx, argv[0]);
        if (veto == -1)
            return JS_EXCEPTION;
        auto __arg0 = veto;

        instance->Veto(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::CloseEvent::SetCanVeto
static JSValue callback_method_Ozone_CloseEvent_SetCanVeto(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CloseEvent* instance = (Ozone::CloseEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetCanVeto(bool canVeto)
overload0:
    {
        bool canVeto;
        canVeto = JS_ToBool(ctx, argv[0]);
        if (canVeto == -1)
            return JS_EXCEPTION;
        auto __arg0 = canVeto;

        instance->SetCanVeto(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::CloseEvent::CanVeto
static JSValue callback_method_Ozone_CloseEvent_CanVeto(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CloseEvent* instance = (Ozone::CloseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->CanVeto();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::CloseEvent::GetVeto
static JSValue callback_method_Ozone_CloseEvent_GetVeto(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CloseEvent* instance = (Ozone::CloseEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetVeto();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::CloseEvent::Clone
static JSValue callback_method_Ozone_CloseEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::CloseEvent* instance = (Ozone::CloseEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_CloseEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "CloseEvent");
}

void finalizer_Ozone_CloseEvent(JSRuntime *rt, JSValue val)
{
    Ozone::CloseEvent* instance = (Ozone::CloseEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_CloseEvent
{
    "CloseEvent",
    .finalizer = finalizer_Ozone_CloseEvent
};

static JSCFunctionListEntry funcDef_Ozone_CloseEvent[]
{
    JS_CFUNC_DEF("SetLoggingOff", 1, callback_method_Ozone_CloseEvent_SetLoggingOff),
    JS_CFUNC_DEF("GetLoggingOff", 0, callback_method_Ozone_CloseEvent_GetLoggingOff),
    JS_CFUNC_DEF("Veto", 1, callback_method_Ozone_CloseEvent_Veto),
    JS_CFUNC_DEF("SetCanVeto", 1, callback_method_Ozone_CloseEvent_SetCanVeto),
    JS_CFUNC_DEF("CanVeto", 0, callback_method_Ozone_CloseEvent_CanVeto),
    JS_CFUNC_DEF("GetVeto", 0, callback_method_Ozone_CloseEvent_GetVeto),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_CloseEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_CloseEvent_toString),
};

static void register_class_Ozone_CloseEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "CloseEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_CloseEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_CloseEvent, &classDef_Ozone_CloseEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_CloseEvent, sizeof(funcDef_Ozone_CloseEvent) / sizeof(funcDef_Ozone_CloseEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_CloseEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_CloseEvent_CloseEvent, "CloseEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "CloseEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_CloseEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_ShowEvent;

// Ozone::ShowEvent::ShowEvent
static JSValue callback_method_Ozone_ShowEvent_ShowEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ShowEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsBool(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ShowEvent(int winid, bool show)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        bool show;
        show = JS_ToBool(ctx, argv[1]);
        if (show == -1)
            return JS_EXCEPTION;
        auto __arg1 = show;

        instance = new Ozone::ShowEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_ShowEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_ShowEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::ShowEvent::SetShow
static JSValue callback_method_Ozone_ShowEvent_SetShow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ShowEvent* instance = (Ozone::ShowEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetShow(bool show)
overload0:
    {
        bool show;
        show = JS_ToBool(ctx, argv[0]);
        if (show == -1)
            return JS_EXCEPTION;
        auto __arg0 = show;

        instance->SetShow(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::ShowEvent::IsShown
static JSValue callback_method_Ozone_ShowEvent_IsShown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ShowEvent* instance = (Ozone::ShowEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsShown();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::ShowEvent::Clone
static JSValue callback_method_Ozone_ShowEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ShowEvent* instance = (Ozone::ShowEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_ShowEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "ShowEvent");
}

void finalizer_Ozone_ShowEvent(JSRuntime *rt, JSValue val)
{
    Ozone::ShowEvent* instance = (Ozone::ShowEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_ShowEvent
{
    "ShowEvent",
    .finalizer = finalizer_Ozone_ShowEvent
};

static JSCFunctionListEntry funcDef_Ozone_ShowEvent[]
{
    JS_CFUNC_DEF("SetShow", 1, callback_method_Ozone_ShowEvent_SetShow),
    JS_CFUNC_DEF("IsShown", 0, callback_method_Ozone_ShowEvent_IsShown),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_ShowEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_ShowEvent_toString),
};

static void register_class_Ozone_ShowEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "ShowEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_ShowEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_ShowEvent, &classDef_Ozone_ShowEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_ShowEvent, sizeof(funcDef_Ozone_ShowEvent) / sizeof(funcDef_Ozone_ShowEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_ShowEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_ShowEvent_ShowEvent, "ShowEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "ShowEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_ShowEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_IconizeEvent;

// Ozone::IconizeEvent::IconizeEvent
static JSValue callback_method_Ozone_IconizeEvent_IconizeEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::IconizeEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsBool(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // IconizeEvent(int winid, bool iconized)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        bool iconized;
        iconized = JS_ToBool(ctx, argv[1]);
        if (iconized == -1)
            return JS_EXCEPTION;
        auto __arg1 = iconized;

        instance = new Ozone::IconizeEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_IconizeEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_IconizeEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::IconizeEvent::IsIconized
static JSValue callback_method_Ozone_IconizeEvent_IsIconized(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::IconizeEvent* instance = (Ozone::IconizeEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsIconized();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::IconizeEvent::Clone
static JSValue callback_method_Ozone_IconizeEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::IconizeEvent* instance = (Ozone::IconizeEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_IconizeEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "IconizeEvent");
}

void finalizer_Ozone_IconizeEvent(JSRuntime *rt, JSValue val)
{
    Ozone::IconizeEvent* instance = (Ozone::IconizeEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_IconizeEvent
{
    "IconizeEvent",
    .finalizer = finalizer_Ozone_IconizeEvent
};

static JSCFunctionListEntry funcDef_Ozone_IconizeEvent[]
{
    JS_CFUNC_DEF("IsIconized", 0, callback_method_Ozone_IconizeEvent_IsIconized),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_IconizeEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_IconizeEvent_toString),
};

static void register_class_Ozone_IconizeEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "IconizeEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_IconizeEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_IconizeEvent, &classDef_Ozone_IconizeEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_IconizeEvent, sizeof(funcDef_Ozone_IconizeEvent) / sizeof(funcDef_Ozone_IconizeEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_IconizeEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_IconizeEvent_IconizeEvent, "IconizeEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "IconizeEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_IconizeEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_MaximizeEvent;

// Ozone::MaximizeEvent::MaximizeEvent
static JSValue callback_method_Ozone_MaximizeEvent_MaximizeEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MaximizeEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // MaximizeEvent(int winid)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        instance = new Ozone::MaximizeEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_MaximizeEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_MaximizeEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::MaximizeEvent::Clone
static JSValue callback_method_Ozone_MaximizeEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MaximizeEvent* instance = (Ozone::MaximizeEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_MaximizeEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "MaximizeEvent");
}

void finalizer_Ozone_MaximizeEvent(JSRuntime *rt, JSValue val)
{
    Ozone::MaximizeEvent* instance = (Ozone::MaximizeEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_MaximizeEvent
{
    "MaximizeEvent",
    .finalizer = finalizer_Ozone_MaximizeEvent
};

static JSCFunctionListEntry funcDef_Ozone_MaximizeEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_MaximizeEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_MaximizeEvent_toString),
};

static void register_class_Ozone_MaximizeEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "MaximizeEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_MaximizeEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_MaximizeEvent, &classDef_Ozone_MaximizeEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_MaximizeEvent, sizeof(funcDef_Ozone_MaximizeEvent) / sizeof(funcDef_Ozone_MaximizeEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_MaximizeEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_MaximizeEvent_MaximizeEvent, "MaximizeEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "MaximizeEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_MaximizeEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_JoystickEvent;

// Ozone::JoystickEvent::JoystickEvent
static JSValue callback_method_Ozone_JoystickEvent_JoystickEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 4)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsInt32(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsInt32(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // JoystickEvent(int type, int state, int joystick, int change)
overload0:
    {
        int type;
        int32_t _type;
        if (JS_ToInt32(ctx, &_type, argv[0]))
            return JS_EXCEPTION;
        type = (int)_type;
        auto __arg0 = type;

        int state;
        int32_t _state;
        if (JS_ToInt32(ctx, &_state, argv[1]))
            return JS_EXCEPTION;
        state = (int)_state;
        auto __arg1 = state;

        int joystick;
        int32_t _joystick;
        if (JS_ToInt32(ctx, &_joystick, argv[2]))
            return JS_EXCEPTION;
        joystick = (int)_joystick;
        auto __arg2 = joystick;

        int change;
        int32_t _change;
        if (JS_ToInt32(ctx, &_change, argv[3]))
            return JS_EXCEPTION;
        change = (int)_change;
        auto __arg3 = change;

        instance = new Ozone::JoystickEvent(__arg0, __arg1, __arg2, __arg3);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_JoystickEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_JoystickEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::JoystickEvent::GetPosition
static JSValue callback_method_Ozone_JoystickEvent_GetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Point __ret = instance->GetPosition();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::JoystickEvent::GetZPosition
static JSValue callback_method_Ozone_JoystickEvent_GetZPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetZPosition();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::JoystickEvent::GetButtonState
static JSValue callback_method_Ozone_JoystickEvent_GetButtonState(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetButtonState();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::JoystickEvent::GetButtonChange
static JSValue callback_method_Ozone_JoystickEvent_GetButtonChange(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetButtonChange();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::JoystickEvent::GetButtonOrdinal
static JSValue callback_method_Ozone_JoystickEvent_GetButtonOrdinal(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetButtonOrdinal();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::JoystickEvent::GetJoystick
static JSValue callback_method_Ozone_JoystickEvent_GetJoystick(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetJoystick();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::JoystickEvent::SetJoystick
static JSValue callback_method_Ozone_JoystickEvent_SetJoystick(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetJoystick(int stick)
overload0:
    {
        int stick;
        int32_t _stick;
        if (JS_ToInt32(ctx, &_stick, argv[0]))
            return JS_EXCEPTION;
        stick = (int)_stick;
        auto __arg0 = stick;

        instance->SetJoystick(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::JoystickEvent::SetButtonState
static JSValue callback_method_Ozone_JoystickEvent_SetButtonState(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetButtonState(int state)
overload0:
    {
        int state;
        int32_t _state;
        if (JS_ToInt32(ctx, &_state, argv[0]))
            return JS_EXCEPTION;
        state = (int)_state;
        auto __arg0 = state;

        instance->SetButtonState(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::JoystickEvent::SetButtonChange
static JSValue callback_method_Ozone_JoystickEvent_SetButtonChange(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetButtonChange(int change)
overload0:
    {
        int change;
        int32_t _change;
        if (JS_ToInt32(ctx, &_change, argv[0]))
            return JS_EXCEPTION;
        change = (int)_change;
        auto __arg0 = change;

        instance->SetButtonChange(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::JoystickEvent::SetPosition
static JSValue callback_method_Ozone_JoystickEvent_SetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPosition(const ::Ozone::Point& pos)
overload0:
    {
        Ozone::Point* pos_instance = (Ozone::Point*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *pos_instance;

        instance->SetPosition(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::JoystickEvent::SetZPosition
static JSValue callback_method_Ozone_JoystickEvent_SetZPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetZPosition(int zPos)
overload0:
    {
        int zPos;
        int32_t _zPos;
        if (JS_ToInt32(ctx, &_zPos, argv[0]))
            return JS_EXCEPTION;
        zPos = (int)_zPos;
        auto __arg0 = zPos;

        instance->SetZPosition(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::JoystickEvent::IsButton
static JSValue callback_method_Ozone_JoystickEvent_IsButton(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsButton();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::JoystickEvent::IsMove
static JSValue callback_method_Ozone_JoystickEvent_IsMove(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsMove();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::JoystickEvent::IsZMove
static JSValue callback_method_Ozone_JoystickEvent_IsZMove(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsZMove();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::JoystickEvent::ButtonDown
static JSValue callback_method_Ozone_JoystickEvent_ButtonDown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool ButtonDown(int but) const
overload0:
    {
        int but;
        int32_t _but;
        if (JS_ToInt32(ctx, &_but, argv[0]))
            return JS_EXCEPTION;
        but = (int)_but;
        auto __arg0 = but;

        bool __ret = instance->ButtonDown(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::JoystickEvent::ButtonUp
static JSValue callback_method_Ozone_JoystickEvent_ButtonUp(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool ButtonUp(int but) const
overload0:
    {
        int but;
        int32_t _but;
        if (JS_ToInt32(ctx, &_but, argv[0]))
            return JS_EXCEPTION;
        but = (int)_but;
        auto __arg0 = but;

        bool __ret = instance->ButtonUp(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::JoystickEvent::ButtonIsDown
static JSValue callback_method_Ozone_JoystickEvent_ButtonIsDown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool ButtonIsDown(int but) const
overload0:
    {
        int but;
        int32_t _but;
        if (JS_ToInt32(ctx, &_but, argv[0]))
            return JS_EXCEPTION;
        but = (int)_but;
        auto __arg0 = but;

        bool __ret = instance->ButtonIsDown(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::JoystickEvent::Clone
static JSValue callback_method_Ozone_JoystickEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_JoystickEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "JoystickEvent");
}

void finalizer_Ozone_JoystickEvent(JSRuntime *rt, JSValue val)
{
    Ozone::JoystickEvent* instance = (Ozone::JoystickEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_JoystickEvent
{
    "JoystickEvent",
    .finalizer = finalizer_Ozone_JoystickEvent
};

static JSCFunctionListEntry funcDef_Ozone_JoystickEvent[]
{
    JS_CFUNC_DEF("GetPosition", 0, callback_method_Ozone_JoystickEvent_GetPosition),
    JS_CFUNC_DEF("GetZPosition", 0, callback_method_Ozone_JoystickEvent_GetZPosition),
    JS_CFUNC_DEF("GetButtonState", 0, callback_method_Ozone_JoystickEvent_GetButtonState),
    JS_CFUNC_DEF("GetButtonChange", 0, callback_method_Ozone_JoystickEvent_GetButtonChange),
    JS_CFUNC_DEF("GetButtonOrdinal", 0, callback_method_Ozone_JoystickEvent_GetButtonOrdinal),
    JS_CFUNC_DEF("GetJoystick", 0, callback_method_Ozone_JoystickEvent_GetJoystick),
    JS_CFUNC_DEF("SetJoystick", 1, callback_method_Ozone_JoystickEvent_SetJoystick),
    JS_CFUNC_DEF("SetButtonState", 1, callback_method_Ozone_JoystickEvent_SetButtonState),
    JS_CFUNC_DEF("SetButtonChange", 1, callback_method_Ozone_JoystickEvent_SetButtonChange),
    JS_CFUNC_DEF("SetPosition", 1, callback_method_Ozone_JoystickEvent_SetPosition),
    JS_CFUNC_DEF("SetZPosition", 1, callback_method_Ozone_JoystickEvent_SetZPosition),
    JS_CFUNC_DEF("IsButton", 0, callback_method_Ozone_JoystickEvent_IsButton),
    JS_CFUNC_DEF("IsMove", 0, callback_method_Ozone_JoystickEvent_IsMove),
    JS_CFUNC_DEF("IsZMove", 0, callback_method_Ozone_JoystickEvent_IsZMove),
    JS_CFUNC_DEF("ButtonDown", 1, callback_method_Ozone_JoystickEvent_ButtonDown),
    JS_CFUNC_DEF("ButtonUp", 1, callback_method_Ozone_JoystickEvent_ButtonUp),
    JS_CFUNC_DEF("ButtonIsDown", 1, callback_method_Ozone_JoystickEvent_ButtonIsDown),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_JoystickEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_JoystickEvent_toString),
};

static void register_class_Ozone_JoystickEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "JoystickEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_JoystickEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_JoystickEvent, &classDef_Ozone_JoystickEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_JoystickEvent, sizeof(funcDef_Ozone_JoystickEvent) / sizeof(funcDef_Ozone_JoystickEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_JoystickEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_JoystickEvent_JoystickEvent, "JoystickEvent", 4, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "JoystickEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_JoystickEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_UpdateUIEvent;

// Ozone::UpdateUIEvent::UpdateUIEvent
static JSValue callback_method_Ozone_UpdateUIEvent_UpdateUIEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // UpdateUIEvent(int commandId)
overload0:
    {
        int commandId;
        int32_t _commandId;
        if (JS_ToInt32(ctx, &_commandId, argv[0]))
            return JS_EXCEPTION;
        commandId = (int)_commandId;
        auto __arg0 = commandId;

        instance = new Ozone::UpdateUIEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_UpdateUIEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_UpdateUIEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::UpdateUIEvent::GetChecked
static JSValue callback_method_Ozone_UpdateUIEvent_GetChecked(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetChecked();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::UpdateUIEvent::GetEnabled
static JSValue callback_method_Ozone_UpdateUIEvent_GetEnabled(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetEnabled();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::UpdateUIEvent::GetShown
static JSValue callback_method_Ozone_UpdateUIEvent_GetShown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetShown();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::UpdateUIEvent::GetText
static JSValue callback_method_Ozone_UpdateUIEvent_GetText(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    const char* __ret = instance->GetText();

    JSValue ____ret = JS_NewString(ctx, __ret);

    return ____ret;
}

// Ozone::UpdateUIEvent::GetSetText
static JSValue callback_method_Ozone_UpdateUIEvent_GetSetText(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetSetText();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::UpdateUIEvent::GetSetChecked
static JSValue callback_method_Ozone_UpdateUIEvent_GetSetChecked(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetSetChecked();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::UpdateUIEvent::GetSetEnabled
static JSValue callback_method_Ozone_UpdateUIEvent_GetSetEnabled(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetSetEnabled();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::UpdateUIEvent::GetSetShown
static JSValue callback_method_Ozone_UpdateUIEvent_GetSetShown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetSetShown();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::UpdateUIEvent::Check
static JSValue callback_method_Ozone_UpdateUIEvent_Check(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Check(bool check)
overload0:
    {
        bool check;
        check = JS_ToBool(ctx, argv[0]);
        if (check == -1)
            return JS_EXCEPTION;
        auto __arg0 = check;

        instance->Check(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::UpdateUIEvent::Enable
static JSValue callback_method_Ozone_UpdateUIEvent_Enable(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Enable(bool enable)
overload0:
    {
        bool enable;
        enable = JS_ToBool(ctx, argv[0]);
        if (enable == -1)
            return JS_EXCEPTION;
        auto __arg0 = enable;

        instance->Enable(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::UpdateUIEvent::Show
static JSValue callback_method_Ozone_UpdateUIEvent_Show(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Show(bool show)
overload0:
    {
        bool show;
        show = JS_ToBool(ctx, argv[0]);
        if (show == -1)
            return JS_EXCEPTION;
        auto __arg0 = show;

        instance->Show(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::UpdateUIEvent::SetText
static JSValue callback_method_Ozone_UpdateUIEvent_SetText(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsString(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetText(const char* text)
overload0:
    {
        const char* text;
        text = JS_ToCString(ctx, argv[0]);
        if (!text)
            return JS_EXCEPTION;
        auto __arg0 = text;

        instance->SetText(__arg0);

        JS_FreeCString(ctx, text);

        return JS_UNDEFINED;
    }
}

// Ozone::UpdateUIEvent::IsCheckable
static JSValue callback_method_Ozone_UpdateUIEvent_IsCheckable(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsCheckable();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::UpdateUIEvent::DisallowCheck
static JSValue callback_method_Ozone_UpdateUIEvent_DisallowCheck(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    instance->DisallowCheck();

    return JS_UNDEFINED;
}

// Ozone::UpdateUIEvent::Clone
static JSValue callback_method_Ozone_UpdateUIEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::UpdateUIEvent::SetUpdateInterval
static JSValue callback_method_Ozone_UpdateUIEvent_SetUpdateInterval(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetUpdateInterval(long updateInterval)
overload0:
    {
        long updateInterval;
        int32_t _updateInterval;
        if (JS_ToInt32(ctx, &_updateInterval, argv[0]))
            return JS_EXCEPTION;
        updateInterval = (long)_updateInterval;
        auto __arg0 = updateInterval;

        ::Ozone::UpdateUIEvent::SetUpdateInterval(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::UpdateUIEvent::GetUpdateInterval
static JSValue callback_method_Ozone_UpdateUIEvent_GetUpdateInterval(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    long __ret = ::Ozone::UpdateUIEvent::GetUpdateInterval();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::UpdateUIEvent::ResetUpdateTime
static JSValue callback_method_Ozone_UpdateUIEvent_ResetUpdateTime(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    ::Ozone::UpdateUIEvent::ResetUpdateTime();

    return JS_UNDEFINED;
}

// Ozone::UpdateUIEvent::SetMode
static JSValue callback_method_Ozone_UpdateUIEvent_SetMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetMode(::Ozone::UpdateUIMode mode)
overload0:
    {
        unsigned int mode;
        uint32_t _mode;
        if (JS_ToUint32(ctx, &_mode, argv[0]))
            return JS_EXCEPTION;
        mode = (unsigned int)_mode;
        auto __arg0 = (::Ozone::UpdateUIMode)mode;

        ::Ozone::UpdateUIEvent::SetMode(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::UpdateUIEvent::GetMode
static JSValue callback_method_Ozone_UpdateUIEvent_GetMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    ::Ozone::UpdateUIMode __ret = ::Ozone::UpdateUIEvent::GetMode();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_UpdateUIEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "UpdateUIEvent");
}

void finalizer_Ozone_UpdateUIEvent(JSRuntime *rt, JSValue val)
{
    Ozone::UpdateUIEvent* instance = (Ozone::UpdateUIEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_UpdateUIEvent
{
    "UpdateUIEvent",
    .finalizer = finalizer_Ozone_UpdateUIEvent
};

static JSCFunctionListEntry funcDef_Ozone_UpdateUIEvent[]
{
    JS_CFUNC_DEF("GetChecked", 0, callback_method_Ozone_UpdateUIEvent_GetChecked),
    JS_CFUNC_DEF("GetEnabled", 0, callback_method_Ozone_UpdateUIEvent_GetEnabled),
    JS_CFUNC_DEF("GetShown", 0, callback_method_Ozone_UpdateUIEvent_GetShown),
    JS_CFUNC_DEF("GetText", 0, callback_method_Ozone_UpdateUIEvent_GetText),
    JS_CFUNC_DEF("GetSetText", 0, callback_method_Ozone_UpdateUIEvent_GetSetText),
    JS_CFUNC_DEF("GetSetChecked", 0, callback_method_Ozone_UpdateUIEvent_GetSetChecked),
    JS_CFUNC_DEF("GetSetEnabled", 0, callback_method_Ozone_UpdateUIEvent_GetSetEnabled),
    JS_CFUNC_DEF("GetSetShown", 0, callback_method_Ozone_UpdateUIEvent_GetSetShown),
    JS_CFUNC_DEF("Check", 1, callback_method_Ozone_UpdateUIEvent_Check),
    JS_CFUNC_DEF("Enable", 1, callback_method_Ozone_UpdateUIEvent_Enable),
    JS_CFUNC_DEF("Show", 1, callback_method_Ozone_UpdateUIEvent_Show),
    JS_CFUNC_DEF("SetText", 1, callback_method_Ozone_UpdateUIEvent_SetText),
    JS_CFUNC_DEF("IsCheckable", 0, callback_method_Ozone_UpdateUIEvent_IsCheckable),
    JS_CFUNC_DEF("DisallowCheck", 0, callback_method_Ozone_UpdateUIEvent_DisallowCheck),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_UpdateUIEvent_Clone),
    JS_CFUNC_DEF("SetUpdateInterval", 1, callback_method_Ozone_UpdateUIEvent_SetUpdateInterval),
    JS_CFUNC_DEF("GetUpdateInterval", 0, callback_method_Ozone_UpdateUIEvent_GetUpdateInterval),
    JS_CFUNC_DEF("ResetUpdateTime", 0, callback_method_Ozone_UpdateUIEvent_ResetUpdateTime),
    JS_CFUNC_DEF("SetMode", 1, callback_method_Ozone_UpdateUIEvent_SetMode),
    JS_CFUNC_DEF("GetMode", 0, callback_method_Ozone_UpdateUIEvent_GetMode),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_UpdateUIEvent_toString),
};

static void register_class_Ozone_UpdateUIEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "UpdateUIEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_UpdateUIEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_UpdateUIEvent, &classDef_Ozone_UpdateUIEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_UpdateUIEvent, sizeof(funcDef_Ozone_UpdateUIEvent) / sizeof(funcDef_Ozone_UpdateUIEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_UpdateUIEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_UpdateUIEvent_UpdateUIEvent, "UpdateUIEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "UpdateUIEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_UpdateUIEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_CommandEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_SysColourChangedEvent;

// Ozone::SysColourChangedEvent::SysColourChangedEvent
static JSValue callback_method_Ozone_SysColourChangedEvent_SysColourChangedEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SysColourChangedEvent* instance;

    instance = new Ozone::SysColourChangedEvent();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_SysColourChangedEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_SysColourChangedEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::SysColourChangedEvent::Clone
static JSValue callback_method_Ozone_SysColourChangedEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::SysColourChangedEvent* instance = (Ozone::SysColourChangedEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_SysColourChangedEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "SysColourChangedEvent");
}

void finalizer_Ozone_SysColourChangedEvent(JSRuntime *rt, JSValue val)
{
    Ozone::SysColourChangedEvent* instance = (Ozone::SysColourChangedEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_SysColourChangedEvent
{
    "SysColourChangedEvent",
    .finalizer = finalizer_Ozone_SysColourChangedEvent
};

static JSCFunctionListEntry funcDef_Ozone_SysColourChangedEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_SysColourChangedEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_SysColourChangedEvent_toString),
};

static void register_class_Ozone_SysColourChangedEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "SysColourChangedEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_SysColourChangedEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_SysColourChangedEvent, &classDef_Ozone_SysColourChangedEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_SysColourChangedEvent, sizeof(funcDef_Ozone_SysColourChangedEvent) / sizeof(funcDef_Ozone_SysColourChangedEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_SysColourChangedEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_SysColourChangedEvent_SysColourChangedEvent, "SysColourChangedEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "SysColourChangedEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_SysColourChangedEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_MouseCaptureChangedEvent;

// Ozone::MouseCaptureChangedEvent::MouseCaptureChangedEvent
static JSValue callback_method_Ozone_MouseCaptureChangedEvent_MouseCaptureChangedEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseCaptureChangedEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]) || JS_IsNull(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // MouseCaptureChangedEvent(int winid, ::Ozone::Window* gainedCapture)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        Ozone::Window* gainedCapture_instance = (Ozone::Window*) JS_Interop_GetInstance(argv[1], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg1 = gainedCapture_instance;

        instance = new Ozone::MouseCaptureChangedEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_MouseCaptureChangedEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_MouseCaptureChangedEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::MouseCaptureChangedEvent::Clone
static JSValue callback_method_Ozone_MouseCaptureChangedEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseCaptureChangedEvent* instance = (Ozone::MouseCaptureChangedEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::MouseCaptureChangedEvent::GetCapturedWindow
static JSValue callback_method_Ozone_MouseCaptureChangedEvent_GetCapturedWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseCaptureChangedEvent* instance = (Ozone::MouseCaptureChangedEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->GetCapturedWindow();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_MouseCaptureChangedEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "MouseCaptureChangedEvent");
}

void finalizer_Ozone_MouseCaptureChangedEvent(JSRuntime *rt, JSValue val)
{
    Ozone::MouseCaptureChangedEvent* instance = (Ozone::MouseCaptureChangedEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_MouseCaptureChangedEvent
{
    "MouseCaptureChangedEvent",
    .finalizer = finalizer_Ozone_MouseCaptureChangedEvent
};

static JSCFunctionListEntry funcDef_Ozone_MouseCaptureChangedEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_MouseCaptureChangedEvent_Clone),
    JS_CFUNC_DEF("GetCapturedWindow", 0, callback_method_Ozone_MouseCaptureChangedEvent_GetCapturedWindow),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_MouseCaptureChangedEvent_toString),
};

static void register_class_Ozone_MouseCaptureChangedEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "MouseCaptureChangedEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_MouseCaptureChangedEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_MouseCaptureChangedEvent, &classDef_Ozone_MouseCaptureChangedEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_MouseCaptureChangedEvent, sizeof(funcDef_Ozone_MouseCaptureChangedEvent) / sizeof(funcDef_Ozone_MouseCaptureChangedEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_MouseCaptureChangedEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_MouseCaptureChangedEvent_MouseCaptureChangedEvent, "MouseCaptureChangedEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "MouseCaptureChangedEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_MouseCaptureChangedEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_MouseCaptureLostEvent;

// Ozone::MouseCaptureLostEvent::MouseCaptureLostEvent
static JSValue callback_method_Ozone_MouseCaptureLostEvent_MouseCaptureLostEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseCaptureLostEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // MouseCaptureLostEvent(int winid)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        instance = new Ozone::MouseCaptureLostEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_MouseCaptureLostEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_MouseCaptureLostEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::MouseCaptureLostEvent::Clone
static JSValue callback_method_Ozone_MouseCaptureLostEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::MouseCaptureLostEvent* instance = (Ozone::MouseCaptureLostEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_MouseCaptureLostEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "MouseCaptureLostEvent");
}

void finalizer_Ozone_MouseCaptureLostEvent(JSRuntime *rt, JSValue val)
{
    Ozone::MouseCaptureLostEvent* instance = (Ozone::MouseCaptureLostEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_MouseCaptureLostEvent
{
    "MouseCaptureLostEvent",
    .finalizer = finalizer_Ozone_MouseCaptureLostEvent
};

static JSCFunctionListEntry funcDef_Ozone_MouseCaptureLostEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_MouseCaptureLostEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_MouseCaptureLostEvent_toString),
};

static void register_class_Ozone_MouseCaptureLostEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "MouseCaptureLostEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_MouseCaptureLostEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_MouseCaptureLostEvent, &classDef_Ozone_MouseCaptureLostEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_MouseCaptureLostEvent, sizeof(funcDef_Ozone_MouseCaptureLostEvent) / sizeof(funcDef_Ozone_MouseCaptureLostEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_MouseCaptureLostEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_MouseCaptureLostEvent_MouseCaptureLostEvent, "MouseCaptureLostEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "MouseCaptureLostEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_MouseCaptureLostEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_DisplayChangedEvent;

// Ozone::DisplayChangedEvent::DisplayChangedEvent
static JSValue callback_method_Ozone_DisplayChangedEvent_DisplayChangedEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::DisplayChangedEvent* instance;

    instance = new Ozone::DisplayChangedEvent();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_DisplayChangedEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_DisplayChangedEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::DisplayChangedEvent::Clone
static JSValue callback_method_Ozone_DisplayChangedEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::DisplayChangedEvent* instance = (Ozone::DisplayChangedEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_DisplayChangedEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "DisplayChangedEvent");
}

void finalizer_Ozone_DisplayChangedEvent(JSRuntime *rt, JSValue val)
{
    Ozone::DisplayChangedEvent* instance = (Ozone::DisplayChangedEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_DisplayChangedEvent
{
    "DisplayChangedEvent",
    .finalizer = finalizer_Ozone_DisplayChangedEvent
};

static JSCFunctionListEntry funcDef_Ozone_DisplayChangedEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_DisplayChangedEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_DisplayChangedEvent_toString),
};

static void register_class_Ozone_DisplayChangedEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "DisplayChangedEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_DisplayChangedEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_DisplayChangedEvent, &classDef_Ozone_DisplayChangedEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_DisplayChangedEvent, sizeof(funcDef_Ozone_DisplayChangedEvent) / sizeof(funcDef_Ozone_DisplayChangedEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_DisplayChangedEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_DisplayChangedEvent_DisplayChangedEvent, "DisplayChangedEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "DisplayChangedEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_DisplayChangedEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_DPIChangedEvent;

// Ozone::DPIChangedEvent::DPIChangedEvent
static JSValue callback_method_Ozone_DPIChangedEvent_DPIChangedEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::DPIChangedEvent* instance;

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]) || JS_IsNull(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // explicit DPIChangedEvent(const ::Ozone::Size& oldDPI, const ::Ozone::Size& newDPI)
overload0:
    {
        Ozone::Size* oldDPI_instance = (Ozone::Size*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *oldDPI_instance;

        Ozone::Size* newDPI_instance = (Ozone::Size*) JS_Interop_GetInstance(argv[1], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *newDPI_instance;

        instance = new Ozone::DPIChangedEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_DPIChangedEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_DPIChangedEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::DPIChangedEvent::GetOldDPI
static JSValue callback_method_Ozone_DPIChangedEvent_GetOldDPI(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::DPIChangedEvent* instance = (Ozone::DPIChangedEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetOldDPI();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::DPIChangedEvent::GetNewDPI
static JSValue callback_method_Ozone_DPIChangedEvent_GetNewDPI(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::DPIChangedEvent* instance = (Ozone::DPIChangedEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetNewDPI();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::DPIChangedEvent::Clone
static JSValue callback_method_Ozone_DPIChangedEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::DPIChangedEvent* instance = (Ozone::DPIChangedEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_DPIChangedEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "DPIChangedEvent");
}

void finalizer_Ozone_DPIChangedEvent(JSRuntime *rt, JSValue val)
{
    Ozone::DPIChangedEvent* instance = (Ozone::DPIChangedEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_DPIChangedEvent
{
    "DPIChangedEvent",
    .finalizer = finalizer_Ozone_DPIChangedEvent
};

static JSCFunctionListEntry funcDef_Ozone_DPIChangedEvent[]
{
    JS_CFUNC_DEF("GetOldDPI", 0, callback_method_Ozone_DPIChangedEvent_GetOldDPI),
    JS_CFUNC_DEF("GetNewDPI", 0, callback_method_Ozone_DPIChangedEvent_GetNewDPI),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_DPIChangedEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_DPIChangedEvent_toString),
};

static void register_class_Ozone_DPIChangedEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "DPIChangedEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_DPIChangedEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_DPIChangedEvent, &classDef_Ozone_DPIChangedEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_DPIChangedEvent, sizeof(funcDef_Ozone_DPIChangedEvent) / sizeof(funcDef_Ozone_DPIChangedEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_DPIChangedEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_DPIChangedEvent_DPIChangedEvent, "DPIChangedEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "DPIChangedEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_DPIChangedEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_PaletteChangedEvent;

// Ozone::PaletteChangedEvent::PaletteChangedEvent
static JSValue callback_method_Ozone_PaletteChangedEvent_PaletteChangedEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PaletteChangedEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // PaletteChangedEvent(int winid)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        instance = new Ozone::PaletteChangedEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_PaletteChangedEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_PaletteChangedEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::PaletteChangedEvent::SetChangedWindow
static JSValue callback_method_Ozone_PaletteChangedEvent_SetChangedWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PaletteChangedEvent* instance = (Ozone::PaletteChangedEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetChangedWindow(::Ozone::Window* win)
overload0:
    {
        Ozone::Window* win_instance = (Ozone::Window*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = win_instance;

        instance->SetChangedWindow(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::PaletteChangedEvent::GetChangedWindow
static JSValue callback_method_Ozone_PaletteChangedEvent_GetChangedWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PaletteChangedEvent* instance = (Ozone::PaletteChangedEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->GetChangedWindow();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT, (void*) __ret);

    return ____ret;
}

// Ozone::PaletteChangedEvent::Clone
static JSValue callback_method_Ozone_PaletteChangedEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::PaletteChangedEvent* instance = (Ozone::PaletteChangedEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_PaletteChangedEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "PaletteChangedEvent");
}

void finalizer_Ozone_PaletteChangedEvent(JSRuntime *rt, JSValue val)
{
    Ozone::PaletteChangedEvent* instance = (Ozone::PaletteChangedEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_PaletteChangedEvent
{
    "PaletteChangedEvent",
    .finalizer = finalizer_Ozone_PaletteChangedEvent
};

static JSCFunctionListEntry funcDef_Ozone_PaletteChangedEvent[]
{
    JS_CFUNC_DEF("SetChangedWindow", 1, callback_method_Ozone_PaletteChangedEvent_SetChangedWindow),
    JS_CFUNC_DEF("GetChangedWindow", 0, callback_method_Ozone_PaletteChangedEvent_GetChangedWindow),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_PaletteChangedEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_PaletteChangedEvent_toString),
};

static void register_class_Ozone_PaletteChangedEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "PaletteChangedEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_PaletteChangedEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_PaletteChangedEvent, &classDef_Ozone_PaletteChangedEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_PaletteChangedEvent, sizeof(funcDef_Ozone_PaletteChangedEvent) / sizeof(funcDef_Ozone_PaletteChangedEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_PaletteChangedEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_PaletteChangedEvent_PaletteChangedEvent, "PaletteChangedEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "PaletteChangedEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_PaletteChangedEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_QueryNewPaletteEvent;

// Ozone::QueryNewPaletteEvent::QueryNewPaletteEvent
static JSValue callback_method_Ozone_QueryNewPaletteEvent_QueryNewPaletteEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::QueryNewPaletteEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // QueryNewPaletteEvent(int winid)
overload0:
    {
        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[0]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg0 = winid;

        instance = new Ozone::QueryNewPaletteEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_QueryNewPaletteEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_QueryNewPaletteEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::QueryNewPaletteEvent::SetPaletteRealized
static JSValue callback_method_Ozone_QueryNewPaletteEvent_SetPaletteRealized(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::QueryNewPaletteEvent* instance = (Ozone::QueryNewPaletteEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPaletteRealized(bool realized)
overload0:
    {
        bool realized;
        realized = JS_ToBool(ctx, argv[0]);
        if (realized == -1)
            return JS_EXCEPTION;
        auto __arg0 = realized;

        instance->SetPaletteRealized(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::QueryNewPaletteEvent::GetPaletteRealized
static JSValue callback_method_Ozone_QueryNewPaletteEvent_GetPaletteRealized(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::QueryNewPaletteEvent* instance = (Ozone::QueryNewPaletteEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetPaletteRealized();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::QueryNewPaletteEvent::Clone
static JSValue callback_method_Ozone_QueryNewPaletteEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::QueryNewPaletteEvent* instance = (Ozone::QueryNewPaletteEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_QueryNewPaletteEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "QueryNewPaletteEvent");
}

void finalizer_Ozone_QueryNewPaletteEvent(JSRuntime *rt, JSValue val)
{
    Ozone::QueryNewPaletteEvent* instance = (Ozone::QueryNewPaletteEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_QueryNewPaletteEvent
{
    "QueryNewPaletteEvent",
    .finalizer = finalizer_Ozone_QueryNewPaletteEvent
};

static JSCFunctionListEntry funcDef_Ozone_QueryNewPaletteEvent[]
{
    JS_CFUNC_DEF("SetPaletteRealized", 1, callback_method_Ozone_QueryNewPaletteEvent_SetPaletteRealized),
    JS_CFUNC_DEF("GetPaletteRealized", 0, callback_method_Ozone_QueryNewPaletteEvent_GetPaletteRealized),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_QueryNewPaletteEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_QueryNewPaletteEvent_toString),
};

static void register_class_Ozone_QueryNewPaletteEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "QueryNewPaletteEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_QueryNewPaletteEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_QueryNewPaletteEvent, &classDef_Ozone_QueryNewPaletteEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_QueryNewPaletteEvent, sizeof(funcDef_Ozone_QueryNewPaletteEvent) / sizeof(funcDef_Ozone_QueryNewPaletteEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_QueryNewPaletteEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_QueryNewPaletteEvent_QueryNewPaletteEvent, "QueryNewPaletteEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "QueryNewPaletteEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_QueryNewPaletteEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_NavigationKeyEvent;

enum class NavigationKeyEventFlags : unsigned int
{
    IsBackward = 0x0,
    IsForward = 0x1,
    WinChange = 0x2,
    FromTab = 0x4
};

// Ozone::NavigationKeyEvent::NavigationKeyEvent
static JSValue callback_method_Ozone_NavigationKeyEvent_NavigationKeyEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance;

    instance = new Ozone::NavigationKeyEvent();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_NavigationKeyEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_NavigationKeyEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::NavigationKeyEvent::GetDirection
static JSValue callback_method_Ozone_NavigationKeyEvent_GetDirection(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetDirection();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::NavigationKeyEvent::SetDirection
static JSValue callback_method_Ozone_NavigationKeyEvent_SetDirection(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetDirection(bool bForward)
overload0:
    {
        bool bForward;
        bForward = JS_ToBool(ctx, argv[0]);
        if (bForward == -1)
            return JS_EXCEPTION;
        auto __arg0 = bForward;

        instance->SetDirection(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::NavigationKeyEvent::IsWindowChange
static JSValue callback_method_Ozone_NavigationKeyEvent_IsWindowChange(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsWindowChange();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::NavigationKeyEvent::SetWindowChange
static JSValue callback_method_Ozone_NavigationKeyEvent_SetWindowChange(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetWindowChange(bool bIs)
overload0:
    {
        bool bIs;
        bIs = JS_ToBool(ctx, argv[0]);
        if (bIs == -1)
            return JS_EXCEPTION;
        auto __arg0 = bIs;

        instance->SetWindowChange(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::NavigationKeyEvent::IsFromTab
static JSValue callback_method_Ozone_NavigationKeyEvent_IsFromTab(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsFromTab();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::NavigationKeyEvent::SetFromTab
static JSValue callback_method_Ozone_NavigationKeyEvent_SetFromTab(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetFromTab(bool bIs)
overload0:
    {
        bool bIs;
        bIs = JS_ToBool(ctx, argv[0]);
        if (bIs == -1)
            return JS_EXCEPTION;
        auto __arg0 = bIs;

        instance->SetFromTab(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::NavigationKeyEvent::GetCurrentFocus
static JSValue callback_method_Ozone_NavigationKeyEvent_GetCurrentFocus(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->GetCurrentFocus();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT, (void*) __ret);

    return ____ret;
}

// Ozone::NavigationKeyEvent::SetCurrentFocus
static JSValue callback_method_Ozone_NavigationKeyEvent_SetCurrentFocus(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetCurrentFocus(::Ozone::Window* win)
overload0:
    {
        Ozone::Window* win_instance = (Ozone::Window*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = win_instance;

        instance->SetCurrentFocus(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::NavigationKeyEvent::SetFlags
static JSValue callback_method_Ozone_NavigationKeyEvent_SetFlags(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetFlags(long flags)
overload0:
    {
        long flags;
        int32_t _flags;
        if (JS_ToInt32(ctx, &_flags, argv[0]))
            return JS_EXCEPTION;
        flags = (long)_flags;
        auto __arg0 = flags;

        instance->SetFlags(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::NavigationKeyEvent::Clone
static JSValue callback_method_Ozone_NavigationKeyEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::NavigationKeyEvent::get_m_flags
static JSValue callback_method_Ozone_NavigationKeyEvent_get_m_flags(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    long __ret = instance->get_m_flags();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::NavigationKeyEvent::set_m_flags
static JSValue callback_method_Ozone_NavigationKeyEvent_set_m_flags(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_flags(long value)
overload0:
    {
        long value;
        int32_t _value;
        if (JS_ToInt32(ctx, &_value, argv[0]))
            return JS_EXCEPTION;
        value = (long)_value;
        auto __arg0 = value;

        instance->set_m_flags(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::NavigationKeyEvent::get_m_focus
static JSValue callback_method_Ozone_NavigationKeyEvent_get_m_focus(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->get_m_focus();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT, (void*) __ret);

    return ____ret;
}

// Ozone::NavigationKeyEvent::set_m_focus
static JSValue callback_method_Ozone_NavigationKeyEvent_set_m_focus(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_m_focus(::Ozone::Window* value)
overload0:
    {
        Ozone::Window* value_instance = (Ozone::Window*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = value_instance;

        instance->set_m_focus(__arg0);

        return JS_UNDEFINED;
    }
}

static JSValue callback_class_Ozone_NavigationKeyEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "NavigationKeyEvent");
}

void finalizer_Ozone_NavigationKeyEvent(JSRuntime *rt, JSValue val)
{
    Ozone::NavigationKeyEvent* instance = (Ozone::NavigationKeyEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_NavigationKeyEvent
{
    "NavigationKeyEvent",
    .finalizer = finalizer_Ozone_NavigationKeyEvent
};

static JSCFunctionListEntry funcDef_Ozone_NavigationKeyEvent[]
{
    JS_CFUNC_DEF("GetDirection", 0, callback_method_Ozone_NavigationKeyEvent_GetDirection),
    JS_CFUNC_DEF("SetDirection", 1, callback_method_Ozone_NavigationKeyEvent_SetDirection),
    JS_CFUNC_DEF("IsWindowChange", 0, callback_method_Ozone_NavigationKeyEvent_IsWindowChange),
    JS_CFUNC_DEF("SetWindowChange", 1, callback_method_Ozone_NavigationKeyEvent_SetWindowChange),
    JS_CFUNC_DEF("IsFromTab", 0, callback_method_Ozone_NavigationKeyEvent_IsFromTab),
    JS_CFUNC_DEF("SetFromTab", 1, callback_method_Ozone_NavigationKeyEvent_SetFromTab),
    JS_CFUNC_DEF("GetCurrentFocus", 0, callback_method_Ozone_NavigationKeyEvent_GetCurrentFocus),
    JS_CFUNC_DEF("SetCurrentFocus", 1, callback_method_Ozone_NavigationKeyEvent_SetCurrentFocus),
    JS_CFUNC_DEF("SetFlags", 1, callback_method_Ozone_NavigationKeyEvent_SetFlags),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_NavigationKeyEvent_Clone),
    JS_CFUNC_DEF("get_m_flags", 0, callback_method_Ozone_NavigationKeyEvent_get_m_flags),
    JS_CFUNC_DEF("set_m_flags", 1, callback_method_Ozone_NavigationKeyEvent_set_m_flags),
    JS_CFUNC_DEF("get_m_focus", 0, callback_method_Ozone_NavigationKeyEvent_get_m_focus),
    JS_CFUNC_DEF("set_m_focus", 1, callback_method_Ozone_NavigationKeyEvent_set_m_focus),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_NavigationKeyEvent_toString),
};

static void register_class_Ozone_NavigationKeyEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "NavigationKeyEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_NavigationKeyEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_NavigationKeyEvent, &classDef_Ozone_NavigationKeyEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_NavigationKeyEvent, sizeof(funcDef_Ozone_NavigationKeyEvent) / sizeof(funcDef_Ozone_NavigationKeyEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_NavigationKeyEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_NavigationKeyEvent_NavigationKeyEvent, "NavigationKeyEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "NavigationKeyEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_NavigationKeyEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Event);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_WindowCreateEvent;

// Ozone::WindowCreateEvent::WindowCreateEvent
static JSValue callback_method_Ozone_WindowCreateEvent_WindowCreateEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::WindowCreateEvent* instance;

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // WindowCreateEvent(::Ozone::Window* win)
overload0:
    {
        Ozone::Window* win_instance = (Ozone::Window*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = win_instance;

        instance = new Ozone::WindowCreateEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_WindowCreateEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_WindowCreateEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::WindowCreateEvent::GetWindow
static JSValue callback_method_Ozone_WindowCreateEvent_GetWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::WindowCreateEvent* instance = (Ozone::WindowCreateEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->GetWindow();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT, (void*) __ret);

    return ____ret;
}

// Ozone::WindowCreateEvent::Clone
static JSValue callback_method_Ozone_WindowCreateEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::WindowCreateEvent* instance = (Ozone::WindowCreateEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_WindowCreateEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "WindowCreateEvent");
}

void finalizer_Ozone_WindowCreateEvent(JSRuntime *rt, JSValue val)
{
    Ozone::WindowCreateEvent* instance = (Ozone::WindowCreateEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_WindowCreateEvent
{
    "WindowCreateEvent",
    .finalizer = finalizer_Ozone_WindowCreateEvent
};

static JSCFunctionListEntry funcDef_Ozone_WindowCreateEvent[]
{
    JS_CFUNC_DEF("GetWindow", 0, callback_method_Ozone_WindowCreateEvent_GetWindow),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_WindowCreateEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_WindowCreateEvent_toString),
};

static void register_class_Ozone_WindowCreateEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "WindowCreateEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_WindowCreateEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_WindowCreateEvent, &classDef_Ozone_WindowCreateEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_WindowCreateEvent, sizeof(funcDef_Ozone_WindowCreateEvent) / sizeof(funcDef_Ozone_WindowCreateEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_WindowCreateEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_WindowCreateEvent_WindowCreateEvent, "WindowCreateEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "WindowCreateEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_WindowCreateEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_CommandEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_WindowDestroyEvent;

// Ozone::WindowDestroyEvent::WindowDestroyEvent
static JSValue callback_method_Ozone_WindowDestroyEvent_WindowDestroyEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::WindowDestroyEvent* instance;

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // WindowDestroyEvent(::Ozone::Window* win)
overload0:
    {
        Ozone::Window* win_instance = (Ozone::Window*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = win_instance;

        instance = new Ozone::WindowDestroyEvent(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_WindowDestroyEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_WindowDestroyEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::WindowDestroyEvent::GetWindow
static JSValue callback_method_Ozone_WindowDestroyEvent_GetWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::WindowDestroyEvent* instance = (Ozone::WindowDestroyEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->GetWindow();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT, (void*) __ret);

    return ____ret;
}

// Ozone::WindowDestroyEvent::Clone
static JSValue callback_method_Ozone_WindowDestroyEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::WindowDestroyEvent* instance = (Ozone::WindowDestroyEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_WindowDestroyEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "WindowDestroyEvent");
}

void finalizer_Ozone_WindowDestroyEvent(JSRuntime *rt, JSValue val)
{
    Ozone::WindowDestroyEvent* instance = (Ozone::WindowDestroyEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_WindowDestroyEvent
{
    "WindowDestroyEvent",
    .finalizer = finalizer_Ozone_WindowDestroyEvent
};

static JSCFunctionListEntry funcDef_Ozone_WindowDestroyEvent[]
{
    JS_CFUNC_DEF("GetWindow", 0, callback_method_Ozone_WindowDestroyEvent_GetWindow),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_WindowDestroyEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_WindowDestroyEvent_toString),
};

static void register_class_Ozone_WindowDestroyEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "WindowDestroyEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_WindowDestroyEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_WindowDestroyEvent, &classDef_Ozone_WindowDestroyEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_WindowDestroyEvent, sizeof(funcDef_Ozone_WindowDestroyEvent) / sizeof(funcDef_Ozone_WindowDestroyEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_WindowDestroyEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_WindowDestroyEvent_WindowDestroyEvent, "WindowDestroyEvent", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "WindowDestroyEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_WindowDestroyEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_CommandEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_HelpEvent;

enum class Source : unsigned int
{
    Unknown = 0,
    Keyboard = 1,
    HelpButton = 2
};

// Ozone::HelpEvent::HelpEvent
static JSValue callback_method_Ozone_HelpEvent_HelpEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 4)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::HelpEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsObject(argv[2]) || JS_IsNull(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsInt32(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // HelpEvent(int type, int winid, const ::Ozone::Point& pt, ::Ozone::HelpEvent::Source origin)
overload0:
    {
        int type;
        int32_t _type;
        if (JS_ToInt32(ctx, &_type, argv[0]))
            return JS_EXCEPTION;
        type = (int)_type;
        auto __arg0 = type;

        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[1]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg1 = winid;

        Ozone::Point* pt_instance = (Ozone::Point*) JS_Interop_GetInstance(argv[2], \
            classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg2 = *pt_instance;

        unsigned int origin;
        uint32_t _origin;
        if (JS_ToUint32(ctx, &_origin, argv[3]))
            return JS_EXCEPTION;
        origin = (unsigned int)_origin;
        auto __arg3 = (::Ozone::HelpEvent::Source)origin;

        instance = new Ozone::HelpEvent(__arg0, __arg1, __arg2, __arg3);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_HelpEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_HelpEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::HelpEvent::SetPosition
static JSValue callback_method_Ozone_HelpEvent_SetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::HelpEvent* instance = (Ozone::HelpEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPosition(const ::Ozone::Point& pos)
overload0:
    {
        Ozone::Point* pos_instance = (Ozone::Point*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *pos_instance;

        instance->SetPosition(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::HelpEvent::SetLink
static JSValue callback_method_Ozone_HelpEvent_SetLink(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::HelpEvent* instance = (Ozone::HelpEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsString(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetLink(const char* link)
overload0:
    {
        const char* link;
        link = JS_ToCString(ctx, argv[0]);
        if (!link)
            return JS_EXCEPTION;
        auto __arg0 = link;

        instance->SetLink(__arg0);

        JS_FreeCString(ctx, link);

        return JS_UNDEFINED;
    }
}

// Ozone::HelpEvent::SetTarget
static JSValue callback_method_Ozone_HelpEvent_SetTarget(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::HelpEvent* instance = (Ozone::HelpEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsString(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetTarget(const char* target)
overload0:
    {
        const char* target;
        target = JS_ToCString(ctx, argv[0]);
        if (!target)
            return JS_EXCEPTION;
        auto __arg0 = target;

        instance->SetTarget(__arg0);

        JS_FreeCString(ctx, target);

        return JS_UNDEFINED;
    }
}

// Ozone::HelpEvent::Clone
static JSValue callback_method_Ozone_HelpEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::HelpEvent* instance = (Ozone::HelpEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::HelpEvent::GetOrigin
static JSValue callback_method_Ozone_HelpEvent_GetOrigin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::HelpEvent* instance = (Ozone::HelpEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::HelpEvent::Source __ret = instance->GetOrigin();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::HelpEvent::SetOrigin
static JSValue callback_method_Ozone_HelpEvent_SetOrigin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::HelpEvent* instance = (Ozone::HelpEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsInt32(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetOrigin(::Ozone::HelpEvent::Source origin)
overload0:
    {
        unsigned int origin;
        uint32_t _origin;
        if (JS_ToUint32(ctx, &_origin, argv[0]))
            return JS_EXCEPTION;
        origin = (unsigned int)_origin;
        auto __arg0 = (::Ozone::HelpEvent::Source)origin;

        instance->SetOrigin(__arg0);

        return JS_UNDEFINED;
    }
}

static JSValue callback_class_Ozone_HelpEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "HelpEvent");
}

void finalizer_Ozone_HelpEvent(JSRuntime *rt, JSValue val)
{
    Ozone::HelpEvent* instance = (Ozone::HelpEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_HelpEvent
{
    "HelpEvent",
    .finalizer = finalizer_Ozone_HelpEvent
};

static JSCFunctionListEntry funcDef_Ozone_HelpEvent[]
{
    JS_CFUNC_DEF("SetPosition", 1, callback_method_Ozone_HelpEvent_SetPosition),
    JS_CFUNC_DEF("SetLink", 1, callback_method_Ozone_HelpEvent_SetLink),
    JS_CFUNC_DEF("SetTarget", 1, callback_method_Ozone_HelpEvent_SetTarget),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_HelpEvent_Clone),
    JS_CFUNC_DEF("GetOrigin", 0, callback_method_Ozone_HelpEvent_GetOrigin),
    JS_CFUNC_DEF("SetOrigin", 1, callback_method_Ozone_HelpEvent_SetOrigin),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_HelpEvent_toString),
};

static void register_class_Ozone_HelpEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "HelpEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_HelpEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_HelpEvent, &classDef_Ozone_HelpEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_HelpEvent, sizeof(funcDef_Ozone_HelpEvent) / sizeof(funcDef_Ozone_HelpEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_HelpEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_HelpEvent_HelpEvent, "HelpEvent", 4, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "HelpEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_HelpEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_CommandEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_ClipboardTextEvent;

// Ozone::ClipboardTextEvent::ClipboardTextEvent
static JSValue callback_method_Ozone_ClipboardTextEvent_ClipboardTextEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ClipboardTextEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ClipboardTextEvent(int type, int winid)
overload0:
    {
        int type;
        int32_t _type;
        if (JS_ToInt32(ctx, &_type, argv[0]))
            return JS_EXCEPTION;
        type = (int)_type;
        auto __arg0 = type;

        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[1]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg1 = winid;

        instance = new Ozone::ClipboardTextEvent(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_ClipboardTextEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_ClipboardTextEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::ClipboardTextEvent::Clone
static JSValue callback_method_Ozone_ClipboardTextEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ClipboardTextEvent* instance = (Ozone::ClipboardTextEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_ClipboardTextEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "ClipboardTextEvent");
}

void finalizer_Ozone_ClipboardTextEvent(JSRuntime *rt, JSValue val)
{
    Ozone::ClipboardTextEvent* instance = (Ozone::ClipboardTextEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_ClipboardTextEvent
{
    "ClipboardTextEvent",
    .finalizer = finalizer_Ozone_ClipboardTextEvent
};

static JSCFunctionListEntry funcDef_Ozone_ClipboardTextEvent[]
{
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_ClipboardTextEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_ClipboardTextEvent_toString),
};

static void register_class_Ozone_ClipboardTextEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "ClipboardTextEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_ClipboardTextEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_ClipboardTextEvent, &classDef_Ozone_ClipboardTextEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_ClipboardTextEvent, sizeof(funcDef_Ozone_ClipboardTextEvent) / sizeof(funcDef_Ozone_ClipboardTextEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_ClipboardTextEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_ClipboardTextEvent_ClipboardTextEvent, "ClipboardTextEvent", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "ClipboardTextEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_ClipboardTextEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_CommandEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_ContextMenuEvent;

// Ozone::ContextMenuEvent::ContextMenuEvent
static JSValue callback_method_Ozone_ContextMenuEvent_ContextMenuEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 3)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ContextMenuEvent* instance;

    if (JS_IsInt32(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsInt32(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsObject(argv[2]) || JS_IsNull(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ContextMenuEvent(int type, int winid, const ::Ozone::Point& pt)
overload0:
    {
        int type;
        int32_t _type;
        if (JS_ToInt32(ctx, &_type, argv[0]))
            return JS_EXCEPTION;
        type = (int)_type;
        auto __arg0 = type;

        int winid;
        int32_t _winid;
        if (JS_ToInt32(ctx, &_winid, argv[1]))
            return JS_EXCEPTION;
        winid = (int)_winid;
        auto __arg1 = winid;

        Ozone::Point* pt_instance = (Ozone::Point*) JS_Interop_GetInstance(argv[2], \
            classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg2 = *pt_instance;

        instance = new Ozone::ContextMenuEvent(__arg0, __arg1, __arg2);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_ContextMenuEvent);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_ContextMenuEvent);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::ContextMenuEvent::SetPosition
static JSValue callback_method_Ozone_ContextMenuEvent_SetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ContextMenuEvent* instance = (Ozone::ContextMenuEvent*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPosition(const ::Ozone::Point& pos)
overload0:
    {
        Ozone::Point* pos_instance = (Ozone::Point*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *pos_instance;

        instance->SetPosition(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::ContextMenuEvent::Clone
static JSValue callback_method_Ozone_ContextMenuEvent_Clone(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::ContextMenuEvent* instance = (Ozone::ContextMenuEvent*) JS_GetOpaque(this_val, 0);

    ::Ozone::Event* __ret = instance->Clone();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_ContextMenuEvent_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "ContextMenuEvent");
}

void finalizer_Ozone_ContextMenuEvent(JSRuntime *rt, JSValue val)
{
    Ozone::ContextMenuEvent* instance = (Ozone::ContextMenuEvent*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_ContextMenuEvent
{
    "ContextMenuEvent",
    .finalizer = finalizer_Ozone_ContextMenuEvent
};

static JSCFunctionListEntry funcDef_Ozone_ContextMenuEvent[]
{
    JS_CFUNC_DEF("SetPosition", 1, callback_method_Ozone_ContextMenuEvent_SetPosition),
    JS_CFUNC_DEF("Clone", 0, callback_method_Ozone_ContextMenuEvent_Clone),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_ContextMenuEvent_toString),
};

static void register_class_Ozone_ContextMenuEvent(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "ContextMenuEvent");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_ContextMenuEvent);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_ContextMenuEvent, &classDef_Ozone_ContextMenuEvent);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_ContextMenuEvent, sizeof(funcDef_Ozone_ContextMenuEvent) / sizeof(funcDef_Ozone_ContextMenuEvent[0]));
        JS_SetClassProto(ctx, classId_Ozone_ContextMenuEvent, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_ContextMenuEvent_ContextMenuEvent, "ContextMenuEvent", 3, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "ContextMenuEvent", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_ContextMenuEvent);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_CommandEvent);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_EvtHandler;

// Ozone::EvtHandler::EvtHandler
static JSValue callback_method_Ozone_EvtHandler_EvtHandler(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance;

    instance = new Ozone::EvtHandler();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_EvtHandler);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_EvtHandler);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::EvtHandler::GetNextHandler
static JSValue callback_method_Ozone_EvtHandler_GetNextHandler(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    ::Ozone::EvtHandler* __ret = instance->GetNextHandler();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_EvtHandler, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::EvtHandler::GetPreviousHandler
static JSValue callback_method_Ozone_EvtHandler_GetPreviousHandler(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    ::Ozone::EvtHandler* __ret = instance->GetPreviousHandler();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_EvtHandler, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::EvtHandler::SetNextHandler
static JSValue callback_method_Ozone_EvtHandler_SetNextHandler(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetNextHandler(::Ozone::EvtHandler* handler)
overload0:
    {
        Ozone::EvtHandler* handler_instance = (Ozone::EvtHandler*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_EvtHandler, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = handler_instance;

        instance->SetNextHandler(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::EvtHandler::SetPreviousHandler
static JSValue callback_method_Ozone_EvtHandler_SetPreviousHandler(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPreviousHandler(::Ozone::EvtHandler* handler)
overload0:
    {
        Ozone::EvtHandler* handler_instance = (Ozone::EvtHandler*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_EvtHandler, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = handler_instance;

        instance->SetPreviousHandler(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::EvtHandler::SetEvtHandlerEnabled
static JSValue callback_method_Ozone_EvtHandler_SetEvtHandlerEnabled(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetEvtHandlerEnabled(bool enabled)
overload0:
    {
        bool enabled;
        enabled = JS_ToBool(ctx, argv[0]);
        if (enabled == -1)
            return JS_EXCEPTION;
        auto __arg0 = enabled;

        instance->SetEvtHandlerEnabled(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::EvtHandler::GetEvtHandlerEnabled
static JSValue callback_method_Ozone_EvtHandler_GetEvtHandlerEnabled(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->GetEvtHandlerEnabled();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::EvtHandler::Unlink
static JSValue callback_method_Ozone_EvtHandler_Unlink(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    instance->Unlink();

    return JS_UNDEFINED;
}

// Ozone::EvtHandler::IsUnlinked
static JSValue callback_method_Ozone_EvtHandler_IsUnlinked(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsUnlinked();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::EvtHandler::ProcessEvent
static JSValue callback_method_Ozone_EvtHandler_ProcessEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool ProcessEvent(::Ozone::Event& event)
overload0:
    {
        Ozone::Event* event_instance = (Ozone::Event*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *event_instance;

        bool __ret = instance->ProcessEvent(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::EvtHandler::SafelyProcessEvent
static JSValue callback_method_Ozone_EvtHandler_SafelyProcessEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool SafelyProcessEvent(::Ozone::Event& event)
overload0:
    {
        Ozone::Event* event_instance = (Ozone::Event*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *event_instance;

        bool __ret = instance->SafelyProcessEvent(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::EvtHandler::ProcessEventLocally
static JSValue callback_method_Ozone_EvtHandler_ProcessEventLocally(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool ProcessEventLocally(::Ozone::Event& event)
overload0:
    {
        Ozone::Event* event_instance = (Ozone::Event*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *event_instance;

        bool __ret = instance->ProcessEventLocally(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::EvtHandler::QueueEvent
static JSValue callback_method_Ozone_EvtHandler_QueueEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void QueueEvent(::Ozone::Event* event)
overload0:
    {
        Ozone::Event* event_instance = (Ozone::Event*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = event_instance;

        instance->QueueEvent(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::EvtHandler::AddPendingEvent
static JSValue callback_method_Ozone_EvtHandler_AddPendingEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddPendingEvent(const ::Ozone::Event& event)
overload0:
    {
        Ozone::Event* event_instance = (Ozone::Event*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *event_instance;

        instance->AddPendingEvent(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::EvtHandler::ProcessPendingEvents
static JSValue callback_method_Ozone_EvtHandler_ProcessPendingEvents(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    instance->ProcessPendingEvents();

    return JS_UNDEFINED;
}

// Ozone::EvtHandler::DeletePendingEvents
static JSValue callback_method_Ozone_EvtHandler_DeletePendingEvents(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    instance->DeletePendingEvents();

    return JS_UNDEFINED;
}

// Ozone::EvtHandler::ProcessThreadEvent
static JSValue callback_method_Ozone_EvtHandler_ProcessThreadEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool ProcessThreadEvent(const ::Ozone::Event& event)
overload0:
    {
        Ozone::Event* event_instance = (Ozone::Event*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *event_instance;

        bool __ret = instance->ProcessThreadEvent(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::EvtHandler::SearchDynamicEventTable
static JSValue callback_method_Ozone_EvtHandler_SearchDynamicEventTable(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool SearchDynamicEventTable(::Ozone::Event& event)
overload0:
    {
        Ozone::Event* event_instance = (Ozone::Event*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *event_instance;

        bool __ret = instance->SearchDynamicEventTable(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::EvtHandler::ClearEventHashTable
static JSValue callback_method_Ozone_EvtHandler_ClearEventHashTable(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    instance->ClearEventHashTable();

    return JS_UNDEFINED;
}

// Ozone::EvtHandler::OnSinkDestroyed
static JSValue callback_method_Ozone_EvtHandler_OnSinkDestroyed(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void OnSinkDestroyed(::Ozone::EvtHandler* sink)
overload0:
    {
        Ozone::EvtHandler* sink_instance = (Ozone::EvtHandler*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_EvtHandler, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sink_instance;

        instance->OnSinkDestroyed(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::EvtHandler::WXConsumeException
static JSValue callback_method_Ozone_EvtHandler_WXConsumeException(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    ::Ozone::EvtHandler::WXConsumeException();

    return JS_UNDEFINED;
}

static JSValue callback_class_Ozone_EvtHandler_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "EvtHandler");
}

void finalizer_Ozone_EvtHandler(JSRuntime *rt, JSValue val)
{
    Ozone::EvtHandler* instance = (Ozone::EvtHandler*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_EvtHandler
{
    "EvtHandler",
    .finalizer = finalizer_Ozone_EvtHandler
};

static JSCFunctionListEntry funcDef_Ozone_EvtHandler[]
{
    JS_CFUNC_DEF("GetNextHandler", 0, callback_method_Ozone_EvtHandler_GetNextHandler),
    JS_CFUNC_DEF("GetPreviousHandler", 0, callback_method_Ozone_EvtHandler_GetPreviousHandler),
    JS_CFUNC_DEF("SetNextHandler", 1, callback_method_Ozone_EvtHandler_SetNextHandler),
    JS_CFUNC_DEF("SetPreviousHandler", 1, callback_method_Ozone_EvtHandler_SetPreviousHandler),
    JS_CFUNC_DEF("SetEvtHandlerEnabled", 1, callback_method_Ozone_EvtHandler_SetEvtHandlerEnabled),
    JS_CFUNC_DEF("GetEvtHandlerEnabled", 0, callback_method_Ozone_EvtHandler_GetEvtHandlerEnabled),
    JS_CFUNC_DEF("Unlink", 0, callback_method_Ozone_EvtHandler_Unlink),
    JS_CFUNC_DEF("IsUnlinked", 0, callback_method_Ozone_EvtHandler_IsUnlinked),
    JS_CFUNC_DEF("ProcessEvent", 1, callback_method_Ozone_EvtHandler_ProcessEvent),
    JS_CFUNC_DEF("SafelyProcessEvent", 1, callback_method_Ozone_EvtHandler_SafelyProcessEvent),
    JS_CFUNC_DEF("ProcessEventLocally", 1, callback_method_Ozone_EvtHandler_ProcessEventLocally),
    JS_CFUNC_DEF("QueueEvent", 1, callback_method_Ozone_EvtHandler_QueueEvent),
    JS_CFUNC_DEF("AddPendingEvent", 1, callback_method_Ozone_EvtHandler_AddPendingEvent),
    JS_CFUNC_DEF("ProcessPendingEvents", 0, callback_method_Ozone_EvtHandler_ProcessPendingEvents),
    JS_CFUNC_DEF("DeletePendingEvents", 0, callback_method_Ozone_EvtHandler_DeletePendingEvents),
    JS_CFUNC_DEF("ProcessThreadEvent", 1, callback_method_Ozone_EvtHandler_ProcessThreadEvent),
    JS_CFUNC_DEF("SearchDynamicEventTable", 1, callback_method_Ozone_EvtHandler_SearchDynamicEventTable),
    JS_CFUNC_DEF("ClearEventHashTable", 0, callback_method_Ozone_EvtHandler_ClearEventHashTable),
    JS_CFUNC_DEF("OnSinkDestroyed", 1, callback_method_Ozone_EvtHandler_OnSinkDestroyed),
    JS_CFUNC_DEF("WXConsumeException", 0, callback_method_Ozone_EvtHandler_WXConsumeException),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_EvtHandler_toString),
};

static void register_class_Ozone_EvtHandler(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "EvtHandler");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_EvtHandler);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_EvtHandler, &classDef_Ozone_EvtHandler);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_EvtHandler, sizeof(funcDef_Ozone_EvtHandler) / sizeof(funcDef_Ozone_EvtHandler[0]));
        JS_SetClassProto(ctx, classId_Ozone_EvtHandler, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_EvtHandler_EvtHandler, "EvtHandler", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "EvtHandler", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_EvtHandler);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Object);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

// Ozone::NewEventType
static JSValue callback_function_Ozone_NewEventType(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    int __ret = ::Ozone::NewEventType();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

static void register_function_Ozone_NewEventType(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "NewEventType");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_NewEventType, "NewEventType", 0);
    int status = JS_SetModuleExport(ctx, m, "NewEventType", val);
    assert(status != -1);
}

// Ozone::PostEvent
static JSValue callback_function_Ozone_PostEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]) || JS_IsNull(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void PostEvent(::Ozone::EvtHandler* dest, const ::Ozone::Event& event)
overload0:
    {
        Ozone::EvtHandler* dest_instance = (Ozone::EvtHandler*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_EvtHandler, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = dest_instance;

        Ozone::Event* event_instance = (Ozone::Event*) JS_Interop_GetInstance(argv[1], \
            classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *event_instance;

        ::Ozone::PostEvent(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

static void register_function_Ozone_PostEvent(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "PostEvent");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_PostEvent, "PostEvent", 2);
    int status = JS_SetModuleExport(ctx, m, "PostEvent", val);
    assert(status != -1);
}

// Ozone::QueueEvent
static JSValue callback_function_Ozone_QueueEvent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 2)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]) || JS_IsNull(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void QueueEvent(::Ozone::EvtHandler* dest, ::Ozone::Event* event)
overload0:
    {
        Ozone::EvtHandler* dest_instance = (Ozone::EvtHandler*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_EvtHandler, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = dest_instance;

        Ozone::Event* event_instance = (Ozone::Event*) JS_Interop_GetInstance(argv[1], \
            classId_Ozone_Event, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg1 = event_instance;

        ::Ozone::QueueEvent(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

static void register_function_Ozone_QueueEvent(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "QueueEvent");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_QueueEvent, "QueueEvent", 2);
    int status = JS_SetModuleExport(ctx, m, "QueueEvent", val);
    assert(status != -1);
}

// Ozone::FindFocusDescendant
static JSValue callback_function_Ozone_FindFocusDescendant(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc != 1)
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");

    if (JS_IsObject(argv[0]) || JS_IsNull(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Window* FindFocusDescendant(::Ozone::Window* ancestor)
overload0:
    {
        Ozone::Window* ancestor_instance = (Ozone::Window*) JS_Interop_GetInstance(argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = ancestor_instance;

        ::Ozone::Window* __ret = ::Ozone::FindFocusDescendant(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT, (void*) __ret);

        return ____ret;
    }
}

static void register_function_Ozone_FindFocusDescendant(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "FindFocusDescendant");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_FindFocusDescendant, "FindFocusDescendant", 1);
    int status = JS_SetModuleExport(ctx, m, "FindFocusDescendant", val);
    assert(status != -1);
}

void register_ozone_event(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (phase == 0)
    {
        register_enum_Ozone_EventCategory(ctx, m, set);

        register_enum_Ozone_IdleMode(ctx, m, set);

        register_enum_Ozone_MouseWheelAxis(ctx, m, set);

        register_enum_Ozone_UpdateUIMode(ctx, m, set);

        register_enum_Ozone_EventPropagation(ctx, m, set);

        register_enum_Ozone_JoystickButton(ctx, m, set);

        register_enum_Ozone_JoystickId(ctx, m, set);

        register_enum_Ozone_KeyCategoryFlags(ctx, m, set);

        register_function_Ozone_NewEventType(ctx, m, set);

        register_function_Ozone_PostEvent(ctx, m, set);

        register_function_Ozone_QueueEvent(ctx, m, set);

        register_function_Ozone_FindFocusDescendant(ctx, m, set);
    }

    register_class_Ozone_Event(ctx, m, set, phase);

    register_class_Ozone_PropagateOnce(ctx, m, set, phase);

    register_class_Ozone_IdleEvent(ctx, m, set, phase);

    register_class_Ozone_ThreadEvent(ctx, m, set, phase);

    register_class_Ozone_AsyncMethodCallEvent(ctx, m, set, phase);

    register_class_Ozone_CommandEvent(ctx, m, set, phase);

    register_class_Ozone_NotifyEvent(ctx, m, set, phase);

    register_class_Ozone_ScrollEvent(ctx, m, set, phase);

    register_class_Ozone_ScrollWinEvent(ctx, m, set, phase);

    register_class_Ozone_MouseEvent(ctx, m, set, phase);

    register_class_Ozone_SetCursorEvent(ctx, m, set, phase);

    register_class_Ozone_GestureEvent(ctx, m, set, phase);

    register_class_Ozone_PanGestureEvent(ctx, m, set, phase);

    register_class_Ozone_ZoomGestureEvent(ctx, m, set, phase);

    register_class_Ozone_RotateGestureEvent(ctx, m, set, phase);

    register_class_Ozone_TwoFingerTapEvent(ctx, m, set, phase);

    register_class_Ozone_LongPressEvent(ctx, m, set, phase);

    register_class_Ozone_PressAndTapEvent(ctx, m, set, phase);

    register_class_Ozone_KeyEvent(ctx, m, set, phase);

    register_class_Ozone_SizeEvent(ctx, m, set, phase);

    register_class_Ozone_MoveEvent(ctx, m, set, phase);

    register_class_Ozone_PaintEvent(ctx, m, set, phase);

    register_class_Ozone_NcPaintEvent(ctx, m, set, phase);

    register_class_Ozone_EraseEvent(ctx, m, set, phase);

    register_class_Ozone_FocusEvent(ctx, m, set, phase);

    register_class_Ozone_ChildFocusEvent(ctx, m, set, phase);

    register_class_Ozone_ActivateEvent(ctx, m, set, phase);

    register_class_Ozone_InitDialogEvent(ctx, m, set, phase);

    register_class_Ozone_MenuEvent(ctx, m, set, phase);

    register_class_Ozone_CloseEvent(ctx, m, set, phase);

    register_class_Ozone_ShowEvent(ctx, m, set, phase);

    register_class_Ozone_IconizeEvent(ctx, m, set, phase);

    register_class_Ozone_MaximizeEvent(ctx, m, set, phase);

    register_class_Ozone_JoystickEvent(ctx, m, set, phase);

    register_class_Ozone_UpdateUIEvent(ctx, m, set, phase);

    register_class_Ozone_SysColourChangedEvent(ctx, m, set, phase);

    register_class_Ozone_MouseCaptureChangedEvent(ctx, m, set, phase);

    register_class_Ozone_MouseCaptureLostEvent(ctx, m, set, phase);

    register_class_Ozone_DisplayChangedEvent(ctx, m, set, phase);

    register_class_Ozone_DPIChangedEvent(ctx, m, set, phase);

    register_class_Ozone_PaletteChangedEvent(ctx, m, set, phase);

    register_class_Ozone_QueryNewPaletteEvent(ctx, m, set, phase);

    register_class_Ozone_NavigationKeyEvent(ctx, m, set, phase);

    register_class_Ozone_WindowCreateEvent(ctx, m, set, phase);

    register_class_Ozone_WindowDestroyEvent(ctx, m, set, phase);

    register_class_Ozone_HelpEvent(ctx, m, set, phase);

    register_class_Ozone_ClipboardTextEvent(ctx, m, set, phase);

    register_class_Ozone_ContextMenuEvent(ctx, m, set, phase);

    register_class_Ozone_EvtHandler(ctx, m, set, phase);
}

} // extern "C"
