// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <quickjs.h>
#include <assert.h>
#include <ozone/gdicmn.h>

extern "C" {

extern JSClassID classId_Ozone_Size;
extern JSClassID classId_Ozone_Point;
extern JSClassID classId_Ozone_RealPoint;
extern JSClassID classId_Ozone_wxPointListNode;
extern JSClassID classId_Ozone_Rect;
extern JSClassID classId_Ozone_GDIObjListBase;
extern JSClassID classId_Ozone_ColourDatabase;
extern JSClassID classId_Ozone_Color;
extern JSClassID classId_Ozone_ResourceCache;
extern JSClassID classId_Ozone_StockGDI;
extern JSClassID classId_Ozone_Brush;
extern JSClassID classId_Ozone_Pen;

static void register_enum_Ozone_BitmapType(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "BitmapType");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // INVALID
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "INVALID", __item);
    }

    // BMP
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "BMP", __item);
    }

    // BMP_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "BMP_RESOURCE", __item);
    }

    // RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "RESOURCE", __item);
    }

    // ICO
    {
        JSValue __item = JS_NewUint32(ctx, 3);
        JS_SetPropertyStr(ctx, val, "ICO", __item);
    }

    // ICO_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 4);
        JS_SetPropertyStr(ctx, val, "ICO_RESOURCE", __item);
    }

    // CUR
    {
        JSValue __item = JS_NewUint32(ctx, 5);
        JS_SetPropertyStr(ctx, val, "CUR", __item);
    }

    // CUR_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 6);
        JS_SetPropertyStr(ctx, val, "CUR_RESOURCE", __item);
    }

    // XBM
    {
        JSValue __item = JS_NewUint32(ctx, 7);
        JS_SetPropertyStr(ctx, val, "XBM", __item);
    }

    // XBM_DATA
    {
        JSValue __item = JS_NewUint32(ctx, 8);
        JS_SetPropertyStr(ctx, val, "XBM_DATA", __item);
    }

    // XPM
    {
        JSValue __item = JS_NewUint32(ctx, 9);
        JS_SetPropertyStr(ctx, val, "XPM", __item);
    }

    // XPM_DATA
    {
        JSValue __item = JS_NewUint32(ctx, 10);
        JS_SetPropertyStr(ctx, val, "XPM_DATA", __item);
    }

    // TIFF
    {
        JSValue __item = JS_NewUint32(ctx, 11);
        JS_SetPropertyStr(ctx, val, "TIFF", __item);
    }

    // TIF
    {
        JSValue __item = JS_NewUint32(ctx, 11);
        JS_SetPropertyStr(ctx, val, "TIF", __item);
    }

    // TIFF_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 12);
        JS_SetPropertyStr(ctx, val, "TIFF_RESOURCE", __item);
    }

    // TIF_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 12);
        JS_SetPropertyStr(ctx, val, "TIF_RESOURCE", __item);
    }

    // GIF
    {
        JSValue __item = JS_NewUint32(ctx, 13);
        JS_SetPropertyStr(ctx, val, "GIF", __item);
    }

    // GIF_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 14);
        JS_SetPropertyStr(ctx, val, "GIF_RESOURCE", __item);
    }

    // PNG
    {
        JSValue __item = JS_NewUint32(ctx, 15);
        JS_SetPropertyStr(ctx, val, "PNG", __item);
    }

    // PNG_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 16);
        JS_SetPropertyStr(ctx, val, "PNG_RESOURCE", __item);
    }

    // JPEG
    {
        JSValue __item = JS_NewUint32(ctx, 17);
        JS_SetPropertyStr(ctx, val, "JPEG", __item);
    }

    // JPEG_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 18);
        JS_SetPropertyStr(ctx, val, "JPEG_RESOURCE", __item);
    }

    // PNM
    {
        JSValue __item = JS_NewUint32(ctx, 19);
        JS_SetPropertyStr(ctx, val, "PNM", __item);
    }

    // PNM_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 20);
        JS_SetPropertyStr(ctx, val, "PNM_RESOURCE", __item);
    }

    // PCX
    {
        JSValue __item = JS_NewUint32(ctx, 21);
        JS_SetPropertyStr(ctx, val, "PCX", __item);
    }

    // PCX_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 22);
        JS_SetPropertyStr(ctx, val, "PCX_RESOURCE", __item);
    }

    // PICT
    {
        JSValue __item = JS_NewUint32(ctx, 23);
        JS_SetPropertyStr(ctx, val, "PICT", __item);
    }

    // PICT_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 24);
        JS_SetPropertyStr(ctx, val, "PICT_RESOURCE", __item);
    }

    // ICON
    {
        JSValue __item = JS_NewUint32(ctx, 25);
        JS_SetPropertyStr(ctx, val, "ICON", __item);
    }

    // ICON_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 26);
        JS_SetPropertyStr(ctx, val, "ICON_RESOURCE", __item);
    }

    // ANI
    {
        JSValue __item = JS_NewUint32(ctx, 27);
        JS_SetPropertyStr(ctx, val, "ANI", __item);
    }

    // IFF
    {
        JSValue __item = JS_NewUint32(ctx, 28);
        JS_SetPropertyStr(ctx, val, "IFF", __item);
    }

    // TGA
    {
        JSValue __item = JS_NewUint32(ctx, 29);
        JS_SetPropertyStr(ctx, val, "TGA", __item);
    }

    // MACCURSOR
    {
        JSValue __item = JS_NewUint32(ctx, 30);
        JS_SetPropertyStr(ctx, val, "MACCURSOR", __item);
    }

    // MACCURSOR_RESOURCE
    {
        JSValue __item = JS_NewUint32(ctx, 31);
        JS_SetPropertyStr(ctx, val, "MACCURSOR_RESOURCE", __item);
    }

    // MAX
    {
        JSValue __item = JS_NewUint32(ctx, 32);
        JS_SetPropertyStr(ctx, val, "MAX", __item);
    }

    // ANY
    {
        JSValue __item = JS_NewUint32(ctx, 50);
        JS_SetPropertyStr(ctx, val, "ANY", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "BitmapType", val);
    assert(status != -1);
}

static void register_enum_Ozone_EllipsizeFlags(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "EllipsizeFlags");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // NONE
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "NONE", __item);
    }

    // PROCESS_MNEMONICS
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "PROCESS_MNEMONICS", __item);
    }

    // EXPAND_TABS
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "EXPAND_TABS", __item);
    }

    // DEFAULT
    {
        JSValue __item = JS_NewUint32(ctx, 3);
        JS_SetPropertyStr(ctx, val, "DEFAULT", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "EllipsizeFlags", val);
    assert(status != -1);
}

static void register_enum_Ozone_EllipsizeMode(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "EllipsizeMode");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // NONE
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "NONE", __item);
    }

    // START
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "START", __item);
    }

    // MIDDLE
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "MIDDLE", __item);
    }

    // END
    {
        JSValue __item = JS_NewUint32(ctx, 3);
        JS_SetPropertyStr(ctx, val, "END", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "EllipsizeMode", val);
    assert(status != -1);
}

static void register_enum_Ozone_PolygonFillMode(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "PolygonFillMode");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // ODDEVEN_RULE
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "ODDEVEN_RULE", __item);
    }

    // WINDING_RULE
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "WINDING_RULE", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "PolygonFillMode", val);
    assert(status != -1);
}

static void register_enum_Ozone_StockCursor(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "StockCursor");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // NONE
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "NONE", __item);
    }

    // ARROW
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "ARROW", __item);
    }

    // RIGHT_ARROW
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "RIGHT_ARROW", __item);
    }

    // BULLSEYE
    {
        JSValue __item = JS_NewUint32(ctx, 3);
        JS_SetPropertyStr(ctx, val, "BULLSEYE", __item);
    }

    // CHAR
    {
        JSValue __item = JS_NewUint32(ctx, 4);
        JS_SetPropertyStr(ctx, val, "CHAR", __item);
    }

    // CROSS
    {
        JSValue __item = JS_NewUint32(ctx, 5);
        JS_SetPropertyStr(ctx, val, "CROSS", __item);
    }

    // HAND
    {
        JSValue __item = JS_NewUint32(ctx, 6);
        JS_SetPropertyStr(ctx, val, "HAND", __item);
    }

    // IBEAM
    {
        JSValue __item = JS_NewUint32(ctx, 7);
        JS_SetPropertyStr(ctx, val, "IBEAM", __item);
    }

    // LEFT_BUTTON
    {
        JSValue __item = JS_NewUint32(ctx, 8);
        JS_SetPropertyStr(ctx, val, "LEFT_BUTTON", __item);
    }

    // MAGNIFIER
    {
        JSValue __item = JS_NewUint32(ctx, 9);
        JS_SetPropertyStr(ctx, val, "MAGNIFIER", __item);
    }

    // MIDDLE_BUTTON
    {
        JSValue __item = JS_NewUint32(ctx, 10);
        JS_SetPropertyStr(ctx, val, "MIDDLE_BUTTON", __item);
    }

    // NO_ENTRY
    {
        JSValue __item = JS_NewUint32(ctx, 11);
        JS_SetPropertyStr(ctx, val, "NO_ENTRY", __item);
    }

    // PAINT_BRUSH
    {
        JSValue __item = JS_NewUint32(ctx, 12);
        JS_SetPropertyStr(ctx, val, "PAINT_BRUSH", __item);
    }

    // PENCIL
    {
        JSValue __item = JS_NewUint32(ctx, 13);
        JS_SetPropertyStr(ctx, val, "PENCIL", __item);
    }

    // POINT_LEFT
    {
        JSValue __item = JS_NewUint32(ctx, 14);
        JS_SetPropertyStr(ctx, val, "POINT_LEFT", __item);
    }

    // POINT_RIGHT
    {
        JSValue __item = JS_NewUint32(ctx, 15);
        JS_SetPropertyStr(ctx, val, "POINT_RIGHT", __item);
    }

    // QUESTION_ARROW
    {
        JSValue __item = JS_NewUint32(ctx, 16);
        JS_SetPropertyStr(ctx, val, "QUESTION_ARROW", __item);
    }

    // RIGHT_BUTTON
    {
        JSValue __item = JS_NewUint32(ctx, 17);
        JS_SetPropertyStr(ctx, val, "RIGHT_BUTTON", __item);
    }

    // SIZENESW
    {
        JSValue __item = JS_NewUint32(ctx, 18);
        JS_SetPropertyStr(ctx, val, "SIZENESW", __item);
    }

    // SIZENS
    {
        JSValue __item = JS_NewUint32(ctx, 19);
        JS_SetPropertyStr(ctx, val, "SIZENS", __item);
    }

    // SIZENWSE
    {
        JSValue __item = JS_NewUint32(ctx, 20);
        JS_SetPropertyStr(ctx, val, "SIZENWSE", __item);
    }

    // SIZEWE
    {
        JSValue __item = JS_NewUint32(ctx, 21);
        JS_SetPropertyStr(ctx, val, "SIZEWE", __item);
    }

    // SIZING
    {
        JSValue __item = JS_NewUint32(ctx, 22);
        JS_SetPropertyStr(ctx, val, "SIZING", __item);
    }

    // SPRAYCAN
    {
        JSValue __item = JS_NewUint32(ctx, 23);
        JS_SetPropertyStr(ctx, val, "SPRAYCAN", __item);
    }

    // WAIT
    {
        JSValue __item = JS_NewUint32(ctx, 24);
        JS_SetPropertyStr(ctx, val, "WAIT", __item);
    }

    // WATCH
    {
        JSValue __item = JS_NewUint32(ctx, 25);
        JS_SetPropertyStr(ctx, val, "WATCH", __item);
    }

    // BLANK
    {
        JSValue __item = JS_NewUint32(ctx, 26);
        JS_SetPropertyStr(ctx, val, "BLANK", __item);
    }

    // DEFAULT
    {
        JSValue __item = JS_NewUint32(ctx, 27);
        JS_SetPropertyStr(ctx, val, "DEFAULT", __item);
    }

    // ARROWWAIT
    {
        JSValue __item = JS_NewUint32(ctx, 28);
        JS_SetPropertyStr(ctx, val, "ARROWWAIT", __item);
    }

    // MAX
    {
        JSValue __item = JS_NewUint32(ctx, 29);
        JS_SetPropertyStr(ctx, val, "MAX", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "StockCursor", val);
    assert(status != -1);
}

JSClassID classId_Ozone_Size;

// Ozone::Size::Size
static JSValue callback_method_Ozone_Size_Size(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance;

    if (argc == 0)
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // Size()
overload0:
    {
        instance = new Ozone::Size();

        goto wrap;
    }

    // Size(int xx, int yy)
overload1:
    {
        int xx;
        if (JS_ToInt32(ctx, (int32_t*) &xx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = xx;
        int yy;
        if (JS_ToInt32(ctx, (int32_t*) &yy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = yy;
        instance = new Ozone::Size(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_Size);
    else
        proto = JS_GetPropertyStr(ctx, this_val, "prototype");

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_Size);
    JS_SetOpaque(__obj, instance);

    JS_FreeValue(ctx, proto);

    return __obj;
}

// Ozone::Size::IncTo
static JSValue callback_method_Ozone_Size_IncTo(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void IncTo(const ::Ozone::Size& sz)
overload0:
    {
        Ozone::Size* sz_instance = (Ozone::Size*) JS_GetOpaque(argv[0], classId_Ozone_Size);

        auto &__arg0 = *sz_instance;
        instance->IncTo(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Size::DecTo
static JSValue callback_method_Ozone_Size_DecTo(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DecTo(const ::Ozone::Size& sz)
overload0:
    {
        Ozone::Size* sz_instance = (Ozone::Size*) JS_GetOpaque(argv[0], classId_Ozone_Size);

        auto &__arg0 = *sz_instance;
        instance->DecTo(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Size::DecToIfSpecified
static JSValue callback_method_Ozone_Size_DecToIfSpecified(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DecToIfSpecified(const ::Ozone::Size& sz)
overload0:
    {
        Ozone::Size* sz_instance = (Ozone::Size*) JS_GetOpaque(argv[0], classId_Ozone_Size);

        auto &__arg0 = *sz_instance;
        instance->DecToIfSpecified(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Size::IncBy
static JSValue callback_method_Ozone_Size_IncBy(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto overload2;

    if (JS_IsObject(argv[0]))
        goto overload3;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void IncBy(int dx, int dy)
overload0:
    {
        int dx;
        if (JS_ToInt32(ctx, (int32_t*) &dx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = dx;
        int dy;
        if (JS_ToInt32(ctx, (int32_t*) &dy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = dy;
        instance->IncBy(__arg0, __arg1);


        return JS_UNDEFINED;
    }

    // void IncBy(const ::Ozone::Point& pt)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        instance->IncBy(__arg0);


        return JS_UNDEFINED;
    }

    // void IncBy(const ::Ozone::Size& sz)
overload2:
    {
        Ozone::Size* sz_instance = (Ozone::Size*) JS_GetOpaque(argv[0], classId_Ozone_Size);

        auto &__arg0 = *sz_instance;
        instance->IncBy(__arg0);


        return JS_UNDEFINED;
    }

    // void IncBy(int d)
overload3:
    {
        int d;
        if (JS_ToInt32(ctx, (int32_t*) &d, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = d;
        instance->IncBy(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Size::DecBy
static JSValue callback_method_Ozone_Size_DecBy(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto overload2;

    if (JS_IsObject(argv[0]))
        goto overload3;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DecBy(int dx, int dy)
overload0:
    {
        int dx;
        if (JS_ToInt32(ctx, (int32_t*) &dx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = dx;
        int dy;
        if (JS_ToInt32(ctx, (int32_t*) &dy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = dy;
        instance->DecBy(__arg0, __arg1);


        return JS_UNDEFINED;
    }

    // void DecBy(const ::Ozone::Point& pt)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        instance->DecBy(__arg0);


        return JS_UNDEFINED;
    }

    // void DecBy(const ::Ozone::Size& sz)
overload2:
    {
        Ozone::Size* sz_instance = (Ozone::Size*) JS_GetOpaque(argv[0], classId_Ozone_Size);

        auto &__arg0 = *sz_instance;
        instance->DecBy(__arg0);


        return JS_UNDEFINED;
    }

    // void DecBy(int d)
overload3:
    {
        int d;
        if (JS_ToInt32(ctx, (int32_t*) &d, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = d;
        instance->DecBy(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Size::Set
static JSValue callback_method_Ozone_Size_Set(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Set(int xx, int yy)
overload0:
    {
        int xx;
        if (JS_ToInt32(ctx, (int32_t*) &xx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = xx;
        int yy;
        if (JS_ToInt32(ctx, (int32_t*) &yy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = yy;
        instance->Set(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::Size::SetWidth
static JSValue callback_method_Ozone_Size_SetWidth(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetWidth(int w)
overload0:
    {
        int w;
        if (JS_ToInt32(ctx, (int32_t*) &w, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = w;
        instance->SetWidth(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Size::SetHeight
static JSValue callback_method_Ozone_Size_SetHeight(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetHeight(int h)
overload0:
    {
        int h;
        if (JS_ToInt32(ctx, (int32_t*) &h, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = h;
        instance->SetHeight(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Size::GetWidth
static JSValue callback_method_Ozone_Size_GetWidth(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    int __ret = instance->GetWidth();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Size::GetHeight
static JSValue callback_method_Ozone_Size_GetHeight(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    int __ret = instance->GetHeight();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Size::IsFullySpecified
static JSValue callback_method_Ozone_Size_IsFullySpecified(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    bool __ret = instance->IsFullySpecified();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::Size::SetDefaults
static JSValue callback_method_Ozone_Size_SetDefaults(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetDefaults(const ::Ozone::Size& size)
overload0:
    {
        Ozone::Size* size_instance = (Ozone::Size*) JS_GetOpaque(argv[0], classId_Ozone_Size);

        auto &__arg0 = *size_instance;
        instance->SetDefaults(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Size::GetX
static JSValue callback_method_Ozone_Size_GetX(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    int __ret = instance->GetX();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Size::GetY
static JSValue callback_method_Ozone_Size_GetY(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    int __ret = instance->GetY();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Size::get_x
static JSValue callback_method_Ozone_Size_get_x(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    int __ret = instance->get_x();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Size::set_x
static JSValue callback_method_Ozone_Size_set_x(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_x(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_x(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Size::get_y
static JSValue callback_method_Ozone_Size_get_y(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    int __ret = instance->get_y();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Size::set_y
static JSValue callback_method_Ozone_Size_set_y(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Size* instance = (Ozone::Size*) JS_GetOpaque(this_val, classId_Ozone_Size);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_y(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_y(__arg0);

        return JS_UNDEFINED;
    }
}
static JSClassDef classDef_Ozone_Size
{
    "Size",
};

static JSCFunctionListEntry funcDef_Ozone_Size[]
{
    JS_CFUNC_DEF("IncTo", 1, callback_method_Ozone_Size_IncTo),
    JS_CFUNC_DEF("DecTo", 1, callback_method_Ozone_Size_DecTo),
    JS_CFUNC_DEF("DecToIfSpecified", 1, callback_method_Ozone_Size_DecToIfSpecified),
    JS_CFUNC_DEF("IncBy", 2, callback_method_Ozone_Size_IncBy),
    JS_CFUNC_DEF("DecBy", 2, callback_method_Ozone_Size_DecBy),
    JS_CFUNC_DEF("Set", 2, callback_method_Ozone_Size_Set),
    JS_CFUNC_DEF("SetWidth", 1, callback_method_Ozone_Size_SetWidth),
    JS_CFUNC_DEF("SetHeight", 1, callback_method_Ozone_Size_SetHeight),
    JS_CFUNC_DEF("GetWidth", 0, callback_method_Ozone_Size_GetWidth),
    JS_CFUNC_DEF("GetHeight", 0, callback_method_Ozone_Size_GetHeight),
    JS_CFUNC_DEF("IsFullySpecified", 0, callback_method_Ozone_Size_IsFullySpecified),
    JS_CFUNC_DEF("SetDefaults", 1, callback_method_Ozone_Size_SetDefaults),
    JS_CFUNC_DEF("GetX", 0, callback_method_Ozone_Size_GetX),
    JS_CFUNC_DEF("GetY", 0, callback_method_Ozone_Size_GetY),
    JS_CFUNC_DEF("get_x", 0, callback_method_Ozone_Size_get_x),
    JS_CFUNC_DEF("set_x", 1, callback_method_Ozone_Size_set_x),
    JS_CFUNC_DEF("get_y", 0, callback_method_Ozone_Size_get_y),
    JS_CFUNC_DEF("set_y", 1, callback_method_Ozone_Size_set_y),
};


static void register_class_Ozone_Size(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "Size");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_Size);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_Size, &classDef_Ozone_Size);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_Size, sizeof(funcDef_Ozone_Size) / sizeof(funcDef_Ozone_Size[0]));
        JS_SetClassProto(ctx, classId_Ozone_Size, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_Size_Size, "Size", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "Size", ctor);
    }
}

JSClassID classId_Ozone_RealPoint;

// Ozone::RealPoint::RealPoint
static JSValue callback_method_Ozone_RealPoint_RealPoint(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::RealPoint* instance;

    if (argc == 0)
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto overload2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // RealPoint()
overload0:
    {
        instance = new Ozone::RealPoint();

        goto wrap;
    }

    // RealPoint(double xx, double yy)
overload1:
    {
        double xx;
        if (JS_ToFloat64(ctx, &xx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = xx;
        double yy;
        if (JS_ToFloat64(ctx, &yy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = yy;
        instance = new Ozone::RealPoint(__arg0, __arg1);

        goto wrap;
    }

    // RealPoint(const ::Ozone::Point& pt)
overload2:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        instance = new Ozone::RealPoint(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_RealPoint);
    else
        proto = JS_GetPropertyStr(ctx, this_val, "prototype");

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_RealPoint);
    JS_SetOpaque(__obj, instance);

    JS_FreeValue(ctx, proto);

    return __obj;
}

// Ozone::RealPoint::get_x
static JSValue callback_method_Ozone_RealPoint_get_x(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::RealPoint* instance = (Ozone::RealPoint*) JS_GetOpaque(this_val, classId_Ozone_RealPoint);

    double __ret = instance->get_x();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::RealPoint::set_x
static JSValue callback_method_Ozone_RealPoint_set_x(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::RealPoint* instance = (Ozone::RealPoint*) JS_GetOpaque(this_val, classId_Ozone_RealPoint);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_x(double value)
overload0:
    {
        double value;
        if (JS_ToFloat64(ctx, &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_x(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::RealPoint::get_y
static JSValue callback_method_Ozone_RealPoint_get_y(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::RealPoint* instance = (Ozone::RealPoint*) JS_GetOpaque(this_val, classId_Ozone_RealPoint);

    double __ret = instance->get_y();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::RealPoint::set_y
static JSValue callback_method_Ozone_RealPoint_set_y(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::RealPoint* instance = (Ozone::RealPoint*) JS_GetOpaque(this_val, classId_Ozone_RealPoint);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_y(double value)
overload0:
    {
        double value;
        if (JS_ToFloat64(ctx, &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_y(__arg0);

        return JS_UNDEFINED;
    }
}
static JSClassDef classDef_Ozone_RealPoint
{
    "RealPoint",
};

static JSCFunctionListEntry funcDef_Ozone_RealPoint[]
{
    JS_CFUNC_DEF("get_x", 0, callback_method_Ozone_RealPoint_get_x),
    JS_CFUNC_DEF("set_x", 1, callback_method_Ozone_RealPoint_set_x),
    JS_CFUNC_DEF("get_y", 0, callback_method_Ozone_RealPoint_get_y),
    JS_CFUNC_DEF("set_y", 1, callback_method_Ozone_RealPoint_set_y),
};


static void register_class_Ozone_RealPoint(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "RealPoint");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_RealPoint);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_RealPoint, &classDef_Ozone_RealPoint);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_RealPoint, sizeof(funcDef_Ozone_RealPoint) / sizeof(funcDef_Ozone_RealPoint[0]));
        JS_SetClassProto(ctx, classId_Ozone_RealPoint, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_RealPoint_RealPoint, "RealPoint", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "RealPoint", ctor);
    }
}

JSClassID classId_Ozone_Point;

// Ozone::Point::Point
static JSValue callback_method_Ozone_Point_Point(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Point* instance;

    if (argc == 0)
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto overload2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // Point()
overload0:
    {
        instance = new Ozone::Point();

        goto wrap;
    }

    // Point(int xx, int yy)
overload1:
    {
        int xx;
        if (JS_ToInt32(ctx, (int32_t*) &xx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = xx;
        int yy;
        if (JS_ToInt32(ctx, (int32_t*) &yy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = yy;
        instance = new Ozone::Point(__arg0, __arg1);

        goto wrap;
    }

    // Point(const ::Ozone::RealPoint& pt)
overload2:
    {
        Ozone::RealPoint* pt_instance = (Ozone::RealPoint*) JS_GetOpaque(argv[0], classId_Ozone_RealPoint);

        auto &__arg0 = *pt_instance;
        instance = new Ozone::Point(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_Point);
    else
        proto = JS_GetPropertyStr(ctx, this_val, "prototype");

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_Point);
    JS_SetOpaque(__obj, instance);

    JS_FreeValue(ctx, proto);

    return __obj;
}

// Ozone::Point::IsFullySpecified
static JSValue callback_method_Ozone_Point_IsFullySpecified(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Point* instance = (Ozone::Point*) JS_GetOpaque(this_val, classId_Ozone_Point);

    bool __ret = instance->IsFullySpecified();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::Point::SetDefaults
static JSValue callback_method_Ozone_Point_SetDefaults(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Point* instance = (Ozone::Point*) JS_GetOpaque(this_val, classId_Ozone_Point);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetDefaults(const ::Ozone::Point& pt)
overload0:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        instance->SetDefaults(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Point::get_x
static JSValue callback_method_Ozone_Point_get_x(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Point* instance = (Ozone::Point*) JS_GetOpaque(this_val, classId_Ozone_Point);

    int __ret = instance->get_x();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Point::set_x
static JSValue callback_method_Ozone_Point_set_x(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Point* instance = (Ozone::Point*) JS_GetOpaque(this_val, classId_Ozone_Point);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_x(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_x(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Point::get_y
static JSValue callback_method_Ozone_Point_get_y(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Point* instance = (Ozone::Point*) JS_GetOpaque(this_val, classId_Ozone_Point);

    int __ret = instance->get_y();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Point::set_y
static JSValue callback_method_Ozone_Point_set_y(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Point* instance = (Ozone::Point*) JS_GetOpaque(this_val, classId_Ozone_Point);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_y(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_y(__arg0);

        return JS_UNDEFINED;
    }
}
static JSClassDef classDef_Ozone_Point
{
    "Point",
};

static JSCFunctionListEntry funcDef_Ozone_Point[]
{
    JS_CFUNC_DEF("IsFullySpecified", 0, callback_method_Ozone_Point_IsFullySpecified),
    JS_CFUNC_DEF("SetDefaults", 1, callback_method_Ozone_Point_SetDefaults),
    JS_CFUNC_DEF("get_x", 0, callback_method_Ozone_Point_get_x),
    JS_CFUNC_DEF("set_x", 1, callback_method_Ozone_Point_set_x),
    JS_CFUNC_DEF("get_y", 0, callback_method_Ozone_Point_get_y),
    JS_CFUNC_DEF("set_y", 1, callback_method_Ozone_Point_set_y),
};


static void register_class_Ozone_Point(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "Point");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_Point);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_Point, &classDef_Ozone_Point);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_Point, sizeof(funcDef_Ozone_Point) / sizeof(funcDef_Ozone_Point[0]));
        JS_SetClassProto(ctx, classId_Ozone_Point, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_Point_Point, "Point", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "Point", ctor);
    }
}

JSClassID classId_Ozone_wxPointListNode;

// Ozone::wxPointListNode::GetNext
static JSValue callback_method_Ozone_wxPointListNode_GetNext(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::wxPointListNode* instance = (Ozone::wxPointListNode*) JS_GetOpaque(this_val, classId_Ozone_wxPointListNode);

    ::Ozone::wxPointListNode* __ret = instance->GetNext();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::wxPointListNode::GetPrevious
static JSValue callback_method_Ozone_wxPointListNode_GetPrevious(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::wxPointListNode* instance = (Ozone::wxPointListNode*) JS_GetOpaque(this_val, classId_Ozone_wxPointListNode);

    ::Ozone::wxPointListNode* __ret = instance->GetPrevious();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::wxPointListNode::GetData
static JSValue callback_method_Ozone_wxPointListNode_GetData(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::wxPointListNode* instance = (Ozone::wxPointListNode*) JS_GetOpaque(this_val, classId_Ozone_wxPointListNode);

    ::Ozone::Point* __ret = instance->GetData();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::wxPointListNode::SetData
static JSValue callback_method_Ozone_wxPointListNode_SetData(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::wxPointListNode* instance = (Ozone::wxPointListNode*) JS_GetOpaque(this_val, classId_Ozone_wxPointListNode);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetData(::Ozone::Point* data)
overload0:
    {
        Ozone::Point* data_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto __arg0 = data_instance;
        instance->SetData(__arg0);

        return JS_UNDEFINED;
    }
}
static JSClassDef classDef_Ozone_wxPointListNode
{
    "wxPointListNode",
};

static JSCFunctionListEntry funcDef_Ozone_wxPointListNode[]
{
    JS_CFUNC_DEF("GetNext", 0, callback_method_Ozone_wxPointListNode_GetNext),
    JS_CFUNC_DEF("GetPrevious", 0, callback_method_Ozone_wxPointListNode_GetPrevious),
    JS_CFUNC_DEF("GetData", 0, callback_method_Ozone_wxPointListNode_GetData),
    JS_CFUNC_DEF("SetData", 1, callback_method_Ozone_wxPointListNode_SetData),
};


static void register_class_Ozone_wxPointListNode(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "wxPointListNode");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_wxPointListNode);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_wxPointListNode, &classDef_Ozone_wxPointListNode);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_wxPointListNode, sizeof(funcDef_Ozone_wxPointListNode) / sizeof(funcDef_Ozone_wxPointListNode[0]));
        JS_SetClassProto(ctx, classId_Ozone_wxPointListNode, proto);

    }
}

JSClassID classId_Ozone_Rect;

// Ozone::Rect::Rect
static JSValue callback_method_Ozone_Rect_Rect(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance;

    if (argc == 0)
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsObject(argv[0]))
        goto overload4;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto overload2;

    if (JS_IsObject(argv[1]))
        goto overload3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[3]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // Rect()
overload0:
    {
        instance = new Ozone::Rect();

        goto wrap;
    }

    // Rect(int xx, int yy, int ww, int hh)
overload1:
    {
        int xx;
        if (JS_ToInt32(ctx, (int32_t*) &xx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = xx;
        int yy;
        if (JS_ToInt32(ctx, (int32_t*) &yy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = yy;
        int ww;
        if (JS_ToInt32(ctx, (int32_t*) &ww, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = ww;
        int hh;
        if (JS_ToInt32(ctx, (int32_t*) &hh, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = hh;
        instance = new Ozone::Rect(__arg0, __arg1, __arg2, __arg3);

        goto wrap;
    }

    // Rect(const ::Ozone::Point& topLeft, const ::Ozone::Point& bottomRight)
overload2:
    {
        Ozone::Point* topLeft_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *topLeft_instance;
        Ozone::Point* bottomRight_instance = (Ozone::Point*) JS_GetOpaque(argv[1], classId_Ozone_Point);

        auto &__arg1 = *bottomRight_instance;
        instance = new Ozone::Rect(__arg0, __arg1);

        goto wrap;
    }

    // Rect(const ::Ozone::Point& pt, const ::Ozone::Size& size)
overload3:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        Ozone::Size* size_instance = (Ozone::Size*) JS_GetOpaque(argv[1], classId_Ozone_Size);

        auto &__arg1 = *size_instance;
        instance = new Ozone::Rect(__arg0, __arg1);

        goto wrap;
    }

    // Rect(const ::Ozone::Size& size)
overload4:
    {
        Ozone::Size* size_instance = (Ozone::Size*) JS_GetOpaque(argv[0], classId_Ozone_Size);

        auto &__arg0 = *size_instance;
        instance = new Ozone::Rect(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_Rect);
    else
        proto = JS_GetPropertyStr(ctx, this_val, "prototype");

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_Rect);
    JS_SetOpaque(__obj, instance);

    JS_FreeValue(ctx, proto);

    return __obj;
}

// Ozone::Rect::GetX
static JSValue callback_method_Ozone_Rect_GetX(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->GetX();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::SetX
static JSValue callback_method_Ozone_Rect_SetX(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetX(int xx)
overload0:
    {
        int xx;
        if (JS_ToInt32(ctx, (int32_t*) &xx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = xx;
        instance->SetX(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::GetY
static JSValue callback_method_Ozone_Rect_GetY(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->GetY();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::SetY
static JSValue callback_method_Ozone_Rect_SetY(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetY(int yy)
overload0:
    {
        int yy;
        if (JS_ToInt32(ctx, (int32_t*) &yy, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = yy;
        instance->SetY(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::GetWidth
static JSValue callback_method_Ozone_Rect_GetWidth(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->GetWidth();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::SetWidth
static JSValue callback_method_Ozone_Rect_SetWidth(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetWidth(int w)
overload0:
    {
        int w;
        if (JS_ToInt32(ctx, (int32_t*) &w, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = w;
        instance->SetWidth(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::GetHeight
static JSValue callback_method_Ozone_Rect_GetHeight(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->GetHeight();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::SetHeight
static JSValue callback_method_Ozone_Rect_SetHeight(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetHeight(int h)
overload0:
    {
        int h;
        if (JS_ToInt32(ctx, (int32_t*) &h, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = h;
        instance->SetHeight(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::GetPosition
static JSValue callback_method_Ozone_Rect_GetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    ::Ozone::Point __ret = instance->GetPosition();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::Rect::SetPosition
static JSValue callback_method_Ozone_Rect_SetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPosition(const ::Ozone::Point& p)
overload0:
    {
        Ozone::Point* p_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *p_instance;
        instance->SetPosition(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::GetSize
static JSValue callback_method_Ozone_Rect_GetSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    ::Ozone::Size __ret = instance->GetSize();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::Rect::SetSize
static JSValue callback_method_Ozone_Rect_SetSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetSize(const ::Ozone::Size& s)
overload0:
    {
        Ozone::Size* s_instance = (Ozone::Size*) JS_GetOpaque(argv[0], classId_Ozone_Size);

        auto &__arg0 = *s_instance;
        instance->SetSize(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::IsEmpty
static JSValue callback_method_Ozone_Rect_IsEmpty(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    bool __ret = instance->IsEmpty();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::GetLeft
static JSValue callback_method_Ozone_Rect_GetLeft(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->GetLeft();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::GetTop
static JSValue callback_method_Ozone_Rect_GetTop(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->GetTop();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::GetBottom
static JSValue callback_method_Ozone_Rect_GetBottom(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->GetBottom();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::GetRight
static JSValue callback_method_Ozone_Rect_GetRight(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->GetRight();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::SetLeft
static JSValue callback_method_Ozone_Rect_SetLeft(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetLeft(int left)
overload0:
    {
        int left;
        if (JS_ToInt32(ctx, (int32_t*) &left, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = left;
        instance->SetLeft(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::SetRight
static JSValue callback_method_Ozone_Rect_SetRight(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetRight(int right)
overload0:
    {
        int right;
        if (JS_ToInt32(ctx, (int32_t*) &right, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = right;
        instance->SetRight(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::SetTop
static JSValue callback_method_Ozone_Rect_SetTop(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetTop(int top)
overload0:
    {
        int top;
        if (JS_ToInt32(ctx, (int32_t*) &top, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = top;
        instance->SetTop(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::SetBottom
static JSValue callback_method_Ozone_Rect_SetBottom(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetBottom(int bottom)
overload0:
    {
        int bottom;
        if (JS_ToInt32(ctx, (int32_t*) &bottom, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = bottom;
        instance->SetBottom(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::GetTopLeft
static JSValue callback_method_Ozone_Rect_GetTopLeft(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    ::Ozone::Point __ret = instance->GetTopLeft();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::Rect::GetLeftTop
static JSValue callback_method_Ozone_Rect_GetLeftTop(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    ::Ozone::Point __ret = instance->GetLeftTop();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::Rect::SetTopLeft
static JSValue callback_method_Ozone_Rect_SetTopLeft(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetTopLeft(const ::Ozone::Point& p)
overload0:
    {
        Ozone::Point* p_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *p_instance;
        instance->SetTopLeft(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::SetLeftTop
static JSValue callback_method_Ozone_Rect_SetLeftTop(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetLeftTop(const ::Ozone::Point& p)
overload0:
    {
        Ozone::Point* p_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *p_instance;
        instance->SetLeftTop(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::GetBottomRight
static JSValue callback_method_Ozone_Rect_GetBottomRight(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    ::Ozone::Point __ret = instance->GetBottomRight();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::Rect::GetRightBottom
static JSValue callback_method_Ozone_Rect_GetRightBottom(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    ::Ozone::Point __ret = instance->GetRightBottom();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::Rect::SetBottomRight
static JSValue callback_method_Ozone_Rect_SetBottomRight(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetBottomRight(const ::Ozone::Point& p)
overload0:
    {
        Ozone::Point* p_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *p_instance;
        instance->SetBottomRight(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::SetRightBottom
static JSValue callback_method_Ozone_Rect_SetRightBottom(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetRightBottom(const ::Ozone::Point& p)
overload0:
    {
        Ozone::Point* p_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *p_instance;
        instance->SetRightBottom(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::GetTopRight
static JSValue callback_method_Ozone_Rect_GetTopRight(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    ::Ozone::Point __ret = instance->GetTopRight();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::Rect::GetRightTop
static JSValue callback_method_Ozone_Rect_GetRightTop(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    ::Ozone::Point __ret = instance->GetRightTop();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::Rect::SetTopRight
static JSValue callback_method_Ozone_Rect_SetTopRight(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetTopRight(const ::Ozone::Point& p)
overload0:
    {
        Ozone::Point* p_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *p_instance;
        instance->SetTopRight(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::SetRightTop
static JSValue callback_method_Ozone_Rect_SetRightTop(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetRightTop(const ::Ozone::Point& p)
overload0:
    {
        Ozone::Point* p_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *p_instance;
        instance->SetRightTop(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::GetBottomLeft
static JSValue callback_method_Ozone_Rect_GetBottomLeft(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    ::Ozone::Point __ret = instance->GetBottomLeft();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::Rect::GetLeftBottom
static JSValue callback_method_Ozone_Rect_GetLeftBottom(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    ::Ozone::Point __ret = instance->GetLeftBottom();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::Rect::SetBottomLeft
static JSValue callback_method_Ozone_Rect_SetBottomLeft(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetBottomLeft(const ::Ozone::Point& p)
overload0:
    {
        Ozone::Point* p_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *p_instance;
        instance->SetBottomLeft(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::SetLeftBottom
static JSValue callback_method_Ozone_Rect_SetLeftBottom(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetLeftBottom(const ::Ozone::Point& p)
overload0:
    {
        Ozone::Point* p_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *p_instance;
        instance->SetLeftBottom(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::Inflate
static JSValue callback_method_Ozone_Rect_Inflate(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Rect Inflate(int dx, int dy) const
overload0:
    {
        int dx;
        if (JS_ToInt32(ctx, (int32_t*) &dx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = dx;
        int dy;
        if (JS_ToInt32(ctx, (int32_t*) &dy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = dy;
        ::Ozone::Rect __ret = instance->Inflate(__arg0, __arg1);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::Rect::Deflate
static JSValue callback_method_Ozone_Rect_Deflate(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Rect Deflate(int dx, int dy) const
overload0:
    {
        int dx;
        if (JS_ToInt32(ctx, (int32_t*) &dx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = dx;
        int dy;
        if (JS_ToInt32(ctx, (int32_t*) &dy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = dy;
        ::Ozone::Rect __ret = instance->Deflate(__arg0, __arg1);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::Rect::Offset
static JSValue callback_method_Ozone_Rect_Offset(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto overload1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Offset(int dx, int dy)
overload0:
    {
        int dx;
        if (JS_ToInt32(ctx, (int32_t*) &dx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = dx;
        int dy;
        if (JS_ToInt32(ctx, (int32_t*) &dy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = dy;
        instance->Offset(__arg0, __arg1);


        return JS_UNDEFINED;
    }

    // void Offset(const ::Ozone::Point& pt)
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        instance->Offset(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::Intersect
static JSValue callback_method_Ozone_Rect_Intersect(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Rect Intersect(const ::Ozone::Rect& rect) const
overload0:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        ::Ozone::Rect __ret = instance->Intersect(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::Rect::Union
static JSValue callback_method_Ozone_Rect_Union(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Rect Union(const ::Ozone::Rect& rect) const
overload0:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        ::Ozone::Rect __ret = instance->Union(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::Rect::Contains
static JSValue callback_method_Ozone_Rect_Contains(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto overload1;

    if (JS_IsObject(argv[0]))
        goto overload2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Contains(int x, int y) const
overload0:
    {
        int x;
        if (JS_ToInt32(ctx, (int32_t*) &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        int y;
        if (JS_ToInt32(ctx, (int32_t*) &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        bool __ret = instance->Contains(__arg0, __arg1);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Contains(const ::Ozone::Point& pt) const
overload1:
    {
        Ozone::Point* pt_instance = (Ozone::Point*) JS_GetOpaque(argv[0], classId_Ozone_Point);

        auto &__arg0 = *pt_instance;
        bool __ret = instance->Contains(__arg0);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Contains(const ::Ozone::Rect& rect) const
overload2:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        bool __ret = instance->Contains(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Rect::Intersects
static JSValue callback_method_Ozone_Rect_Intersects(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Intersects(const ::Ozone::Rect& rect) const
overload0:
    {
        Ozone::Rect* rect_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *rect_instance;
        bool __ret = instance->Intersects(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Rect::CentreIn
static JSValue callback_method_Ozone_Rect_CentreIn(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Rect CentreIn(const ::Ozone::Rect& r, int dir) const
overload0:
    {
        Ozone::Rect* r_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *r_instance;
        int dir;
        if (JS_ToInt32(ctx, (int32_t*) &dir, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = dir;
        ::Ozone::Rect __ret = instance->CentreIn(__arg0, __arg1);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::Rect::CenterIn
static JSValue callback_method_Ozone_Rect_CenterIn(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Rect CenterIn(const ::Ozone::Rect& r, int dir) const
overload0:
    {
        Ozone::Rect* r_instance = (Ozone::Rect*) JS_GetOpaque(argv[0], classId_Ozone_Rect);

        auto &__arg0 = *r_instance;
        int dir;
        if (JS_ToInt32(ctx, (int32_t*) &dir, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = dir;
        ::Ozone::Rect __ret = instance->CenterIn(__arg0, __arg1);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::Rect::get_x
static JSValue callback_method_Ozone_Rect_get_x(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->get_x();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::set_x
static JSValue callback_method_Ozone_Rect_set_x(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_x(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_x(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::get_y
static JSValue callback_method_Ozone_Rect_get_y(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->get_y();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::set_y
static JSValue callback_method_Ozone_Rect_set_y(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_y(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_y(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::get_width
static JSValue callback_method_Ozone_Rect_get_width(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->get_width();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::set_width
static JSValue callback_method_Ozone_Rect_set_width(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_width(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_width(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Rect::get_height
static JSValue callback_method_Ozone_Rect_get_height(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    int __ret = instance->get_height();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::Rect::set_height
static JSValue callback_method_Ozone_Rect_set_height(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Rect* instance = (Ozone::Rect*) JS_GetOpaque(this_val, classId_Ozone_Rect);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void set_height(int value)
overload0:
    {
        int value;
        if (JS_ToInt32(ctx, (int32_t*) &value, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = value;
        instance->set_height(__arg0);

        return JS_UNDEFINED;
    }
}
static JSClassDef classDef_Ozone_Rect
{
    "Rect",
};

static JSCFunctionListEntry funcDef_Ozone_Rect[]
{
    JS_CFUNC_DEF("GetX", 0, callback_method_Ozone_Rect_GetX),
    JS_CFUNC_DEF("SetX", 1, callback_method_Ozone_Rect_SetX),
    JS_CFUNC_DEF("GetY", 0, callback_method_Ozone_Rect_GetY),
    JS_CFUNC_DEF("SetY", 1, callback_method_Ozone_Rect_SetY),
    JS_CFUNC_DEF("GetWidth", 0, callback_method_Ozone_Rect_GetWidth),
    JS_CFUNC_DEF("SetWidth", 1, callback_method_Ozone_Rect_SetWidth),
    JS_CFUNC_DEF("GetHeight", 0, callback_method_Ozone_Rect_GetHeight),
    JS_CFUNC_DEF("SetHeight", 1, callback_method_Ozone_Rect_SetHeight),
    JS_CFUNC_DEF("GetPosition", 0, callback_method_Ozone_Rect_GetPosition),
    JS_CFUNC_DEF("SetPosition", 1, callback_method_Ozone_Rect_SetPosition),
    JS_CFUNC_DEF("GetSize", 0, callback_method_Ozone_Rect_GetSize),
    JS_CFUNC_DEF("SetSize", 1, callback_method_Ozone_Rect_SetSize),
    JS_CFUNC_DEF("IsEmpty", 0, callback_method_Ozone_Rect_IsEmpty),
    JS_CFUNC_DEF("GetLeft", 0, callback_method_Ozone_Rect_GetLeft),
    JS_CFUNC_DEF("GetTop", 0, callback_method_Ozone_Rect_GetTop),
    JS_CFUNC_DEF("GetBottom", 0, callback_method_Ozone_Rect_GetBottom),
    JS_CFUNC_DEF("GetRight", 0, callback_method_Ozone_Rect_GetRight),
    JS_CFUNC_DEF("SetLeft", 1, callback_method_Ozone_Rect_SetLeft),
    JS_CFUNC_DEF("SetRight", 1, callback_method_Ozone_Rect_SetRight),
    JS_CFUNC_DEF("SetTop", 1, callback_method_Ozone_Rect_SetTop),
    JS_CFUNC_DEF("SetBottom", 1, callback_method_Ozone_Rect_SetBottom),
    JS_CFUNC_DEF("GetTopLeft", 0, callback_method_Ozone_Rect_GetTopLeft),
    JS_CFUNC_DEF("GetLeftTop", 0, callback_method_Ozone_Rect_GetLeftTop),
    JS_CFUNC_DEF("SetTopLeft", 1, callback_method_Ozone_Rect_SetTopLeft),
    JS_CFUNC_DEF("SetLeftTop", 1, callback_method_Ozone_Rect_SetLeftTop),
    JS_CFUNC_DEF("GetBottomRight", 0, callback_method_Ozone_Rect_GetBottomRight),
    JS_CFUNC_DEF("GetRightBottom", 0, callback_method_Ozone_Rect_GetRightBottom),
    JS_CFUNC_DEF("SetBottomRight", 1, callback_method_Ozone_Rect_SetBottomRight),
    JS_CFUNC_DEF("SetRightBottom", 1, callback_method_Ozone_Rect_SetRightBottom),
    JS_CFUNC_DEF("GetTopRight", 0, callback_method_Ozone_Rect_GetTopRight),
    JS_CFUNC_DEF("GetRightTop", 0, callback_method_Ozone_Rect_GetRightTop),
    JS_CFUNC_DEF("SetTopRight", 1, callback_method_Ozone_Rect_SetTopRight),
    JS_CFUNC_DEF("SetRightTop", 1, callback_method_Ozone_Rect_SetRightTop),
    JS_CFUNC_DEF("GetBottomLeft", 0, callback_method_Ozone_Rect_GetBottomLeft),
    JS_CFUNC_DEF("GetLeftBottom", 0, callback_method_Ozone_Rect_GetLeftBottom),
    JS_CFUNC_DEF("SetBottomLeft", 1, callback_method_Ozone_Rect_SetBottomLeft),
    JS_CFUNC_DEF("SetLeftBottom", 1, callback_method_Ozone_Rect_SetLeftBottom),
    JS_CFUNC_DEF("Inflate", 2, callback_method_Ozone_Rect_Inflate),
    JS_CFUNC_DEF("Deflate", 2, callback_method_Ozone_Rect_Deflate),
    JS_CFUNC_DEF("Offset", 2, callback_method_Ozone_Rect_Offset),
    JS_CFUNC_DEF("Intersect", 1, callback_method_Ozone_Rect_Intersect),
    JS_CFUNC_DEF("Union", 1, callback_method_Ozone_Rect_Union),
    JS_CFUNC_DEF("Contains", 2, callback_method_Ozone_Rect_Contains),
    JS_CFUNC_DEF("Intersects", 1, callback_method_Ozone_Rect_Intersects),
    JS_CFUNC_DEF("CentreIn", 2, callback_method_Ozone_Rect_CentreIn),
    JS_CFUNC_DEF("CenterIn", 2, callback_method_Ozone_Rect_CenterIn),
    JS_CFUNC_DEF("get_x", 0, callback_method_Ozone_Rect_get_x),
    JS_CFUNC_DEF("set_x", 1, callback_method_Ozone_Rect_set_x),
    JS_CFUNC_DEF("get_y", 0, callback_method_Ozone_Rect_get_y),
    JS_CFUNC_DEF("set_y", 1, callback_method_Ozone_Rect_set_y),
    JS_CFUNC_DEF("get_width", 0, callback_method_Ozone_Rect_get_width),
    JS_CFUNC_DEF("set_width", 1, callback_method_Ozone_Rect_set_width),
    JS_CFUNC_DEF("get_height", 0, callback_method_Ozone_Rect_get_height),
    JS_CFUNC_DEF("set_height", 1, callback_method_Ozone_Rect_set_height),
};


static void register_class_Ozone_Rect(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "Rect");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_Rect);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_Rect, &classDef_Ozone_Rect);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_Rect, sizeof(funcDef_Ozone_Rect) / sizeof(funcDef_Ozone_Rect[0]));
        JS_SetClassProto(ctx, classId_Ozone_Rect, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_Rect_Rect, "Rect", 4, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "Rect", ctor);
    }
}

JSClassID classId_Ozone_GDIObjListBase;

// Ozone::GDIObjListBase::GDIObjListBase
static JSValue callback_method_Ozone_GDIObjListBase_GDIObjListBase(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GDIObjListBase* instance;

    instance = new Ozone::GDIObjListBase();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GDIObjListBase);
    else
        proto = JS_GetPropertyStr(ctx, this_val, "prototype");

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GDIObjListBase);
    JS_SetOpaque(__obj, instance);

    JS_FreeValue(ctx, proto);

    return __obj;
}
static JSClassDef classDef_Ozone_GDIObjListBase
{
    "GDIObjListBase",
};

static JSCFunctionListEntry funcDef_Ozone_GDIObjListBase[]
{
};


static void register_class_Ozone_GDIObjListBase(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GDIObjListBase");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GDIObjListBase);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GDIObjListBase, &classDef_Ozone_GDIObjListBase);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GDIObjListBase, sizeof(funcDef_Ozone_GDIObjListBase) / sizeof(funcDef_Ozone_GDIObjListBase[0]));
        JS_SetClassProto(ctx, classId_Ozone_GDIObjListBase, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GDIObjListBase_GDIObjListBase, "GDIObjListBase", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GDIObjListBase", ctor);
    }
}

JSClassID classId_Ozone_ColourDatabase;

// Ozone::ColourDatabase::ColourDatabase
static JSValue callback_method_Ozone_ColourDatabase_ColourDatabase(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::ColourDatabase* instance;

    instance = new Ozone::ColourDatabase();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_ColourDatabase);
    else
        proto = JS_GetPropertyStr(ctx, this_val, "prototype");

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_ColourDatabase);
    JS_SetOpaque(__obj, instance);

    JS_FreeValue(ctx, proto);

    return __obj;
}

// Ozone::ColourDatabase::Find
static JSValue callback_method_Ozone_ColourDatabase_Find(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::ColourDatabase* instance = (Ozone::ColourDatabase*) JS_GetOpaque(this_val, classId_Ozone_ColourDatabase);

    if (JS_IsString(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Color Find(const char* name) const
overload0:
    {
        const char* name;
        name = JS_ToCString(ctx, argv[0]);
        if (!name)
            return JS_EXCEPTION;

        auto __arg0 = name;
        ::Ozone::Color __ret = instance->Find(__arg0);

        JS_FreeCString(ctx, name);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::ColourDatabase::FindName
static JSValue callback_method_Ozone_ColourDatabase_FindName(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::ColourDatabase* instance = (Ozone::ColourDatabase*) JS_GetOpaque(this_val, classId_Ozone_ColourDatabase);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // char* FindName(const ::Ozone::Color& colour) const
overload0:
    {
        Ozone::Color* colour_instance = (Ozone::Color*) JS_GetOpaque(argv[0], classId_Ozone_Color);

        auto &__arg0 = *colour_instance;
        const char* __ret = instance->FindName(__arg0);

        JSValue ____ret = JS_NewString(ctx, __ret);

        return ____ret;
    }
}

// Ozone::ColourDatabase::AddColour
static JSValue callback_method_Ozone_ColourDatabase_AddColour(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::ColourDatabase* instance = (Ozone::ColourDatabase*) JS_GetOpaque(this_val, classId_Ozone_ColourDatabase);

    if (JS_IsString(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddColour(const char* name, const ::Ozone::Color& colour)
overload0:
    {
        const char* name;
        name = JS_ToCString(ctx, argv[0]);
        if (!name)
            return JS_EXCEPTION;

        auto __arg0 = name;
        Ozone::Color* colour_instance = (Ozone::Color*) JS_GetOpaque(argv[1], classId_Ozone_Color);

        auto &__arg1 = *colour_instance;
        instance->AddColour(__arg0, __arg1);

        JS_FreeCString(ctx, name);

        return JS_UNDEFINED;
    }
}
static JSClassDef classDef_Ozone_ColourDatabase
{
    "ColourDatabase",
};

static JSCFunctionListEntry funcDef_Ozone_ColourDatabase[]
{
    JS_CFUNC_DEF("Find", 1, callback_method_Ozone_ColourDatabase_Find),
    JS_CFUNC_DEF("FindName", 1, callback_method_Ozone_ColourDatabase_FindName),
    JS_CFUNC_DEF("AddColour", 2, callback_method_Ozone_ColourDatabase_AddColour),
};


static void register_class_Ozone_ColourDatabase(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "ColourDatabase");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_ColourDatabase);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_ColourDatabase, &classDef_Ozone_ColourDatabase);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_ColourDatabase, sizeof(funcDef_Ozone_ColourDatabase) / sizeof(funcDef_Ozone_ColourDatabase[0]));
        JS_SetClassProto(ctx, classId_Ozone_ColourDatabase, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_ColourDatabase_ColourDatabase, "ColourDatabase", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "ColourDatabase", ctor);
    }
}

JSClassID classId_Ozone_ResourceCache;

// Ozone::ResourceCache::ResourceCache
static JSValue callback_method_Ozone_ResourceCache_ResourceCache(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::ResourceCache* instance;

    if (argc == 0)
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ResourceCache()
overload0:
    {
        instance = new Ozone::ResourceCache();

        goto wrap;
    }

    // ResourceCache(unsigned int keyType)
overload1:
    {
        unsigned int keyType;
        if (JS_ToUint32(ctx, (uint32_t*) &keyType, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = keyType;
        instance = new Ozone::ResourceCache(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_ResourceCache);
    else
        proto = JS_GetPropertyStr(ctx, this_val, "prototype");

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_ResourceCache);
    JS_SetOpaque(__obj, instance);

    JS_FreeValue(ctx, proto);

    return __obj;
}
static JSClassDef classDef_Ozone_ResourceCache
{
    "ResourceCache",
};

static JSCFunctionListEntry funcDef_Ozone_ResourceCache[]
{
};


static void register_class_Ozone_ResourceCache(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "ResourceCache");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_ResourceCache);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_ResourceCache, &classDef_Ozone_ResourceCache);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_ResourceCache, sizeof(funcDef_Ozone_ResourceCache) / sizeof(funcDef_Ozone_ResourceCache[0]));
        JS_SetClassProto(ctx, classId_Ozone_ResourceCache, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_ResourceCache_ResourceCache, "ResourceCache", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "ResourceCache", ctor);
    }
}

JSClassID classId_Ozone_StockGDI;

enum class Item : unsigned int
{
    BRUSH_BLACK = 0,
    BRUSH_BLUE = 1,
    BRUSH_CYAN = 2,
    BRUSH_GREEN = 3,
    BRUSH_YELLOW = 4,
    BRUSH_GREY = 5,
    BRUSH_LIGHTGREY = 6,
    BRUSH_MEDIUMGREY = 7,
    BRUSH_RED = 8,
    BRUSH_TRANSPARENT = 9,
    BRUSH_WHITE = 10,
    COLOUR_BLACK = 11,
    COLOUR_BLUE = 12,
    COLOUR_CYAN = 13,
    COLOUR_GREEN = 14,
    COLOUR_YELLOW = 15,
    COLOUR_LIGHTGREY = 16,
    COLOUR_RED = 17,
    COLOUR_WHITE = 18,
    CURSOR_CROSS = 19,
    CURSOR_HOURGLASS = 20,
    CURSOR_STANDARD = 21,
    FONT_ITALIC = 22,
    FONT_NORMAL = 23,
    FONT_SMALL = 24,
    FONT_SWISS = 25,
    PEN_BLACK = 26,
    PEN_BLACKDASHED = 27,
    PEN_BLUE = 28,
    PEN_CYAN = 29,
    PEN_GREEN = 30,
    PEN_YELLOW = 31,
    PEN_GREY = 32,
    PEN_LIGHTGREY = 33,
    PEN_MEDIUMGREY = 34,
    PEN_RED = 35,
    PEN_TRANSPARENT = 36,
    PEN_WHITE = 37,
    ITEMCOUNT = 38
};

// Ozone::StockGDI::StockGDI
static JSValue callback_method_Ozone_StockGDI_StockGDI(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::StockGDI* instance;

    instance = new Ozone::StockGDI();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_StockGDI);
    else
        proto = JS_GetPropertyStr(ctx, this_val, "prototype");

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_StockGDI);
    JS_SetOpaque(__obj, instance);

    JS_FreeValue(ctx, proto);

    return __obj;
}

// Ozone::StockGDI::DeleteAll
static JSValue callback_method_Ozone_StockGDI_DeleteAll(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    ::Ozone::StockGDI::DeleteAll();

    return JS_UNDEFINED;
}

// Ozone::StockGDI::GetBrush
static JSValue callback_method_Ozone_StockGDI_GetBrush(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Brush* GetBrush(::Ozone::StockGDI::Item item)
overload0:
    {
        unsigned int item;
        if (JS_ToUint32(ctx, (uint32_t*) &item, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = (::Ozone::StockGDI::Item)item;
        const ::Ozone::Brush* __ret = ::Ozone::StockGDI::GetBrush(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::StockGDI::GetColour
static JSValue callback_method_Ozone_StockGDI_GetColour(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Color* GetColour(::Ozone::StockGDI::Item item)
overload0:
    {
        unsigned int item;
        if (JS_ToUint32(ctx, (uint32_t*) &item, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = (::Ozone::StockGDI::Item)item;
        const ::Ozone::Color* __ret = ::Ozone::StockGDI::GetColour(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::StockGDI::GetPen
static JSValue callback_method_Ozone_StockGDI_GetPen(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Pen* GetPen(::Ozone::StockGDI::Item item)
overload0:
    {
        unsigned int item;
        if (JS_ToUint32(ctx, (uint32_t*) &item, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = (::Ozone::StockGDI::Item)item;
        const ::Ozone::Pen* __ret = ::Ozone::StockGDI::GetPen(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}
static JSClassDef classDef_Ozone_StockGDI
{
    "StockGDI",
};

static JSCFunctionListEntry funcDef_Ozone_StockGDI[]
{
    JS_CFUNC_DEF("DeleteAll", 0, callback_method_Ozone_StockGDI_DeleteAll),
    JS_CFUNC_DEF("GetBrush", 1, callback_method_Ozone_StockGDI_GetBrush),
    JS_CFUNC_DEF("GetColour", 1, callback_method_Ozone_StockGDI_GetColour),
    JS_CFUNC_DEF("GetPen", 1, callback_method_Ozone_StockGDI_GetPen),
};


static void register_class_Ozone_StockGDI(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "StockGDI");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_StockGDI);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_StockGDI, &classDef_Ozone_StockGDI);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_StockGDI, sizeof(funcDef_Ozone_StockGDI) / sizeof(funcDef_Ozone_StockGDI[0]));
        JS_SetClassProto(ctx, classId_Ozone_StockGDI, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_StockGDI_StockGDI, "StockGDI", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "StockGDI", ctor);
    }
}

// Ozone::InitializeStockLists
static JSValue callback_function_Ozone_InitializeStockLists(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    ::Ozone::InitializeStockLists();

    return JS_UNDEFINED;
}

static void register_function_Ozone_InitializeStockLists(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "InitializeStockLists");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_InitializeStockLists, "InitializeStockLists", 0);
    int status = JS_SetModuleExport(ctx, m, "InitializeStockLists", val);
    assert(status != -1);
}

// Ozone::DeleteStockLists
static JSValue callback_function_Ozone_DeleteStockLists(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    ::Ozone::DeleteStockLists();

    return JS_UNDEFINED;
}

static void register_function_Ozone_DeleteStockLists(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "DeleteStockLists");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_DeleteStockLists, "DeleteStockLists", 0);
    int status = JS_SetModuleExport(ctx, m, "DeleteStockLists", val);
    assert(status != -1);
}

// Ozone::ColourDisplay
static JSValue callback_function_Ozone_ColourDisplay(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    bool __ret = ::Ozone::ColourDisplay();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

static void register_function_Ozone_ColourDisplay(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "ColourDisplay");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_ColourDisplay, "ColourDisplay", 0);
    int status = JS_SetModuleExport(ctx, m, "ColourDisplay", val);
    assert(status != -1);
}

// Ozone::DisplayDepth
static JSValue callback_function_Ozone_DisplayDepth(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    int __ret = ::Ozone::DisplayDepth();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

static void register_function_Ozone_DisplayDepth(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "DisplayDepth");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_DisplayDepth, "DisplayDepth", 0);
    int status = JS_SetModuleExport(ctx, m, "DisplayDepth", val);
    assert(status != -1);
}

// Ozone::GetDisplaySize
static JSValue callback_function_Ozone_GetDisplaySize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    ::Ozone::Size __ret = ::Ozone::GetDisplaySize();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

static void register_function_Ozone_GetDisplaySize(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "GetDisplaySize");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_GetDisplaySize, "GetDisplaySize", 0);
    int status = JS_SetModuleExport(ctx, m, "GetDisplaySize", val);
    assert(status != -1);
}

// Ozone::GetDisplaySizeMM
static JSValue callback_function_Ozone_GetDisplaySizeMM(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    ::Ozone::Size __ret = ::Ozone::GetDisplaySizeMM();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

static void register_function_Ozone_GetDisplaySizeMM(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "GetDisplaySizeMM");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_GetDisplaySizeMM, "GetDisplaySizeMM", 0);
    int status = JS_SetModuleExport(ctx, m, "GetDisplaySizeMM", val);
    assert(status != -1);
}

// Ozone::GetDisplayPPI
static JSValue callback_function_Ozone_GetDisplayPPI(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    ::Ozone::Size __ret = ::Ozone::GetDisplayPPI();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

static void register_function_Ozone_GetDisplayPPI(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "GetDisplayPPI");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_GetDisplayPPI, "GetDisplayPPI", 0);
    int status = JS_SetModuleExport(ctx, m, "GetDisplayPPI", val);
    assert(status != -1);
}

// Ozone::GetClientDisplayRect
static JSValue callback_function_Ozone_GetClientDisplayRect(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    ::Ozone::Rect __ret = ::Ozone::GetClientDisplayRect();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

static void register_function_Ozone_GetClientDisplayRect(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "GetClientDisplayRect");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewCFunction(ctx, callback_function_Ozone_GetClientDisplayRect, "GetClientDisplayRect", 0);
    int status = JS_SetModuleExport(ctx, m, "GetClientDisplayRect", val);
    assert(status != -1);
}

void register_ozone_gdicmn(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (phase == 0)
    {
        register_enum_Ozone_BitmapType(ctx, m, set);

        register_enum_Ozone_EllipsizeFlags(ctx, m, set);

        register_enum_Ozone_EllipsizeMode(ctx, m, set);

        register_enum_Ozone_PolygonFillMode(ctx, m, set);

        register_enum_Ozone_StockCursor(ctx, m, set);

        register_function_Ozone_InitializeStockLists(ctx, m, set);

        register_function_Ozone_DeleteStockLists(ctx, m, set);

        register_function_Ozone_ColourDisplay(ctx, m, set);

        register_function_Ozone_DisplayDepth(ctx, m, set);

        register_function_Ozone_GetDisplaySize(ctx, m, set);

        register_function_Ozone_GetDisplaySizeMM(ctx, m, set);

        register_function_Ozone_GetDisplayPPI(ctx, m, set);

        register_function_Ozone_GetClientDisplayRect(ctx, m, set);
    }

    register_class_Ozone_Size(ctx, m, set, phase);

    register_class_Ozone_RealPoint(ctx, m, set, phase);

    register_class_Ozone_Point(ctx, m, set, phase);

    register_class_Ozone_wxPointListNode(ctx, m, set, phase);

    register_class_Ozone_Rect(ctx, m, set, phase);

    register_class_Ozone_GDIObjListBase(ctx, m, set, phase);

    register_class_Ozone_ColourDatabase(ctx, m, set, phase);

    register_class_Ozone_ResourceCache(ctx, m, set, phase);

    register_class_Ozone_StockGDI(ctx, m, set, phase);
}
}
