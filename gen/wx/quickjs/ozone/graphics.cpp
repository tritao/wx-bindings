// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <CppSharp_QuickJS.h>
#include <assert.h>
#include <ozone/graphics.h>

extern "C" {

extern JSClassID classId_Ozone_GraphicsObject;
extern JSClassID classId_Ozone_Object;
extern JSClassID classId_Ozone_GraphicsRenderer;
extern JSClassID classId_Ozone_GraphicsPen;
extern JSClassID classId_Ozone_GraphicsBrush;
extern JSClassID classId_Ozone_GraphicsFont;
extern JSClassID classId_Ozone_GraphicsBitmap;
extern JSClassID classId_Ozone_GraphicsMatrix;
extern JSClassID classId_Ozone_GraphicsGradientStop;
extern JSClassID classId_Ozone_Color;
extern JSClassID classId_Ozone_GraphicsGradientStops;
extern JSClassID classId_Ozone_GraphicsPenInfo;
extern JSClassID classId_Ozone_GraphicsPath;
extern JSClassID classId_Ozone_GraphicsContext;
extern JSClassID classId_Ozone_Window;
extern JSClassID classId_Ozone_Pen;
extern JSClassID classId_Ozone_Brush;
extern JSClassID classId_Ozone_WindowDC;
extern JSClassID classId_Ozone_DC;
extern JSClassID classId__Signal;

static void register_enum_Ozone_GradientType(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "GradientType");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // NONE
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "NONE", __item);
    }

    // LINEAR
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "LINEAR", __item);
    }

    // RADIAL
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "RADIAL", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "GradientType", val);
    assert(status != -1);
}

static void register_enum_Ozone_AntialiasMode(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "AntialiasMode");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // NONE
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "NONE", __item);
    }

    // DEFAULT
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "DEFAULT", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "AntialiasMode", val);
    assert(status != -1);
}

static void register_enum_Ozone_InterpolationQuality(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "InterpolationQuality");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // DEFAULT
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "DEFAULT", __item);
    }

    // NONE
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "NONE", __item);
    }

    // FAST
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "FAST", __item);
    }

    // GOOD
    {
        JSValue __item = JS_NewUint32(ctx, 3);
        JS_SetPropertyStr(ctx, val, "GOOD", __item);
    }

    // BEST
    {
        JSValue __item = JS_NewUint32(ctx, 4);
        JS_SetPropertyStr(ctx, val, "BEST", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "InterpolationQuality", val);
    assert(status != -1);
}

static void register_enum_Ozone_CompositionMode(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "CompositionMode");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // INVALID
    {
        JSValue __item = JS_NewInt32(ctx, -1);
        JS_SetPropertyStr(ctx, val, "INVALID", __item);
    }

    // CLEAR
    {
        JSValue __item = JS_NewInt32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "CLEAR", __item);
    }

    // SOURCE
    {
        JSValue __item = JS_NewInt32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "SOURCE", __item);
    }

    // OVER
    {
        JSValue __item = JS_NewInt32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "OVER", __item);
    }

    // IN
    {
        JSValue __item = JS_NewInt32(ctx, 3);
        JS_SetPropertyStr(ctx, val, "IN", __item);
    }

    // OUT
    {
        JSValue __item = JS_NewInt32(ctx, 4);
        JS_SetPropertyStr(ctx, val, "OUT", __item);
    }

    // ATOP
    {
        JSValue __item = JS_NewInt32(ctx, 5);
        JS_SetPropertyStr(ctx, val, "ATOP", __item);
    }

    // DEST
    {
        JSValue __item = JS_NewInt32(ctx, 6);
        JS_SetPropertyStr(ctx, val, "DEST", __item);
    }

    // DEST_OVER
    {
        JSValue __item = JS_NewInt32(ctx, 7);
        JS_SetPropertyStr(ctx, val, "DEST_OVER", __item);
    }

    // DEST_IN
    {
        JSValue __item = JS_NewInt32(ctx, 8);
        JS_SetPropertyStr(ctx, val, "DEST_IN", __item);
    }

    // DEST_OUT
    {
        JSValue __item = JS_NewInt32(ctx, 9);
        JS_SetPropertyStr(ctx, val, "DEST_OUT", __item);
    }

    // DEST_ATOP
    {
        JSValue __item = JS_NewInt32(ctx, 10);
        JS_SetPropertyStr(ctx, val, "DEST_ATOP", __item);
    }

    // XOR
    {
        JSValue __item = JS_NewInt32(ctx, 11);
        JS_SetPropertyStr(ctx, val, "XOR", __item);
    }

    // ADD
    {
        JSValue __item = JS_NewInt32(ctx, 12);
        JS_SetPropertyStr(ctx, val, "ADD", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "CompositionMode", val);
    assert(status != -1);
}

JSClassID classId_Ozone_GraphicsObject;

// Ozone::GraphicsObject::GraphicsObject
static JSValue callback_method_Ozone_GraphicsObject_GraphicsObject(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsObject* instance;

    if (argc == 0)
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // GraphicsObject()
overload0:
    {
        instance = new Ozone::GraphicsObject();

        goto wrap;
    }

    // GraphicsObject(::Ozone::GraphicsRenderer* renderer)
overload1:
    {
        Ozone::GraphicsRenderer* renderer_instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsRenderer);

        auto __arg0 = renderer_instance;
        instance = new Ozone::GraphicsObject(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsObject);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsObject);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::GraphicsObject::IsNull
static JSValue callback_method_Ozone_GraphicsObject_IsNull(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsObject* instance = (Ozone::GraphicsObject*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsNull();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsObject::GetRenderer
static JSValue callback_method_Ozone_GraphicsObject_GetRenderer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsObject* instance = (Ozone::GraphicsObject*) JS_GetOpaque(this_val, 0);

    ::Ozone::GraphicsRenderer* __ret = instance->GetRenderer();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

static JSValue callback_class_Ozone_GraphicsObject_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsObject");
}

void finalizer_Ozone_GraphicsObject(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsObject* instance = (Ozone::GraphicsObject*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsObject
{
    "GraphicsObject",
    .finalizer = finalizer_Ozone_GraphicsObject
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsObject[]
{
    JS_CFUNC_DEF("IsNull", 0, callback_method_Ozone_GraphicsObject_IsNull),
    JS_CFUNC_DEF("GetRenderer", 0, callback_method_Ozone_GraphicsObject_GetRenderer),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsObject_toString),
};

static void register_class_Ozone_GraphicsObject(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsObject");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsObject);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsObject, &classDef_Ozone_GraphicsObject);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsObject, sizeof(funcDef_Ozone_GraphicsObject) / sizeof(funcDef_Ozone_GraphicsObject[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsObject, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsObject_GraphicsObject, "GraphicsObject", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsObject", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsObject);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Object);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_GraphicsPen;

// Ozone::GraphicsPen::GraphicsPen
static JSValue callback_method_Ozone_GraphicsPen_GraphicsPen(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPen* instance;

    instance = new Ozone::GraphicsPen();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsPen);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsPen);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

static JSValue callback_class_Ozone_GraphicsPen_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsPen");
}

void finalizer_Ozone_GraphicsPen(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsPen* instance = (Ozone::GraphicsPen*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsPen
{
    "GraphicsPen",
    .finalizer = finalizer_Ozone_GraphicsPen
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsPen[]
{
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsPen_toString),
};

static void register_class_Ozone_GraphicsPen(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsPen");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsPen);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsPen, &classDef_Ozone_GraphicsPen);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsPen, sizeof(funcDef_Ozone_GraphicsPen) / sizeof(funcDef_Ozone_GraphicsPen[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsPen, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsPen_GraphicsPen, "GraphicsPen", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsPen", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsPen);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GraphicsObject);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_GraphicsBrush;

// Ozone::GraphicsBrush::GraphicsBrush
static JSValue callback_method_Ozone_GraphicsBrush_GraphicsBrush(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsBrush* instance;

    instance = new Ozone::GraphicsBrush();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsBrush);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsBrush);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

static JSValue callback_class_Ozone_GraphicsBrush_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsBrush");
}

void finalizer_Ozone_GraphicsBrush(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsBrush* instance = (Ozone::GraphicsBrush*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsBrush
{
    "GraphicsBrush",
    .finalizer = finalizer_Ozone_GraphicsBrush
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsBrush[]
{
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsBrush_toString),
};

static void register_class_Ozone_GraphicsBrush(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsBrush");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsBrush);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsBrush, &classDef_Ozone_GraphicsBrush);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsBrush, sizeof(funcDef_Ozone_GraphicsBrush) / sizeof(funcDef_Ozone_GraphicsBrush[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsBrush, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsBrush_GraphicsBrush, "GraphicsBrush", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsBrush", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsBrush);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GraphicsObject);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_GraphicsFont;

// Ozone::GraphicsFont::GraphicsFont
static JSValue callback_method_Ozone_GraphicsFont_GraphicsFont(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsFont* instance;

    instance = new Ozone::GraphicsFont();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsFont);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsFont);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

static JSValue callback_class_Ozone_GraphicsFont_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsFont");
}

void finalizer_Ozone_GraphicsFont(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsFont* instance = (Ozone::GraphicsFont*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsFont
{
    "GraphicsFont",
    .finalizer = finalizer_Ozone_GraphicsFont
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsFont[]
{
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsFont_toString),
};

static void register_class_Ozone_GraphicsFont(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsFont");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsFont);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsFont, &classDef_Ozone_GraphicsFont);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsFont, sizeof(funcDef_Ozone_GraphicsFont) / sizeof(funcDef_Ozone_GraphicsFont[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsFont, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsFont_GraphicsFont, "GraphicsFont", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsFont", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsFont);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GraphicsObject);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_GraphicsBitmap;

// Ozone::GraphicsBitmap::GraphicsBitmap
static JSValue callback_method_Ozone_GraphicsBitmap_GraphicsBitmap(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsBitmap* instance;

    instance = new Ozone::GraphicsBitmap();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsBitmap);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsBitmap);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

static JSValue callback_class_Ozone_GraphicsBitmap_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsBitmap");
}

void finalizer_Ozone_GraphicsBitmap(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsBitmap* instance = (Ozone::GraphicsBitmap*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsBitmap
{
    "GraphicsBitmap",
    .finalizer = finalizer_Ozone_GraphicsBitmap
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsBitmap[]
{
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsBitmap_toString),
};

static void register_class_Ozone_GraphicsBitmap(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsBitmap");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsBitmap);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsBitmap, &classDef_Ozone_GraphicsBitmap);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsBitmap, sizeof(funcDef_Ozone_GraphicsBitmap) / sizeof(funcDef_Ozone_GraphicsBitmap[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsBitmap, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsBitmap_GraphicsBitmap, "GraphicsBitmap", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsBitmap", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsBitmap);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GraphicsObject);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_GraphicsMatrix;

// Ozone::GraphicsMatrix::GraphicsMatrix
static JSValue callback_method_Ozone_GraphicsMatrix_GraphicsMatrix(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsMatrix* instance;

    instance = new Ozone::GraphicsMatrix();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsMatrix);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsMatrix);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::GraphicsMatrix::Concat
static JSValue callback_method_Ozone_GraphicsMatrix_Concat(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsMatrix* instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Concat(const ::Ozone::GraphicsMatrix& t)
overload0:
    {
        Ozone::GraphicsMatrix* t_instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsMatrix);

        auto &__arg0 = *t_instance;
        instance->Concat(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsMatrix::Set
static JSValue callback_method_Ozone_GraphicsMatrix_Set(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 6 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsMatrix* instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[5]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Set(double a, double b, double c, double d, double tx, double ty)
overload0:
    {
        double a;
        if (JS_ToFloat64(ctx, &a, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = a;
        double b;
        if (JS_ToFloat64(ctx, &b, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = b;
        double c;
        if (JS_ToFloat64(ctx, &c, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = c;
        double d;
        if (JS_ToFloat64(ctx, &d, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = d;
        double tx;
        if (JS_ToFloat64(ctx, &tx, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = tx;
        double ty;
        if (JS_ToFloat64(ctx, &ty, argv[5]))
            return JS_EXCEPTION;

        auto __arg5 = ty;
        instance->Set(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsMatrix::Invert
static JSValue callback_method_Ozone_GraphicsMatrix_Invert(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsMatrix* instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(this_val, 0);

    instance->Invert();

    return JS_UNDEFINED;
}

// Ozone::GraphicsMatrix::IsEqual
static JSValue callback_method_Ozone_GraphicsMatrix_IsEqual(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsMatrix* instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool IsEqual(const ::Ozone::GraphicsMatrix& t) const
overload0:
    {
        Ozone::GraphicsMatrix* t_instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsMatrix);

        auto &__arg0 = *t_instance;
        bool __ret = instance->IsEqual(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::GraphicsMatrix::IsIdentity
static JSValue callback_method_Ozone_GraphicsMatrix_IsIdentity(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsMatrix* instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsIdentity();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsMatrix::Translate
static JSValue callback_method_Ozone_GraphicsMatrix_Translate(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsMatrix* instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Translate(double dx, double dy)
overload0:
    {
        double dx;
        if (JS_ToFloat64(ctx, &dx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = dx;
        double dy;
        if (JS_ToFloat64(ctx, &dy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = dy;
        instance->Translate(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsMatrix::Scale
static JSValue callback_method_Ozone_GraphicsMatrix_Scale(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsMatrix* instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Scale(double xScale, double yScale)
overload0:
    {
        double xScale;
        if (JS_ToFloat64(ctx, &xScale, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = xScale;
        double yScale;
        if (JS_ToFloat64(ctx, &yScale, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = yScale;
        instance->Scale(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsMatrix::Rotate
static JSValue callback_method_Ozone_GraphicsMatrix_Rotate(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsMatrix* instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Rotate(double angle)
overload0:
    {
        double angle;
        if (JS_ToFloat64(ctx, &angle, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = angle;
        instance->Rotate(__arg0);

        return JS_UNDEFINED;
    }
}

static JSValue callback_class_Ozone_GraphicsMatrix_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsMatrix");
}

void finalizer_Ozone_GraphicsMatrix(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsMatrix* instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsMatrix
{
    "GraphicsMatrix",
    .finalizer = finalizer_Ozone_GraphicsMatrix
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsMatrix[]
{
    JS_CFUNC_DEF("Concat", 1, callback_method_Ozone_GraphicsMatrix_Concat),
    JS_CFUNC_DEF("Set", 6, callback_method_Ozone_GraphicsMatrix_Set),
    JS_CFUNC_DEF("Invert", 0, callback_method_Ozone_GraphicsMatrix_Invert),
    JS_CFUNC_DEF("IsEqual", 1, callback_method_Ozone_GraphicsMatrix_IsEqual),
    JS_CFUNC_DEF("IsIdentity", 0, callback_method_Ozone_GraphicsMatrix_IsIdentity),
    JS_CFUNC_DEF("Translate", 2, callback_method_Ozone_GraphicsMatrix_Translate),
    JS_CFUNC_DEF("Scale", 2, callback_method_Ozone_GraphicsMatrix_Scale),
    JS_CFUNC_DEF("Rotate", 1, callback_method_Ozone_GraphicsMatrix_Rotate),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsMatrix_toString),
};

static void register_class_Ozone_GraphicsMatrix(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsMatrix");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsMatrix);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsMatrix, &classDef_Ozone_GraphicsMatrix);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsMatrix, sizeof(funcDef_Ozone_GraphicsMatrix) / sizeof(funcDef_Ozone_GraphicsMatrix[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsMatrix, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsMatrix_GraphicsMatrix, "GraphicsMatrix", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsMatrix", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsMatrix);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GraphicsObject);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_GraphicsGradientStop;

// Ozone::GraphicsGradientStop::GraphicsGradientStop
static JSValue callback_method_Ozone_GraphicsGradientStop_GraphicsGradientStop(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStop* instance;

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // GraphicsGradientStop(::Ozone::Color col, float pos)
overload0:
    {
        Ozone::Color* col_instance = (Ozone::Color*) JS_GetOpaque(argv[0], classId_Ozone_Color);

        auto __arg0 = *col_instance;
        float pos;
        double _pos;
        if (JS_ToFloat64(ctx, &_pos, argv[1]))
            return JS_EXCEPTION;
        pos = (float)_pos;

        auto __arg1 = pos;
        instance = new Ozone::GraphicsGradientStop(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsGradientStop);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsGradientStop);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::GraphicsGradientStop::SetColour
static JSValue callback_method_Ozone_GraphicsGradientStop_SetColour(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStop* instance = (Ozone::GraphicsGradientStop*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetColour(const ::Ozone::Color& col)
overload0:
    {
        Ozone::Color* col_instance = (Ozone::Color*) JS_GetOpaque(argv[0], classId_Ozone_Color);

        auto &__arg0 = *col_instance;
        instance->SetColour(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsGradientStop::GetPosition
static JSValue callback_method_Ozone_GraphicsGradientStop_GetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStop* instance = (Ozone::GraphicsGradientStop*) JS_GetOpaque(this_val, 0);

    float __ret = instance->GetPosition();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsGradientStop::SetPosition
static JSValue callback_method_Ozone_GraphicsGradientStop_SetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStop* instance = (Ozone::GraphicsGradientStop*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPosition(float pos)
overload0:
    {
        float pos;
        double _pos;
        if (JS_ToFloat64(ctx, &_pos, argv[0]))
            return JS_EXCEPTION;
        pos = (float)_pos;

        auto __arg0 = pos;
        instance->SetPosition(__arg0);

        return JS_UNDEFINED;
    }
}

static JSValue callback_class_Ozone_GraphicsGradientStop_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsGradientStop");
}

void finalizer_Ozone_GraphicsGradientStop(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsGradientStop* instance = (Ozone::GraphicsGradientStop*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsGradientStop
{
    "GraphicsGradientStop",
    .finalizer = finalizer_Ozone_GraphicsGradientStop
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsGradientStop[]
{
    JS_CFUNC_DEF("SetColour", 1, callback_method_Ozone_GraphicsGradientStop_SetColour),
    JS_CFUNC_DEF("GetPosition", 0, callback_method_Ozone_GraphicsGradientStop_GetPosition),
    JS_CFUNC_DEF("SetPosition", 1, callback_method_Ozone_GraphicsGradientStop_SetPosition),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsGradientStop_toString),
};

static void register_class_Ozone_GraphicsGradientStop(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsGradientStop");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsGradientStop);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsGradientStop, &classDef_Ozone_GraphicsGradientStop);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsGradientStop, sizeof(funcDef_Ozone_GraphicsGradientStop) / sizeof(funcDef_Ozone_GraphicsGradientStop[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsGradientStop, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsGradientStop_GraphicsGradientStop, "GraphicsGradientStop", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsGradientStop", ctor);
    }
}

JSClassID classId_Ozone_GraphicsGradientStops;

// Ozone::GraphicsGradientStops::GraphicsGradientStops
static JSValue callback_method_Ozone_GraphicsGradientStops_GraphicsGradientStops(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStops* instance;

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // GraphicsGradientStops(::Ozone::Color startCol, ::Ozone::Color endCol)
overload0:
    {
        Ozone::Color* startCol_instance = (Ozone::Color*) JS_GetOpaque(argv[0], classId_Ozone_Color);

        auto __arg0 = *startCol_instance;
        Ozone::Color* endCol_instance = (Ozone::Color*) JS_GetOpaque(argv[1], classId_Ozone_Color);

        auto __arg1 = *endCol_instance;
        instance = new Ozone::GraphicsGradientStops(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsGradientStops);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsGradientStops);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::GraphicsGradientStops::Add
static JSValue callback_method_Ozone_GraphicsGradientStops_Add(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStops* instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Add(const ::Ozone::GraphicsGradientStop& stop)
overload0:
    {
        Ozone::GraphicsGradientStop* stop_instance = (Ozone::GraphicsGradientStop*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsGradientStop);

        auto &__arg0 = *stop_instance;
        instance->Add(__arg0);


        return JS_UNDEFINED;
    }

    // void Add(::Ozone::Color col, float pos)
overload1:
    {
        Ozone::Color* col_instance = (Ozone::Color*) JS_GetOpaque(argv[0], classId_Ozone_Color);

        auto __arg0 = *col_instance;
        float pos;
        double _pos;
        if (JS_ToFloat64(ctx, &_pos, argv[1]))
            return JS_EXCEPTION;
        pos = (float)_pos;

        auto __arg1 = pos;
        instance->Add(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsGradientStops::GetCount
static JSValue callback_method_Ozone_GraphicsGradientStops_GetCount(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStops* instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(this_val, 0);

    unsigned long __ret = instance->GetCount();

    JSValue ____ret = JS_NewUint32(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsGradientStops::Item
static JSValue callback_method_Ozone_GraphicsGradientStops_Item(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStops* instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsGradientStop Item(unsigned int n) const
overload0:
    {
        unsigned int n;
        if (JS_ToUint32(ctx, (uint32_t*) &n, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = n;
        ::Ozone::GraphicsGradientStop __ret = instance->Item(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsGradientStops::SetStartColour
static JSValue callback_method_Ozone_GraphicsGradientStops_SetStartColour(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStops* instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetStartColour(::Ozone::Color col)
overload0:
    {
        Ozone::Color* col_instance = (Ozone::Color*) JS_GetOpaque(argv[0], classId_Ozone_Color);

        auto __arg0 = *col_instance;
        instance->SetStartColour(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsGradientStops::GetStartColour
static JSValue callback_method_Ozone_GraphicsGradientStops_GetStartColour(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStops* instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(this_val, 0);

    ::Ozone::Color __ret = instance->GetStartColour();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::GraphicsGradientStops::SetEndColour
static JSValue callback_method_Ozone_GraphicsGradientStops_SetEndColour(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStops* instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetEndColour(::Ozone::Color col)
overload0:
    {
        Ozone::Color* col_instance = (Ozone::Color*) JS_GetOpaque(argv[0], classId_Ozone_Color);

        auto __arg0 = *col_instance;
        instance->SetEndColour(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsGradientStops::GetEndColour
static JSValue callback_method_Ozone_GraphicsGradientStops_GetEndColour(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsGradientStops* instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(this_val, 0);

    ::Ozone::Color __ret = instance->GetEndColour();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

static JSValue callback_class_Ozone_GraphicsGradientStops_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsGradientStops");
}

void finalizer_Ozone_GraphicsGradientStops(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsGradientStops* instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsGradientStops
{
    "GraphicsGradientStops",
    .finalizer = finalizer_Ozone_GraphicsGradientStops
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsGradientStops[]
{
    JS_CFUNC_DEF("Add", 2, callback_method_Ozone_GraphicsGradientStops_Add),
    JS_CFUNC_DEF("GetCount", 0, callback_method_Ozone_GraphicsGradientStops_GetCount),
    JS_CFUNC_DEF("Item", 1, callback_method_Ozone_GraphicsGradientStops_Item),
    JS_CFUNC_DEF("SetStartColour", 1, callback_method_Ozone_GraphicsGradientStops_SetStartColour),
    JS_CFUNC_DEF("GetStartColour", 0, callback_method_Ozone_GraphicsGradientStops_GetStartColour),
    JS_CFUNC_DEF("SetEndColour", 1, callback_method_Ozone_GraphicsGradientStops_SetEndColour),
    JS_CFUNC_DEF("GetEndColour", 0, callback_method_Ozone_GraphicsGradientStops_GetEndColour),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsGradientStops_toString),
};

static void register_class_Ozone_GraphicsGradientStops(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsGradientStops");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsGradientStops);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsGradientStops, &classDef_Ozone_GraphicsGradientStops);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsGradientStops, sizeof(funcDef_Ozone_GraphicsGradientStops) / sizeof(funcDef_Ozone_GraphicsGradientStops[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsGradientStops, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsGradientStops_GraphicsGradientStops, "GraphicsGradientStops", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsGradientStops", ctor);
    }
}

JSClassID classId_Ozone_GraphicsPenInfo;

// Ozone::GraphicsPenInfo::GraphicsPenInfo
static JSValue callback_method_Ozone_GraphicsPenInfo_GraphicsPenInfo(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance;

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // explicit GraphicsPenInfo(const ::Ozone::Color& colour, double width, ::Ozone::PenStyle style)
overload0:
    {
        Ozone::Color* colour_instance = (Ozone::Color*) JS_GetOpaque(argv[0], classId_Ozone_Color);

        auto &__arg0 = *colour_instance;
        double width;
        if (JS_ToFloat64(ctx, &width, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = width;
        int style;
        if (JS_ToInt32(ctx, (int32_t*) &style, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = (::Ozone::PenStyle)style;
        instance = new Ozone::GraphicsPenInfo(__arg0, __arg1, __arg2);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsPenInfo);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsPenInfo);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::GraphicsPenInfo::GetWidth
static JSValue callback_method_Ozone_GraphicsPenInfo_GetWidth(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetWidth();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetGradientType
static JSValue callback_method_Ozone_GraphicsPenInfo_GetGradientType(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    ::Ozone::GradientType __ret = instance->GetGradientType();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetX1
static JSValue callback_method_Ozone_GraphicsPenInfo_GetX1(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetX1();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetY1
static JSValue callback_method_Ozone_GraphicsPenInfo_GetY1(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetY1();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetX2
static JSValue callback_method_Ozone_GraphicsPenInfo_GetX2(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetX2();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetY2
static JSValue callback_method_Ozone_GraphicsPenInfo_GetY2(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetY2();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetStartX
static JSValue callback_method_Ozone_GraphicsPenInfo_GetStartX(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetStartX();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetStartY
static JSValue callback_method_Ozone_GraphicsPenInfo_GetStartY(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetStartY();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetEndX
static JSValue callback_method_Ozone_GraphicsPenInfo_GetEndX(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetEndX();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetEndY
static JSValue callback_method_Ozone_GraphicsPenInfo_GetEndY(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetEndY();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetRadius
static JSValue callback_method_Ozone_GraphicsPenInfo_GetRadius(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    double __ret = instance->GetRadius();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetColour
static JSValue callback_method_Ozone_GraphicsPenInfo_GetColour(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    ::Ozone::Color __ret = instance->GetColour();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::GraphicsPenInfo::GetStyle
static JSValue callback_method_Ozone_GraphicsPenInfo_GetStyle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    ::Ozone::PenStyle __ret = instance->GetStyle();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetJoin
static JSValue callback_method_Ozone_GraphicsPenInfo_GetJoin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    ::Ozone::PenJoin __ret = instance->GetJoin();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetCap
static JSValue callback_method_Ozone_GraphicsPenInfo_GetCap(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    ::Ozone::PenCap __ret = instance->GetCap();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::GetDashCount
static JSValue callback_method_Ozone_GraphicsPenInfo_GetDashCount(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetDashCount();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsPenInfo::IsTransparent
static JSValue callback_method_Ozone_GraphicsPenInfo_IsTransparent(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsTransparent();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_GraphicsPenInfo_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsPenInfo");
}

void finalizer_Ozone_GraphicsPenInfo(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsPenInfo* instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsPenInfo
{
    "GraphicsPenInfo",
    .finalizer = finalizer_Ozone_GraphicsPenInfo
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsPenInfo[]
{
    JS_CFUNC_DEF("GetWidth", 0, callback_method_Ozone_GraphicsPenInfo_GetWidth),
    JS_CFUNC_DEF("GetGradientType", 0, callback_method_Ozone_GraphicsPenInfo_GetGradientType),
    JS_CFUNC_DEF("GetX1", 0, callback_method_Ozone_GraphicsPenInfo_GetX1),
    JS_CFUNC_DEF("GetY1", 0, callback_method_Ozone_GraphicsPenInfo_GetY1),
    JS_CFUNC_DEF("GetX2", 0, callback_method_Ozone_GraphicsPenInfo_GetX2),
    JS_CFUNC_DEF("GetY2", 0, callback_method_Ozone_GraphicsPenInfo_GetY2),
    JS_CFUNC_DEF("GetStartX", 0, callback_method_Ozone_GraphicsPenInfo_GetStartX),
    JS_CFUNC_DEF("GetStartY", 0, callback_method_Ozone_GraphicsPenInfo_GetStartY),
    JS_CFUNC_DEF("GetEndX", 0, callback_method_Ozone_GraphicsPenInfo_GetEndX),
    JS_CFUNC_DEF("GetEndY", 0, callback_method_Ozone_GraphicsPenInfo_GetEndY),
    JS_CFUNC_DEF("GetRadius", 0, callback_method_Ozone_GraphicsPenInfo_GetRadius),
    JS_CFUNC_DEF("GetColour", 0, callback_method_Ozone_GraphicsPenInfo_GetColour),
    JS_CFUNC_DEF("GetStyle", 0, callback_method_Ozone_GraphicsPenInfo_GetStyle),
    JS_CFUNC_DEF("GetJoin", 0, callback_method_Ozone_GraphicsPenInfo_GetJoin),
    JS_CFUNC_DEF("GetCap", 0, callback_method_Ozone_GraphicsPenInfo_GetCap),
    JS_CFUNC_DEF("GetDashCount", 0, callback_method_Ozone_GraphicsPenInfo_GetDashCount),
    JS_CFUNC_DEF("IsTransparent", 0, callback_method_Ozone_GraphicsPenInfo_IsTransparent),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsPenInfo_toString),
};

static void register_class_Ozone_GraphicsPenInfo(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsPenInfo");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsPenInfo);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsPenInfo, &classDef_Ozone_GraphicsPenInfo);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsPenInfo, sizeof(funcDef_Ozone_GraphicsPenInfo) / sizeof(funcDef_Ozone_GraphicsPenInfo[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsPenInfo, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsPenInfo_GraphicsPenInfo, "GraphicsPenInfo", 3, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsPenInfo", ctor);
    }
}

JSClassID classId_Ozone_GraphicsPath;

// Ozone::GraphicsPath::GraphicsPath
static JSValue callback_method_Ozone_GraphicsPath_GraphicsPath(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance;

    instance = new Ozone::GraphicsPath();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsPath);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsPath);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::GraphicsPath::MoveToPoint
static JSValue callback_method_Ozone_GraphicsPath_MoveToPoint(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void MoveToPoint(double x, double y)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        instance->MoveToPoint(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::AddLineToPoint
static JSValue callback_method_Ozone_GraphicsPath_AddLineToPoint(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddLineToPoint(double x, double y)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        instance->AddLineToPoint(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::AddCurveToPoint
static JSValue callback_method_Ozone_GraphicsPath_AddCurveToPoint(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 6 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[5]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddCurveToPoint(double cx1, double cy1, double cx2, double cy2, double x, double y)
overload0:
    {
        double cx1;
        if (JS_ToFloat64(ctx, &cx1, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = cx1;
        double cy1;
        if (JS_ToFloat64(ctx, &cy1, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = cy1;
        double cx2;
        if (JS_ToFloat64(ctx, &cx2, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = cx2;
        double cy2;
        if (JS_ToFloat64(ctx, &cy2, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = cy2;
        double x;
        if (JS_ToFloat64(ctx, &x, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[5]))
            return JS_EXCEPTION;

        auto __arg5 = y;
        instance->AddCurveToPoint(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::AddPath
static JSValue callback_method_Ozone_GraphicsPath_AddPath(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddPath(const ::Ozone::GraphicsPath& path)
overload0:
    {
        Ozone::GraphicsPath* path_instance = (Ozone::GraphicsPath*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsPath);

        auto &__arg0 = *path_instance;
        instance->AddPath(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::CloseSubpath
static JSValue callback_method_Ozone_GraphicsPath_CloseSubpath(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    instance->CloseSubpath();

    return JS_UNDEFINED;
}

// Ozone::GraphicsPath::AddArc
static JSValue callback_method_Ozone_GraphicsPath_AddArc(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 6 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (JS_IsBool(argv[5]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddArc(double x, double y, double r, double startAngle, double endAngle, bool clockwise)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        double r;
        if (JS_ToFloat64(ctx, &r, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = r;
        double startAngle;
        if (JS_ToFloat64(ctx, &startAngle, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = startAngle;
        double endAngle;
        if (JS_ToFloat64(ctx, &endAngle, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = endAngle;
        bool clockwise;
        clockwise = JS_ToBool(ctx, argv[5]);
        if (clockwise == -1)
            return JS_EXCEPTION;

        auto __arg5 = clockwise;
        instance->AddArc(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::AddQuadCurveToPoint
static JSValue callback_method_Ozone_GraphicsPath_AddQuadCurveToPoint(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddQuadCurveToPoint(double cx, double cy, double x, double y)
overload0:
    {
        double cx;
        if (JS_ToFloat64(ctx, &cx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = cx;
        double cy;
        if (JS_ToFloat64(ctx, &cy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = cy;
        double x;
        if (JS_ToFloat64(ctx, &x, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = y;
        instance->AddQuadCurveToPoint(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::AddRectangle
static JSValue callback_method_Ozone_GraphicsPath_AddRectangle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddRectangle(double x, double y, double w, double h)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        double w;
        if (JS_ToFloat64(ctx, &w, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = w;
        double h;
        if (JS_ToFloat64(ctx, &h, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = h;
        instance->AddRectangle(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::AddCircle
static JSValue callback_method_Ozone_GraphicsPath_AddCircle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddCircle(double x, double y, double r)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        double r;
        if (JS_ToFloat64(ctx, &r, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = r;
        instance->AddCircle(__arg0, __arg1, __arg2);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::AddArcToPoint
static JSValue callback_method_Ozone_GraphicsPath_AddArcToPoint(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 5 || argc > 5)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddArcToPoint(double x1, double y1, double x2, double y2, double r)
overload0:
    {
        double x1;
        if (JS_ToFloat64(ctx, &x1, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x1;
        double y1;
        if (JS_ToFloat64(ctx, &y1, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y1;
        double x2;
        if (JS_ToFloat64(ctx, &x2, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = x2;
        double y2;
        if (JS_ToFloat64(ctx, &y2, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = y2;
        double r;
        if (JS_ToFloat64(ctx, &r, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = r;
        instance->AddArcToPoint(__arg0, __arg1, __arg2, __arg3, __arg4);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::AddEllipse
static JSValue callback_method_Ozone_GraphicsPath_AddEllipse(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddEllipse(double x, double y, double w, double h)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        double w;
        if (JS_ToFloat64(ctx, &w, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = w;
        double h;
        if (JS_ToFloat64(ctx, &h, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = h;
        instance->AddEllipse(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::AddRoundedRectangle
static JSValue callback_method_Ozone_GraphicsPath_AddRoundedRectangle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 5 || argc > 5)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddRoundedRectangle(double x, double y, double w, double h, double radius)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        double w;
        if (JS_ToFloat64(ctx, &w, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = w;
        double h;
        if (JS_ToFloat64(ctx, &h, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = h;
        double radius;
        if (JS_ToFloat64(ctx, &radius, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = radius;
        instance->AddRoundedRectangle(__arg0, __arg1, __arg2, __arg3, __arg4);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::Transform
static JSValue callback_method_Ozone_GraphicsPath_Transform(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Transform(const ::Ozone::GraphicsMatrix& matrix)
overload0:
    {
        Ozone::GraphicsMatrix* matrix_instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsMatrix);

        auto &__arg0 = *matrix_instance;
        instance->Transform(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsPath::Contains
static JSValue callback_method_Ozone_GraphicsPath_Contains(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Contains(double x, double y, ::Ozone::PolygonFillMode fillStyle) const
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        unsigned int fillStyle;
        if (JS_ToUint32(ctx, (uint32_t*) &fillStyle, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = (::Ozone::PolygonFillMode)fillStyle;
        bool __ret = instance->Contains(__arg0, __arg1, __arg2);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

static JSValue callback_class_Ozone_GraphicsPath_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsPath");
}

void finalizer_Ozone_GraphicsPath(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsPath* instance = (Ozone::GraphicsPath*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsPath
{
    "GraphicsPath",
    .finalizer = finalizer_Ozone_GraphicsPath
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsPath[]
{
    JS_CFUNC_DEF("MoveToPoint", 2, callback_method_Ozone_GraphicsPath_MoveToPoint),
    JS_CFUNC_DEF("AddLineToPoint", 2, callback_method_Ozone_GraphicsPath_AddLineToPoint),
    JS_CFUNC_DEF("AddCurveToPoint", 6, callback_method_Ozone_GraphicsPath_AddCurveToPoint),
    JS_CFUNC_DEF("AddPath", 1, callback_method_Ozone_GraphicsPath_AddPath),
    JS_CFUNC_DEF("CloseSubpath", 0, callback_method_Ozone_GraphicsPath_CloseSubpath),
    JS_CFUNC_DEF("AddArc", 6, callback_method_Ozone_GraphicsPath_AddArc),
    JS_CFUNC_DEF("AddQuadCurveToPoint", 4, callback_method_Ozone_GraphicsPath_AddQuadCurveToPoint),
    JS_CFUNC_DEF("AddRectangle", 4, callback_method_Ozone_GraphicsPath_AddRectangle),
    JS_CFUNC_DEF("AddCircle", 3, callback_method_Ozone_GraphicsPath_AddCircle),
    JS_CFUNC_DEF("AddArcToPoint", 5, callback_method_Ozone_GraphicsPath_AddArcToPoint),
    JS_CFUNC_DEF("AddEllipse", 4, callback_method_Ozone_GraphicsPath_AddEllipse),
    JS_CFUNC_DEF("AddRoundedRectangle", 5, callback_method_Ozone_GraphicsPath_AddRoundedRectangle),
    JS_CFUNC_DEF("Transform", 1, callback_method_Ozone_GraphicsPath_Transform),
    JS_CFUNC_DEF("Contains", 3, callback_method_Ozone_GraphicsPath_Contains),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsPath_toString),
};

static void register_class_Ozone_GraphicsPath(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsPath");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsPath);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsPath, &classDef_Ozone_GraphicsPath);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsPath, sizeof(funcDef_Ozone_GraphicsPath) / sizeof(funcDef_Ozone_GraphicsPath[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsPath, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsPath_GraphicsPath, "GraphicsPath", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsPath", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsPath);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GraphicsObject);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_GraphicsContext;

// Ozone::GraphicsContext::GraphicsContext
static JSValue callback_method_Ozone_GraphicsContext_GraphicsContext(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance;

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // GraphicsContext(::Ozone::GraphicsRenderer* renderer, ::Ozone::Window* window)
overload0:
    {
        Ozone::GraphicsRenderer* renderer_instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsRenderer);

        auto __arg0 = renderer_instance;
        Ozone::Window* window_instance = (Ozone::Window*) JS_GetOpaque(argv[1], classId_Ozone_Window);

        auto __arg1 = window_instance;
        instance = new Ozone::GraphicsContext(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsContext);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsContext);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::GraphicsContext::GetWindow
static JSValue callback_method_Ozone_GraphicsContext_GetWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->GetWindow();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::GraphicsContext::StartDoc
static JSValue callback_method_Ozone_GraphicsContext_StartDoc(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsString(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool StartDoc(const char* message)
overload0:
    {
        const char* message;
        message = JS_ToCString(ctx, argv[0]);
        if (!message)
            return JS_EXCEPTION;

        auto __arg0 = message;
        bool __ret = instance->StartDoc(__arg0);

        JS_FreeCString(ctx, message);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::GraphicsContext::EndDoc
static JSValue callback_method_Ozone_GraphicsContext_EndDoc(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    instance->EndDoc();

    return JS_UNDEFINED;
}

// Ozone::GraphicsContext::StartPage
static JSValue callback_method_Ozone_GraphicsContext_StartPage(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void StartPage(double width, double height)
overload0:
    {
        double width;
        if (JS_ToFloat64(ctx, &width, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = width;
        double height;
        if (JS_ToFloat64(ctx, &height, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = height;
        instance->StartPage(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::EndPage
static JSValue callback_method_Ozone_GraphicsContext_EndPage(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    instance->EndPage();

    return JS_UNDEFINED;
}

// Ozone::GraphicsContext::Flush
static JSValue callback_method_Ozone_GraphicsContext_Flush(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    instance->Flush();

    return JS_UNDEFINED;
}

// Ozone::GraphicsContext::CreatePath
static JSValue callback_method_Ozone_GraphicsContext_CreatePath(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    ::Ozone::GraphicsPath __ret = instance->CreatePath();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::GraphicsContext::CreatePen
static JSValue callback_method_Ozone_GraphicsContext_CreatePen(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsPen CreatePen(const ::Ozone::Pen& pen) const
overload0:
    {
        Ozone::Pen* pen_instance = (Ozone::Pen*) JS_GetOpaque(argv[0], classId_Ozone_Pen);

        auto &__arg0 = *pen_instance;
        ::Ozone::GraphicsPen __ret = instance->CreatePen(__arg0);


        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }

    // ::Ozone::GraphicsPen CreatePen(const ::Ozone::GraphicsPenInfo& info) const
overload1:
    {
        Ozone::GraphicsPenInfo* info_instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsPenInfo);

        auto &__arg0 = *info_instance;
        ::Ozone::GraphicsPen __ret = instance->CreatePen(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsContext::CreateBrush
static JSValue callback_method_Ozone_GraphicsContext_CreateBrush(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsBrush CreateBrush(const ::Ozone::Brush& brush) const
overload0:
    {
        Ozone::Brush* brush_instance = (Ozone::Brush*) JS_GetOpaque(argv[0], classId_Ozone_Brush);

        auto &__arg0 = *brush_instance;
        ::Ozone::GraphicsBrush __ret = instance->CreateBrush(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsContext::CreateLinearGradientBrush
static JSValue callback_method_Ozone_GraphicsContext_CreateLinearGradientBrush(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 6 || argc > 7)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsObject(argv[4]))
        goto typecheck5;

    if (JS_IsObject(argv[4]))
        goto typecheck6;

    goto error;

typecheck5:
    if (JS_IsObject(argv[5]))
        goto typecheck7;

    goto error;

typecheck6:
    if (JS_IsObject(argv[5]))
        goto overload1;

    goto error;

typecheck7:
    if (JS_IsObject(argv[6]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsBrush CreateLinearGradientBrush(double x1, double y1, double x2, double y2, const ::Ozone::Color& c1, const ::Ozone::Color& c2, const ::Ozone::GraphicsMatrix& matrix) const
overload0:
    {
        double x1;
        if (JS_ToFloat64(ctx, &x1, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x1;
        double y1;
        if (JS_ToFloat64(ctx, &y1, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y1;
        double x2;
        if (JS_ToFloat64(ctx, &x2, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = x2;
        double y2;
        if (JS_ToFloat64(ctx, &y2, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = y2;
        Ozone::Color* c1_instance = (Ozone::Color*) JS_GetOpaque(argv[4], classId_Ozone_Color);

        auto &__arg4 = *c1_instance;
        Ozone::Color* c2_instance = (Ozone::Color*) JS_GetOpaque(argv[5], classId_Ozone_Color);

        auto &__arg5 = *c2_instance;
        Ozone::GraphicsMatrix* matrix_instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(argv[6], classId_Ozone_GraphicsMatrix);

        auto &__arg6 = *matrix_instance;
        ::Ozone::GraphicsBrush __ret = instance->CreateLinearGradientBrush(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);


        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }

    // ::Ozone::GraphicsBrush CreateLinearGradientBrush(double x1, double y1, double x2, double y2, const ::Ozone::GraphicsGradientStops& stops, const ::Ozone::GraphicsMatrix& matrix) const
overload1:
    {
        double x1;
        if (JS_ToFloat64(ctx, &x1, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x1;
        double y1;
        if (JS_ToFloat64(ctx, &y1, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y1;
        double x2;
        if (JS_ToFloat64(ctx, &x2, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = x2;
        double y2;
        if (JS_ToFloat64(ctx, &y2, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = y2;
        Ozone::GraphicsGradientStops* stops_instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(argv[4], classId_Ozone_GraphicsGradientStops);

        auto &__arg4 = *stops_instance;
        Ozone::GraphicsMatrix* matrix_instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(argv[5], classId_Ozone_GraphicsMatrix);

        auto &__arg5 = *matrix_instance;
        ::Ozone::GraphicsBrush __ret = instance->CreateLinearGradientBrush(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsContext::CreateRadialGradientBrush
static JSValue callback_method_Ozone_GraphicsContext_CreateRadialGradientBrush(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 7 || argc > 8)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (JS_IsObject(argv[5]))
        goto typecheck6;

    if (JS_IsObject(argv[5]))
        goto typecheck7;

    goto error;

typecheck6:
    if (JS_IsObject(argv[6]))
        goto typecheck8;

    goto error;

typecheck7:
    if (JS_IsObject(argv[6]))
        goto overload1;

    goto error;

typecheck8:
    if (JS_IsObject(argv[7]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsBrush CreateRadialGradientBrush(double startX, double startY, double endX, double endY, double radius, const ::Ozone::Color& oColor, const ::Ozone::Color& cColor, const ::Ozone::GraphicsMatrix& matrix) const
overload0:
    {
        double startX;
        if (JS_ToFloat64(ctx, &startX, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = startX;
        double startY;
        if (JS_ToFloat64(ctx, &startY, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = startY;
        double endX;
        if (JS_ToFloat64(ctx, &endX, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = endX;
        double endY;
        if (JS_ToFloat64(ctx, &endY, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = endY;
        double radius;
        if (JS_ToFloat64(ctx, &radius, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = radius;
        Ozone::Color* oColor_instance = (Ozone::Color*) JS_GetOpaque(argv[5], classId_Ozone_Color);

        auto &__arg5 = *oColor_instance;
        Ozone::Color* cColor_instance = (Ozone::Color*) JS_GetOpaque(argv[6], classId_Ozone_Color);

        auto &__arg6 = *cColor_instance;
        Ozone::GraphicsMatrix* matrix_instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(argv[7], classId_Ozone_GraphicsMatrix);

        auto &__arg7 = *matrix_instance;
        ::Ozone::GraphicsBrush __ret = instance->CreateRadialGradientBrush(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7);


        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }

    // ::Ozone::GraphicsBrush CreateRadialGradientBrush(double startX, double startY, double endX, double endY, double radius, const ::Ozone::GraphicsGradientStops& stops, const ::Ozone::GraphicsMatrix& matrix) const
overload1:
    {
        double startX;
        if (JS_ToFloat64(ctx, &startX, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = startX;
        double startY;
        if (JS_ToFloat64(ctx, &startY, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = startY;
        double endX;
        if (JS_ToFloat64(ctx, &endX, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = endX;
        double endY;
        if (JS_ToFloat64(ctx, &endY, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = endY;
        double radius;
        if (JS_ToFloat64(ctx, &radius, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = radius;
        Ozone::GraphicsGradientStops* stops_instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(argv[5], classId_Ozone_GraphicsGradientStops);

        auto &__arg5 = *stops_instance;
        Ozone::GraphicsMatrix* matrix_instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(argv[6], classId_Ozone_GraphicsMatrix);

        auto &__arg6 = *matrix_instance;
        ::Ozone::GraphicsBrush __ret = instance->CreateRadialGradientBrush(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsContext::CreateFont
static JSValue callback_method_Ozone_GraphicsContext_CreateFont(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsString(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsObject(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsFont CreateFont(double sizeInPixels, const char* facename, int flags, const ::Ozone::Color& col) const
overload0:
    {
        double sizeInPixels;
        if (JS_ToFloat64(ctx, &sizeInPixels, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = sizeInPixels;
        const char* facename;
        facename = JS_ToCString(ctx, argv[1]);
        if (!facename)
            return JS_EXCEPTION;

        auto __arg1 = facename;
        int flags;
        if (JS_ToInt32(ctx, (int32_t*) &flags, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = flags;
        Ozone::Color* col_instance = (Ozone::Color*) JS_GetOpaque(argv[3], classId_Ozone_Color);

        auto &__arg3 = *col_instance;
        ::Ozone::GraphicsFont __ret = instance->CreateFont(__arg0, __arg1, __arg2, __arg3);

        JS_FreeCString(ctx, facename);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsContext::CreateSubBitmap
static JSValue callback_method_Ozone_GraphicsContext_CreateSubBitmap(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 5 || argc > 5)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsBitmap CreateSubBitmap(const ::Ozone::GraphicsBitmap& bitmap, double x, double y, double w, double h) const
overload0:
    {
        Ozone::GraphicsBitmap* bitmap_instance = (Ozone::GraphicsBitmap*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsBitmap);

        auto &__arg0 = *bitmap_instance;
        double x;
        if (JS_ToFloat64(ctx, &x, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = y;
        double w;
        if (JS_ToFloat64(ctx, &w, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = w;
        double h;
        if (JS_ToFloat64(ctx, &h, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = h;
        ::Ozone::GraphicsBitmap __ret = instance->CreateSubBitmap(__arg0, __arg1, __arg2, __arg3, __arg4);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsContext::CreateMatrix
static JSValue callback_method_Ozone_GraphicsContext_CreateMatrix(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 6 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[5]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsMatrix CreateMatrix(double a, double b, double c, double d, double tx, double ty) const
overload0:
    {
        double a;
        if (JS_ToFloat64(ctx, &a, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = a;
        double b;
        if (JS_ToFloat64(ctx, &b, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = b;
        double c;
        if (JS_ToFloat64(ctx, &c, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = c;
        double d;
        if (JS_ToFloat64(ctx, &d, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = d;
        double tx;
        if (JS_ToFloat64(ctx, &tx, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = tx;
        double ty;
        if (JS_ToFloat64(ctx, &ty, argv[5]))
            return JS_EXCEPTION;

        auto __arg5 = ty;
        ::Ozone::GraphicsMatrix __ret = instance->CreateMatrix(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsContext::PushState
static JSValue callback_method_Ozone_GraphicsContext_PushState(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    instance->PushState();

    return JS_UNDEFINED;
}

// Ozone::GraphicsContext::PopState
static JSValue callback_method_Ozone_GraphicsContext_PopState(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    instance->PopState();

    return JS_UNDEFINED;
}

// Ozone::GraphicsContext::Clip
static JSValue callback_method_Ozone_GraphicsContext_Clip(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Clip(double x, double y, double w, double h)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        double w;
        if (JS_ToFloat64(ctx, &w, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = w;
        double h;
        if (JS_ToFloat64(ctx, &h, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = h;
        instance->Clip(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::ResetClip
static JSValue callback_method_Ozone_GraphicsContext_ResetClip(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    instance->ResetClip();

    return JS_UNDEFINED;
}

// Ozone::GraphicsContext::GetAntialiasMode
static JSValue callback_method_Ozone_GraphicsContext_GetAntialiasMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    ::Ozone::AntialiasMode __ret = instance->GetAntialiasMode();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::GraphicsContext::SetAntialiasMode
static JSValue callback_method_Ozone_GraphicsContext_SetAntialiasMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool SetAntialiasMode(::Ozone::AntialiasMode antialias)
overload0:
    {
        unsigned int antialias;
        if (JS_ToUint32(ctx, (uint32_t*) &antialias, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = (::Ozone::AntialiasMode)antialias;
        bool __ret = instance->SetAntialiasMode(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::GraphicsContext::GetInterpolationQuality
static JSValue callback_method_Ozone_GraphicsContext_GetInterpolationQuality(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    ::Ozone::InterpolationQuality __ret = instance->GetInterpolationQuality();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::GraphicsContext::SetInterpolationQuality
static JSValue callback_method_Ozone_GraphicsContext_SetInterpolationQuality(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool SetInterpolationQuality(::Ozone::InterpolationQuality interpolation)
overload0:
    {
        unsigned int interpolation;
        if (JS_ToUint32(ctx, (uint32_t*) &interpolation, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = (::Ozone::InterpolationQuality)interpolation;
        bool __ret = instance->SetInterpolationQuality(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::GraphicsContext::GetCompositionMode
static JSValue callback_method_Ozone_GraphicsContext_GetCompositionMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    ::Ozone::CompositionMode __ret = instance->GetCompositionMode();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::GraphicsContext::SetCompositionMode
static JSValue callback_method_Ozone_GraphicsContext_SetCompositionMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool SetCompositionMode(::Ozone::CompositionMode op)
overload0:
    {
        int op;
        if (JS_ToInt32(ctx, (int32_t*) &op, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = (::Ozone::CompositionMode)op;
        bool __ret = instance->SetCompositionMode(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::GraphicsContext::BeginLayer
static JSValue callback_method_Ozone_GraphicsContext_BeginLayer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void BeginLayer(double opacity)
overload0:
    {
        double opacity;
        if (JS_ToFloat64(ctx, &opacity, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = opacity;
        instance->BeginLayer(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::EndLayer
static JSValue callback_method_Ozone_GraphicsContext_EndLayer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    instance->EndLayer();

    return JS_UNDEFINED;
}

// Ozone::GraphicsContext::Translate
static JSValue callback_method_Ozone_GraphicsContext_Translate(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Translate(double dx, double dy)
overload0:
    {
        double dx;
        if (JS_ToFloat64(ctx, &dx, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = dx;
        double dy;
        if (JS_ToFloat64(ctx, &dy, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = dy;
        instance->Translate(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::Scale
static JSValue callback_method_Ozone_GraphicsContext_Scale(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Scale(double xScale, double yScale)
overload0:
    {
        double xScale;
        if (JS_ToFloat64(ctx, &xScale, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = xScale;
        double yScale;
        if (JS_ToFloat64(ctx, &yScale, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = yScale;
        instance->Scale(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::Rotate
static JSValue callback_method_Ozone_GraphicsContext_Rotate(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Rotate(double angle)
overload0:
    {
        double angle;
        if (JS_ToFloat64(ctx, &angle, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = angle;
        instance->Rotate(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::ConcatTransform
static JSValue callback_method_Ozone_GraphicsContext_ConcatTransform(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void ConcatTransform(const ::Ozone::GraphicsMatrix& matrix)
overload0:
    {
        Ozone::GraphicsMatrix* matrix_instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsMatrix);

        auto &__arg0 = *matrix_instance;
        instance->ConcatTransform(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::SetTransform
static JSValue callback_method_Ozone_GraphicsContext_SetTransform(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetTransform(const ::Ozone::GraphicsMatrix& matrix)
overload0:
    {
        Ozone::GraphicsMatrix* matrix_instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsMatrix);

        auto &__arg0 = *matrix_instance;
        instance->SetTransform(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::GetTransform
static JSValue callback_method_Ozone_GraphicsContext_GetTransform(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    ::Ozone::GraphicsMatrix __ret = instance->GetTransform();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::GraphicsContext::SetPen
static JSValue callback_method_Ozone_GraphicsContext_SetPen(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetPen(const ::Ozone::GraphicsPen& pen)
overload0:
    {
        Ozone::GraphicsPen* pen_instance = (Ozone::GraphicsPen*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsPen);

        auto &__arg0 = *pen_instance;
        instance->SetPen(__arg0);


        return JS_UNDEFINED;
    }

    // void SetPen(const ::Ozone::Pen& pen)
overload1:
    {
        Ozone::Pen* pen_instance = (Ozone::Pen*) JS_GetOpaque(argv[0], classId_Ozone_Pen);

        auto &__arg0 = *pen_instance;
        instance->SetPen(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::SetBrush
static JSValue callback_method_Ozone_GraphicsContext_SetBrush(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetBrush(const ::Ozone::GraphicsBrush& brush)
overload0:
    {
        Ozone::GraphicsBrush* brush_instance = (Ozone::GraphicsBrush*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsBrush);

        auto &__arg0 = *brush_instance;
        instance->SetBrush(__arg0);


        return JS_UNDEFINED;
    }

    // void SetBrush(const ::Ozone::Brush& brush)
overload1:
    {
        Ozone::Brush* brush_instance = (Ozone::Brush*) JS_GetOpaque(argv[0], classId_Ozone_Brush);

        auto &__arg0 = *brush_instance;
        instance->SetBrush(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::SetFont
static JSValue callback_method_Ozone_GraphicsContext_SetFont(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetFont(const ::Ozone::GraphicsFont& font)
overload0:
    {
        Ozone::GraphicsFont* font_instance = (Ozone::GraphicsFont*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsFont);

        auto &__arg0 = *font_instance;
        instance->SetFont(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::StrokePath
static JSValue callback_method_Ozone_GraphicsContext_StrokePath(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void StrokePath(const ::Ozone::GraphicsPath& path)
overload0:
    {
        Ozone::GraphicsPath* path_instance = (Ozone::GraphicsPath*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsPath);

        auto &__arg0 = *path_instance;
        instance->StrokePath(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::FillPath
static JSValue callback_method_Ozone_GraphicsContext_FillPath(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void FillPath(const ::Ozone::GraphicsPath& path, ::Ozone::PolygonFillMode fillStyle)
overload0:
    {
        Ozone::GraphicsPath* path_instance = (Ozone::GraphicsPath*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsPath);

        auto &__arg0 = *path_instance;
        unsigned int fillStyle;
        if (JS_ToUint32(ctx, (uint32_t*) &fillStyle, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = (::Ozone::PolygonFillMode)fillStyle;
        instance->FillPath(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::DrawPath
static JSValue callback_method_Ozone_GraphicsContext_DrawPath(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawPath(const ::Ozone::GraphicsPath& path, ::Ozone::PolygonFillMode fillStyle)
overload0:
    {
        Ozone::GraphicsPath* path_instance = (Ozone::GraphicsPath*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsPath);

        auto &__arg0 = *path_instance;
        unsigned int fillStyle;
        if (JS_ToUint32(ctx, (uint32_t*) &fillStyle, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = (::Ozone::PolygonFillMode)fillStyle;
        instance->DrawPath(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::ClearRectangle
static JSValue callback_method_Ozone_GraphicsContext_ClearRectangle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void ClearRectangle(double x, double y, double w, double h)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        double w;
        if (JS_ToFloat64(ctx, &w, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = w;
        double h;
        if (JS_ToFloat64(ctx, &h, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = h;
        instance->ClearRectangle(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::DrawText
static JSValue callback_method_Ozone_GraphicsContext_DrawText(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 5)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsString(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawText(const char* str, double x, double y)
overload0:
    {
        const char* str;
        str = JS_ToCString(ctx, argv[0]);
        if (!str)
            return JS_EXCEPTION;

        auto __arg0 = str;
        double x;
        if (JS_ToFloat64(ctx, &x, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = y;
        instance->DrawText(__arg0, __arg1, __arg2);

        JS_FreeCString(ctx, str);


        return JS_UNDEFINED;
    }

    // void DrawText(const char* str, double x, double y, double angle)
overload1:
    {
        const char* str;
        str = JS_ToCString(ctx, argv[0]);
        if (!str)
            return JS_EXCEPTION;

        auto __arg0 = str;
        double x;
        if (JS_ToFloat64(ctx, &x, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = y;
        double angle;
        if (JS_ToFloat64(ctx, &angle, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = angle;
        instance->DrawText(__arg0, __arg1, __arg2, __arg3);

        JS_FreeCString(ctx, str);


        return JS_UNDEFINED;
    }

    // void DrawText(const char* str, double x, double y, const ::Ozone::GraphicsBrush& backgroundBrush)
overload2:
    {
        const char* str;
        str = JS_ToCString(ctx, argv[0]);
        if (!str)
            return JS_EXCEPTION;

        auto __arg0 = str;
        double x;
        if (JS_ToFloat64(ctx, &x, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = y;
        Ozone::GraphicsBrush* backgroundBrush_instance = (Ozone::GraphicsBrush*) JS_GetOpaque(argv[3], classId_Ozone_GraphicsBrush);

        auto &__arg3 = *backgroundBrush_instance;
        instance->DrawText(__arg0, __arg1, __arg2, __arg3);

        JS_FreeCString(ctx, str);


        return JS_UNDEFINED;
    }

    // void DrawText(const char* str, double x, double y, double angle, const ::Ozone::GraphicsBrush& backgroundBrush)
overload3:
    {
        const char* str;
        str = JS_ToCString(ctx, argv[0]);
        if (!str)
            return JS_EXCEPTION;

        auto __arg0 = str;
        double x;
        if (JS_ToFloat64(ctx, &x, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = y;
        double angle;
        if (JS_ToFloat64(ctx, &angle, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = angle;
        Ozone::GraphicsBrush* backgroundBrush_instance = (Ozone::GraphicsBrush*) JS_GetOpaque(argv[4], classId_Ozone_GraphicsBrush);

        auto &__arg4 = *backgroundBrush_instance;
        instance->DrawText(__arg0, __arg1, __arg2, __arg3, __arg4);

        JS_FreeCString(ctx, str);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::DrawBitmap
static JSValue callback_method_Ozone_GraphicsContext_DrawBitmap(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 5 || argc > 5)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawBitmap(const ::Ozone::GraphicsBitmap& bmp, double x, double y, double w, double h)
overload0:
    {
        Ozone::GraphicsBitmap* bmp_instance = (Ozone::GraphicsBitmap*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsBitmap);

        auto &__arg0 = *bmp_instance;
        double x;
        if (JS_ToFloat64(ctx, &x, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = y;
        double w;
        if (JS_ToFloat64(ctx, &w, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = w;
        double h;
        if (JS_ToFloat64(ctx, &h, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = h;
        instance->DrawBitmap(__arg0, __arg1, __arg2, __arg3, __arg4);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::StrokeLine
static JSValue callback_method_Ozone_GraphicsContext_StrokeLine(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void StrokeLine(double x1, double y1, double x2, double y2)
overload0:
    {
        double x1;
        if (JS_ToFloat64(ctx, &x1, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x1;
        double y1;
        if (JS_ToFloat64(ctx, &y1, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y1;
        double x2;
        if (JS_ToFloat64(ctx, &x2, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = x2;
        double y2;
        if (JS_ToFloat64(ctx, &y2, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = y2;
        instance->StrokeLine(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::DrawRectangle
static JSValue callback_method_Ozone_GraphicsContext_DrawRectangle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawRectangle(double x, double y, double w, double h)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        double w;
        if (JS_ToFloat64(ctx, &w, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = w;
        double h;
        if (JS_ToFloat64(ctx, &h, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = h;
        instance->DrawRectangle(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::DrawEllipse
static JSValue callback_method_Ozone_GraphicsContext_DrawEllipse(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawEllipse(double x, double y, double w, double h)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        double w;
        if (JS_ToFloat64(ctx, &w, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = w;
        double h;
        if (JS_ToFloat64(ctx, &h, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = h;
        instance->DrawEllipse(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::DrawRoundedRectangle
static JSValue callback_method_Ozone_GraphicsContext_DrawRoundedRectangle(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 5 || argc > 5)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void DrawRoundedRectangle(double x, double y, double w, double h, double radius)
overload0:
    {
        double x;
        if (JS_ToFloat64(ctx, &x, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y;
        double w;
        if (JS_ToFloat64(ctx, &w, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = w;
        double h;
        if (JS_ToFloat64(ctx, &h, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = h;
        double radius;
        if (JS_ToFloat64(ctx, &radius, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = radius;
        instance->DrawRoundedRectangle(__arg0, __arg1, __arg2, __arg3, __arg4);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::ShouldOffset
static JSValue callback_method_Ozone_GraphicsContext_ShouldOffset(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->ShouldOffset();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsContext::EnableOffset
static JSValue callback_method_Ozone_GraphicsContext_EnableOffset(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void EnableOffset(bool enable)
overload0:
    {
        bool enable;
        enable = JS_ToBool(ctx, argv[0]);
        if (enable == -1)
            return JS_EXCEPTION;

        auto __arg0 = enable;
        instance->EnableOffset(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GraphicsContext::DisableOffset
static JSValue callback_method_Ozone_GraphicsContext_DisableOffset(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    instance->DisableOffset();

    return JS_UNDEFINED;
}

// Ozone::GraphicsContext::OffsetEnabled
static JSValue callback_method_Ozone_GraphicsContext_OffsetEnabled(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->OffsetEnabled();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsContext::Create
static JSValue callback_method_Ozone_GraphicsContext_Create(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    if (argc == 0)
        goto overload2;

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsContext* Create(const ::Ozone::WindowDC& dc)
overload0:
    {
        Ozone::WindowDC* dc_instance = (Ozone::WindowDC*) JS_GetOpaque(argv[0], classId_Ozone_WindowDC);

        auto &__arg0 = *dc_instance;
        ::Ozone::GraphicsContext* __ret = ::Ozone::GraphicsContext::Create(__arg0);


        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }

    // ::Ozone::GraphicsContext* Create(::Ozone::Window* window)
overload1:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_GetOpaque(argv[0], classId_Ozone_Window);

        auto __arg0 = window_instance;
        ::Ozone::GraphicsContext* __ret = ::Ozone::GraphicsContext::Create(__arg0);


        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }

    // ::Ozone::GraphicsContext* Create()
overload2:
    {
        ::Ozone::GraphicsContext* __ret = ::Ozone::GraphicsContext::Create();

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsContext::CreateFromUnknownDC
static JSValue callback_method_Ozone_GraphicsContext_CreateFromUnknownDC(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsContext* CreateFromUnknownDC(const ::Ozone::DC& dc)
overload0:
    {
        Ozone::DC* dc_instance = (Ozone::DC*) JS_GetOpaque(argv[0], classId_Ozone_DC);

        auto &__arg0 = *dc_instance;
        ::Ozone::GraphicsContext* __ret = ::Ozone::GraphicsContext::CreateFromUnknownDC(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

static JSValue callback_class_Ozone_GraphicsContext_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsContext");
}

void finalizer_Ozone_GraphicsContext(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsContext* instance = (Ozone::GraphicsContext*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsContext
{
    "GraphicsContext",
    .finalizer = finalizer_Ozone_GraphicsContext
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsContext[]
{
    JS_CFUNC_DEF("GetWindow", 0, callback_method_Ozone_GraphicsContext_GetWindow),
    JS_CFUNC_DEF("StartDoc", 1, callback_method_Ozone_GraphicsContext_StartDoc),
    JS_CFUNC_DEF("EndDoc", 0, callback_method_Ozone_GraphicsContext_EndDoc),
    JS_CFUNC_DEF("StartPage", 2, callback_method_Ozone_GraphicsContext_StartPage),
    JS_CFUNC_DEF("EndPage", 0, callback_method_Ozone_GraphicsContext_EndPage),
    JS_CFUNC_DEF("Flush", 0, callback_method_Ozone_GraphicsContext_Flush),
    JS_CFUNC_DEF("CreatePath", 0, callback_method_Ozone_GraphicsContext_CreatePath),
    JS_CFUNC_DEF("CreatePen", 1, callback_method_Ozone_GraphicsContext_CreatePen),
    JS_CFUNC_DEF("CreateBrush", 1, callback_method_Ozone_GraphicsContext_CreateBrush),
    JS_CFUNC_DEF("CreateLinearGradientBrush", 7, callback_method_Ozone_GraphicsContext_CreateLinearGradientBrush),
    JS_CFUNC_DEF("CreateRadialGradientBrush", 8, callback_method_Ozone_GraphicsContext_CreateRadialGradientBrush),
    JS_CFUNC_DEF("CreateFont", 4, callback_method_Ozone_GraphicsContext_CreateFont),
    JS_CFUNC_DEF("CreateSubBitmap", 5, callback_method_Ozone_GraphicsContext_CreateSubBitmap),
    JS_CFUNC_DEF("CreateMatrix", 6, callback_method_Ozone_GraphicsContext_CreateMatrix),
    JS_CFUNC_DEF("PushState", 0, callback_method_Ozone_GraphicsContext_PushState),
    JS_CFUNC_DEF("PopState", 0, callback_method_Ozone_GraphicsContext_PopState),
    JS_CFUNC_DEF("Clip", 4, callback_method_Ozone_GraphicsContext_Clip),
    JS_CFUNC_DEF("ResetClip", 0, callback_method_Ozone_GraphicsContext_ResetClip),
    JS_CFUNC_DEF("GetAntialiasMode", 0, callback_method_Ozone_GraphicsContext_GetAntialiasMode),
    JS_CFUNC_DEF("SetAntialiasMode", 1, callback_method_Ozone_GraphicsContext_SetAntialiasMode),
    JS_CFUNC_DEF("GetInterpolationQuality", 0, callback_method_Ozone_GraphicsContext_GetInterpolationQuality),
    JS_CFUNC_DEF("SetInterpolationQuality", 1, callback_method_Ozone_GraphicsContext_SetInterpolationQuality),
    JS_CFUNC_DEF("GetCompositionMode", 0, callback_method_Ozone_GraphicsContext_GetCompositionMode),
    JS_CFUNC_DEF("SetCompositionMode", 1, callback_method_Ozone_GraphicsContext_SetCompositionMode),
    JS_CFUNC_DEF("BeginLayer", 1, callback_method_Ozone_GraphicsContext_BeginLayer),
    JS_CFUNC_DEF("EndLayer", 0, callback_method_Ozone_GraphicsContext_EndLayer),
    JS_CFUNC_DEF("Translate", 2, callback_method_Ozone_GraphicsContext_Translate),
    JS_CFUNC_DEF("Scale", 2, callback_method_Ozone_GraphicsContext_Scale),
    JS_CFUNC_DEF("Rotate", 1, callback_method_Ozone_GraphicsContext_Rotate),
    JS_CFUNC_DEF("ConcatTransform", 1, callback_method_Ozone_GraphicsContext_ConcatTransform),
    JS_CFUNC_DEF("SetTransform", 1, callback_method_Ozone_GraphicsContext_SetTransform),
    JS_CFUNC_DEF("GetTransform", 0, callback_method_Ozone_GraphicsContext_GetTransform),
    JS_CFUNC_DEF("SetPen", 1, callback_method_Ozone_GraphicsContext_SetPen),
    JS_CFUNC_DEF("SetBrush", 1, callback_method_Ozone_GraphicsContext_SetBrush),
    JS_CFUNC_DEF("SetFont", 1, callback_method_Ozone_GraphicsContext_SetFont),
    JS_CFUNC_DEF("StrokePath", 1, callback_method_Ozone_GraphicsContext_StrokePath),
    JS_CFUNC_DEF("FillPath", 2, callback_method_Ozone_GraphicsContext_FillPath),
    JS_CFUNC_DEF("DrawPath", 2, callback_method_Ozone_GraphicsContext_DrawPath),
    JS_CFUNC_DEF("ClearRectangle", 4, callback_method_Ozone_GraphicsContext_ClearRectangle),
    JS_CFUNC_DEF("DrawText", 5, callback_method_Ozone_GraphicsContext_DrawText),
    JS_CFUNC_DEF("DrawBitmap", 5, callback_method_Ozone_GraphicsContext_DrawBitmap),
    JS_CFUNC_DEF("StrokeLine", 4, callback_method_Ozone_GraphicsContext_StrokeLine),
    JS_CFUNC_DEF("DrawRectangle", 4, callback_method_Ozone_GraphicsContext_DrawRectangle),
    JS_CFUNC_DEF("DrawEllipse", 4, callback_method_Ozone_GraphicsContext_DrawEllipse),
    JS_CFUNC_DEF("DrawRoundedRectangle", 5, callback_method_Ozone_GraphicsContext_DrawRoundedRectangle),
    JS_CFUNC_DEF("ShouldOffset", 0, callback_method_Ozone_GraphicsContext_ShouldOffset),
    JS_CFUNC_DEF("EnableOffset", 1, callback_method_Ozone_GraphicsContext_EnableOffset),
    JS_CFUNC_DEF("DisableOffset", 0, callback_method_Ozone_GraphicsContext_DisableOffset),
    JS_CFUNC_DEF("OffsetEnabled", 0, callback_method_Ozone_GraphicsContext_OffsetEnabled),
    JS_CFUNC_DEF("Create", 1, callback_method_Ozone_GraphicsContext_Create),
    JS_CFUNC_DEF("CreateFromUnknownDC", 1, callback_method_Ozone_GraphicsContext_CreateFromUnknownDC),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsContext_toString),
};

static void register_class_Ozone_GraphicsContext(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsContext");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsContext);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsContext, &classDef_Ozone_GraphicsContext);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsContext, sizeof(funcDef_Ozone_GraphicsContext) / sizeof(funcDef_Ozone_GraphicsContext[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsContext, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsContext_GraphicsContext, "GraphicsContext", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsContext", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsContext);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GraphicsObject);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_GraphicsRenderer;

// Ozone::GraphicsRenderer::GraphicsRenderer
static JSValue callback_method_Ozone_GraphicsRenderer_GraphicsRenderer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance;

    instance = new Ozone::GraphicsRenderer();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsRenderer);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GraphicsRenderer);
    JS_FreeValue(ctx, proto);

    JS_SetOpaque(__obj, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::GraphicsRenderer::CreateContext
static JSValue callback_method_Ozone_GraphicsRenderer_CreateContext(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsContext* CreateContext(const ::Ozone::WindowDC& dc)
overload0:
    {
        Ozone::WindowDC* dc_instance = (Ozone::WindowDC*) JS_GetOpaque(argv[0], classId_Ozone_WindowDC);

        auto &__arg0 = *dc_instance;
        ::Ozone::GraphicsContext* __ret = instance->CreateContext(__arg0);


        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }

    // ::Ozone::GraphicsContext* CreateContext(::Ozone::Window* window)
overload1:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_GetOpaque(argv[0], classId_Ozone_Window);

        auto __arg0 = window_instance;
        ::Ozone::GraphicsContext* __ret = instance->CreateContext(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsRenderer::CreateContextFromUnknownDC
static JSValue callback_method_Ozone_GraphicsRenderer_CreateContextFromUnknownDC(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsContext* CreateContextFromUnknownDC(const ::Ozone::DC& dc)
overload0:
    {
        Ozone::DC* dc_instance = (Ozone::DC*) JS_GetOpaque(argv[0], classId_Ozone_DC);

        auto &__arg0 = *dc_instance;
        ::Ozone::GraphicsContext* __ret = instance->CreateContextFromUnknownDC(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsRenderer::CreateMeasuringContext
static JSValue callback_method_Ozone_GraphicsRenderer_CreateMeasuringContext(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    ::Ozone::GraphicsContext* __ret = instance->CreateMeasuringContext();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::GraphicsRenderer::CreatePath
static JSValue callback_method_Ozone_GraphicsRenderer_CreatePath(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    ::Ozone::GraphicsPath __ret = instance->CreatePath();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::GraphicsRenderer::CreateMatrix
static JSValue callback_method_Ozone_GraphicsRenderer_CreateMatrix(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 6 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[5]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsMatrix CreateMatrix(double a, double b, double c, double d, double tx, double ty)
overload0:
    {
        double a;
        if (JS_ToFloat64(ctx, &a, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = a;
        double b;
        if (JS_ToFloat64(ctx, &b, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = b;
        double c;
        if (JS_ToFloat64(ctx, &c, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = c;
        double d;
        if (JS_ToFloat64(ctx, &d, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = d;
        double tx;
        if (JS_ToFloat64(ctx, &tx, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = tx;
        double ty;
        if (JS_ToFloat64(ctx, &ty, argv[5]))
            return JS_EXCEPTION;

        auto __arg5 = ty;
        ::Ozone::GraphicsMatrix __ret = instance->CreateMatrix(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsRenderer::CreatePen
static JSValue callback_method_Ozone_GraphicsRenderer_CreatePen(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsPen CreatePen(const ::Ozone::GraphicsPenInfo& info)
overload0:
    {
        Ozone::GraphicsPenInfo* info_instance = (Ozone::GraphicsPenInfo*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsPenInfo);

        auto &__arg0 = *info_instance;
        ::Ozone::GraphicsPen __ret = instance->CreatePen(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsRenderer::CreateBrush
static JSValue callback_method_Ozone_GraphicsRenderer_CreateBrush(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsBrush CreateBrush(const ::Ozone::Brush& brush)
overload0:
    {
        Ozone::Brush* brush_instance = (Ozone::Brush*) JS_GetOpaque(argv[0], classId_Ozone_Brush);

        auto &__arg0 = *brush_instance;
        ::Ozone::GraphicsBrush __ret = instance->CreateBrush(__arg0);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsRenderer::CreateLinearGradientBrush
static JSValue callback_method_Ozone_GraphicsRenderer_CreateLinearGradientBrush(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 6 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsObject(argv[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (JS_IsObject(argv[5]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsBrush CreateLinearGradientBrush(double x1, double y1, double x2, double y2, const ::Ozone::GraphicsGradientStops& stops, const ::Ozone::GraphicsMatrix& matrix)
overload0:
    {
        double x1;
        if (JS_ToFloat64(ctx, &x1, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = x1;
        double y1;
        if (JS_ToFloat64(ctx, &y1, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = y1;
        double x2;
        if (JS_ToFloat64(ctx, &x2, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = x2;
        double y2;
        if (JS_ToFloat64(ctx, &y2, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = y2;
        Ozone::GraphicsGradientStops* stops_instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(argv[4], classId_Ozone_GraphicsGradientStops);

        auto &__arg4 = *stops_instance;
        Ozone::GraphicsMatrix* matrix_instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(argv[5], classId_Ozone_GraphicsMatrix);

        auto &__arg5 = *matrix_instance;
        ::Ozone::GraphicsBrush __ret = instance->CreateLinearGradientBrush(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsRenderer::CreateRadialGradientBrush
static JSValue callback_method_Ozone_GraphicsRenderer_CreateRadialGradientBrush(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 7 || argc > 7)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto typecheck5;

    goto error;

typecheck5:
    if (JS_IsObject(argv[5]))
        goto typecheck6;

    goto error;

typecheck6:
    if (JS_IsObject(argv[6]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsBrush CreateRadialGradientBrush(double startX, double startY, double endX, double endY, double radius, const ::Ozone::GraphicsGradientStops& stops, const ::Ozone::GraphicsMatrix& matrix)
overload0:
    {
        double startX;
        if (JS_ToFloat64(ctx, &startX, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = startX;
        double startY;
        if (JS_ToFloat64(ctx, &startY, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = startY;
        double endX;
        if (JS_ToFloat64(ctx, &endX, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = endX;
        double endY;
        if (JS_ToFloat64(ctx, &endY, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = endY;
        double radius;
        if (JS_ToFloat64(ctx, &radius, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = radius;
        Ozone::GraphicsGradientStops* stops_instance = (Ozone::GraphicsGradientStops*) JS_GetOpaque(argv[5], classId_Ozone_GraphicsGradientStops);

        auto &__arg5 = *stops_instance;
        Ozone::GraphicsMatrix* matrix_instance = (Ozone::GraphicsMatrix*) JS_GetOpaque(argv[6], classId_Ozone_GraphicsMatrix);

        auto &__arg6 = *matrix_instance;
        ::Ozone::GraphicsBrush __ret = instance->CreateRadialGradientBrush(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsRenderer::CreateFont
static JSValue callback_method_Ozone_GraphicsRenderer_CreateFont(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 4 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsString(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsObject(argv[3]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsFont CreateFont(double sizeInPixels, const char* facename, int flags, const ::Ozone::Color& col)
overload0:
    {
        double sizeInPixels;
        if (JS_ToFloat64(ctx, &sizeInPixels, argv[0]))
            return JS_EXCEPTION;

        auto __arg0 = sizeInPixels;
        const char* facename;
        facename = JS_ToCString(ctx, argv[1]);
        if (!facename)
            return JS_EXCEPTION;

        auto __arg1 = facename;
        int flags;
        if (JS_ToInt32(ctx, (int32_t*) &flags, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = flags;
        Ozone::Color* col_instance = (Ozone::Color*) JS_GetOpaque(argv[3], classId_Ozone_Color);

        auto &__arg3 = *col_instance;
        ::Ozone::GraphicsFont __ret = instance->CreateFont(__arg0, __arg1, __arg2, __arg3);

        JS_FreeCString(ctx, facename);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsRenderer::CreateSubBitmap
static JSValue callback_method_Ozone_GraphicsRenderer_CreateSubBitmap(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 5 || argc > 5)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[3]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[4]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::GraphicsBitmap CreateSubBitmap(const ::Ozone::GraphicsBitmap& bitmap, double x, double y, double w, double h)
overload0:
    {
        Ozone::GraphicsBitmap* bitmap_instance = (Ozone::GraphicsBitmap*) JS_GetOpaque(argv[0], classId_Ozone_GraphicsBitmap);

        auto &__arg0 = *bitmap_instance;
        double x;
        if (JS_ToFloat64(ctx, &x, argv[1]))
            return JS_EXCEPTION;

        auto __arg1 = x;
        double y;
        if (JS_ToFloat64(ctx, &y, argv[2]))
            return JS_EXCEPTION;

        auto __arg2 = y;
        double w;
        if (JS_ToFloat64(ctx, &w, argv[3]))
            return JS_EXCEPTION;

        auto __arg3 = w;
        double h;
        if (JS_ToFloat64(ctx, &h, argv[4]))
            return JS_EXCEPTION;

        auto __arg4 = h;
        ::Ozone::GraphicsBitmap __ret = instance->CreateSubBitmap(__arg0, __arg1, __arg2, __arg3, __arg4);

        JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

        return ____ret_instance;
    }
}

// Ozone::GraphicsRenderer::GetName
static JSValue callback_method_Ozone_GraphicsRenderer_GetName(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(this_val, 0);

    const char* __ret = instance->GetName();

    JSValue ____ret = JS_NewString(ctx, __ret);

    return ____ret;
}

// Ozone::GraphicsRenderer::GetDefaultRenderer
static JSValue callback_method_Ozone_GraphicsRenderer_GetDefaultRenderer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    ::Ozone::GraphicsRenderer* __ret = ::Ozone::GraphicsRenderer::GetDefaultRenderer();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

// Ozone::GraphicsRenderer::GetCairoRenderer
static JSValue callback_method_Ozone_GraphicsRenderer_GetCairoRenderer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    ::Ozone::GraphicsRenderer* __ret = ::Ozone::GraphicsRenderer::GetCairoRenderer();

    JSValue ____ret_instance = JS_NewObjectClass(ctx, 0);

    return ____ret_instance;
}

static JSValue callback_class_Ozone_GraphicsRenderer_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GraphicsRenderer");
}

void finalizer_Ozone_GraphicsRenderer(JSRuntime *rt, JSValue val)
{
    Ozone::GraphicsRenderer* instance = (Ozone::GraphicsRenderer*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GraphicsRenderer
{
    "GraphicsRenderer",
    .finalizer = finalizer_Ozone_GraphicsRenderer
};

static JSCFunctionListEntry funcDef_Ozone_GraphicsRenderer[]
{
    JS_CFUNC_DEF("CreateContext", 1, callback_method_Ozone_GraphicsRenderer_CreateContext),
    JS_CFUNC_DEF("CreateContextFromUnknownDC", 1, callback_method_Ozone_GraphicsRenderer_CreateContextFromUnknownDC),
    JS_CFUNC_DEF("CreateMeasuringContext", 0, callback_method_Ozone_GraphicsRenderer_CreateMeasuringContext),
    JS_CFUNC_DEF("CreatePath", 0, callback_method_Ozone_GraphicsRenderer_CreatePath),
    JS_CFUNC_DEF("CreateMatrix", 6, callback_method_Ozone_GraphicsRenderer_CreateMatrix),
    JS_CFUNC_DEF("CreatePen", 1, callback_method_Ozone_GraphicsRenderer_CreatePen),
    JS_CFUNC_DEF("CreateBrush", 1, callback_method_Ozone_GraphicsRenderer_CreateBrush),
    JS_CFUNC_DEF("CreateLinearGradientBrush", 6, callback_method_Ozone_GraphicsRenderer_CreateLinearGradientBrush),
    JS_CFUNC_DEF("CreateRadialGradientBrush", 7, callback_method_Ozone_GraphicsRenderer_CreateRadialGradientBrush),
    JS_CFUNC_DEF("CreateFont", 4, callback_method_Ozone_GraphicsRenderer_CreateFont),
    JS_CFUNC_DEF("CreateSubBitmap", 5, callback_method_Ozone_GraphicsRenderer_CreateSubBitmap),
    JS_CFUNC_DEF("GetName", 0, callback_method_Ozone_GraphicsRenderer_GetName),
    JS_CFUNC_DEF("GetDefaultRenderer", 0, callback_method_Ozone_GraphicsRenderer_GetDefaultRenderer),
    JS_CFUNC_DEF("GetCairoRenderer", 0, callback_method_Ozone_GraphicsRenderer_GetCairoRenderer),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GraphicsRenderer_toString),
};

static void register_class_Ozone_GraphicsRenderer(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GraphicsRenderer");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GraphicsRenderer);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GraphicsRenderer, &classDef_Ozone_GraphicsRenderer);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GraphicsRenderer, sizeof(funcDef_Ozone_GraphicsRenderer) / sizeof(funcDef_Ozone_GraphicsRenderer[0]));
        JS_SetClassProto(ctx, classId_Ozone_GraphicsRenderer, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GraphicsRenderer_GraphicsRenderer, "GraphicsRenderer", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GraphicsRenderer", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_GraphicsRenderer);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Object);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

void register_ozone_graphics(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (phase == 0)
    {
        register_enum_Ozone_GradientType(ctx, m, set);

        register_enum_Ozone_AntialiasMode(ctx, m, set);

        register_enum_Ozone_InterpolationQuality(ctx, m, set);

        register_enum_Ozone_CompositionMode(ctx, m, set);
    }

    register_class_Ozone_GraphicsObject(ctx, m, set, phase);

    register_class_Ozone_GraphicsPen(ctx, m, set, phase);

    register_class_Ozone_GraphicsBrush(ctx, m, set, phase);

    register_class_Ozone_GraphicsFont(ctx, m, set, phase);

    register_class_Ozone_GraphicsBitmap(ctx, m, set, phase);

    register_class_Ozone_GraphicsMatrix(ctx, m, set, phase);

    register_class_Ozone_GraphicsGradientStop(ctx, m, set, phase);

    register_class_Ozone_GraphicsGradientStops(ctx, m, set, phase);

    register_class_Ozone_GraphicsPenInfo(ctx, m, set, phase);

    register_class_Ozone_GraphicsPath(ctx, m, set, phase);

    register_class_Ozone_GraphicsContext(ctx, m, set, phase);

    register_class_Ozone_GraphicsRenderer(ctx, m, set, phase);
}

} // extern "C"
