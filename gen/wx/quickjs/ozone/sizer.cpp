// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <CppSharp_QuickJS.h>
#include <assert.h>
#include <ozone/sizer.h>

extern "C" {

extern JSClassID classId_Ozone_SizerFlags;
extern JSClassID classId_Ozone_SizerSpacer;
extern JSClassID classId_Ozone_Size;
extern JSClassID classId_Ozone_SizerItem;
extern JSClassID classId_Ozone_Object;
extern JSClassID classId_Ozone_Window;
extern JSClassID classId_Ozone_Sizer;
extern JSClassID classId_Ozone_Point;
extern JSClassID classId_Ozone_Rect;
extern JSClassID classId_Ozone_SizerItemList;
extern JSClassID classId_Ozone_GridSizer;
extern JSClassID classId_Ozone_FlexGridSizer;
extern JSClassID classId_Ozone_BoxSizer;
extern JSClassID classId_Ozone_StaticBoxSizer;
extern JSClassID classId_Ozone_StdDialogButtonSizer;
extern JSClassID classId__Signal;

static void register_enum_Ozone_FlexSizerGrowMode(JSContext *ctx, JSModuleDef *m, bool set)
{
    if (!set)
    {
        int status = JS_AddModuleExport(ctx, m, "FlexSizerGrowMode");
        assert(status != -1);
        return;
    }

    JSValue val = JS_NewObject(ctx);

    // NONE
    {
        JSValue __item = JS_NewUint32(ctx, 0);
        JS_SetPropertyStr(ctx, val, "NONE", __item);
    }

    // SPECIFIED
    {
        JSValue __item = JS_NewUint32(ctx, 1);
        JS_SetPropertyStr(ctx, val, "SPECIFIED", __item);
    }

    // ALL
    {
        JSValue __item = JS_NewUint32(ctx, 2);
        JS_SetPropertyStr(ctx, val, "ALL", __item);
    }

    int status = JS_SetModuleExport(ctx, m, "FlexSizerGrowMode", val);
    assert(status != -1);
}

JSClassID classId_Ozone_SizerFlags;

// Ozone::SizerFlags::SizerFlags
static JSValue callback_method_Ozone_SizerFlags_SizerFlags(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerFlags* instance;

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // SizerFlags(int proportion)
overload0:
    {
        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[0]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg0 = proportion;

        instance = new Ozone::SizerFlags(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_SizerFlags);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_SizerFlags);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::SizerFlags::GetProportion
static JSValue callback_method_Ozone_SizerFlags_GetProportion(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerFlags* instance = (Ozone::SizerFlags*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetProportion();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::SizerFlags::GetFlags
static JSValue callback_method_Ozone_SizerFlags_GetFlags(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerFlags* instance = (Ozone::SizerFlags*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetFlags();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::SizerFlags::GetBorderInPixels
static JSValue callback_method_Ozone_SizerFlags_GetBorderInPixels(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerFlags* instance = (Ozone::SizerFlags*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetBorderInPixels();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::SizerFlags::GetDefaultBorder
static JSValue callback_method_Ozone_SizerFlags_GetDefaultBorder(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    int __ret = ::Ozone::SizerFlags::GetDefaultBorder();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::SizerFlags::GetDefaultBorderFractional
static JSValue callback_method_Ozone_SizerFlags_GetDefaultBorderFractional(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    float __ret = ::Ozone::SizerFlags::GetDefaultBorderFractional();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_SizerFlags_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "SizerFlags");
}

void finalizer_Ozone_SizerFlags(JSRuntime *rt, JSValue val)
{
    Ozone::SizerFlags* instance = (Ozone::SizerFlags*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_SizerFlags
{
    "SizerFlags",
    .finalizer = finalizer_Ozone_SizerFlags
};

static JSCFunctionListEntry funcDef_Ozone_SizerFlags[]
{
    JS_CFUNC_DEF("GetProportion", 0, callback_method_Ozone_SizerFlags_GetProportion),
    JS_CFUNC_DEF("GetFlags", 0, callback_method_Ozone_SizerFlags_GetFlags),
    JS_CFUNC_DEF("GetBorderInPixels", 0, callback_method_Ozone_SizerFlags_GetBorderInPixels),
    JS_CFUNC_DEF("GetDefaultBorder", 0, callback_method_Ozone_SizerFlags_GetDefaultBorder),
    JS_CFUNC_DEF("GetDefaultBorderFractional", 0, callback_method_Ozone_SizerFlags_GetDefaultBorderFractional),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_SizerFlags_toString),
};

static void register_class_Ozone_SizerFlags(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "SizerFlags");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_SizerFlags);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_SizerFlags, &classDef_Ozone_SizerFlags);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_SizerFlags, sizeof(funcDef_Ozone_SizerFlags) / sizeof(funcDef_Ozone_SizerFlags[0]));
        JS_SetClassProto(ctx, classId_Ozone_SizerFlags, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_SizerFlags_SizerFlags, "SizerFlags", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "SizerFlags", ctor);
    }
}

JSClassID classId_Ozone_SizerSpacer;

// Ozone::SizerSpacer::SizerSpacer
static JSValue callback_method_Ozone_SizerSpacer_SizerSpacer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerSpacer* instance;

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // SizerSpacer(const ::Ozone::Size& size)
overload0:
    {
        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *size_instance;

        instance = new Ozone::SizerSpacer(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_SizerSpacer);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_SizerSpacer);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::SizerSpacer::SetSize
static JSValue callback_method_Ozone_SizerSpacer_SetSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerSpacer* instance = (Ozone::SizerSpacer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetSize(const ::Ozone::Size& size)
overload0:
    {
        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *size_instance;

        instance->SetSize(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerSpacer::Show
static JSValue callback_method_Ozone_SizerSpacer_Show(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerSpacer* instance = (Ozone::SizerSpacer*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Show(bool show)
overload0:
    {
        bool show;
        show = JS_ToBool(ctx, argv[0]);
        if (show == -1)
            return JS_EXCEPTION;
        auto __arg0 = show;

        instance->Show(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerSpacer::IsShown
static JSValue callback_method_Ozone_SizerSpacer_IsShown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerSpacer* instance = (Ozone::SizerSpacer*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsShown();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_SizerSpacer_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "SizerSpacer");
}

void finalizer_Ozone_SizerSpacer(JSRuntime *rt, JSValue val)
{
    Ozone::SizerSpacer* instance = (Ozone::SizerSpacer*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_SizerSpacer
{
    "SizerSpacer",
    .finalizer = finalizer_Ozone_SizerSpacer
};

static JSCFunctionListEntry funcDef_Ozone_SizerSpacer[]
{
    JS_CFUNC_DEF("SetSize", 1, callback_method_Ozone_SizerSpacer_SetSize),
    JS_CFUNC_DEF("Show", 1, callback_method_Ozone_SizerSpacer_Show),
    JS_CFUNC_DEF("IsShown", 0, callback_method_Ozone_SizerSpacer_IsShown),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_SizerSpacer_toString),
};

static void register_class_Ozone_SizerSpacer(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "SizerSpacer");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_SizerSpacer);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_SizerSpacer, &classDef_Ozone_SizerSpacer);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_SizerSpacer, sizeof(funcDef_Ozone_SizerSpacer) / sizeof(funcDef_Ozone_SizerSpacer[0]));
        JS_SetClassProto(ctx, classId_Ozone_SizerSpacer, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_SizerSpacer_SizerSpacer, "SizerSpacer", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "SizerSpacer", ctor);
    }
}

JSClassID classId_Ozone_SizerItem;

// Ozone::SizerItem::SizerItem
static JSValue callback_method_Ozone_SizerItem_SizerItem(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance;

    if (argc == 0)
        goto overload6;

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsNumber(argv[0]))
        goto typecheck3;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck4;

    if (JS_IsObject(argv[1]))
        goto overload1;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[1]))
        goto typecheck5;

    if (JS_IsObject(argv[1]))
        goto overload3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[1]))
        goto typecheck6;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[2]))
        goto typecheck7;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[2]))
        goto typecheck8;

    goto error;

typecheck6:
    if (JS_IsNumber(argv[2]))
        goto typecheck9;

    if (JS_IsObject(argv[2]))
        goto overload5;

    goto error;

typecheck7:
    if (JS_IsNumber(argv[3]))
        goto typecheck10;

    goto error;

typecheck8:
    if (JS_IsNumber(argv[3]))
        goto typecheck11;

    goto error;

typecheck9:
    if (JS_IsNumber(argv[3]))
        goto typecheck12;

    goto error;

typecheck10:
    if (JS_IsObject(argv[4]))
        goto overload0;

    goto error;

typecheck11:
    if (JS_IsObject(argv[4]))
        goto overload2;

    goto error;

typecheck12:
    if (JS_IsNumber(argv[4]))
        goto typecheck13;

    goto error;

typecheck13:
    if (JS_IsObject(argv[5]))
        goto overload4;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // SizerItem(::Ozone::Window* window, int proportion, int flag, int border, ::Ozone::Object* userData)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[1]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg1 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[2]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg2 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[3]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg3 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[4], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg4 = userData_instance;

        instance = new Ozone::SizerItem(__arg0, __arg1, __arg2, __arg3, __arg4);

        goto wrap;
    }

    // SizerItem(::Ozone::Window* window, const ::Ozone::SizerFlags& flags)
overload1:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *flags_instance;

        instance = new Ozone::SizerItem(__arg0, __arg1);

        goto wrap;
    }

    // SizerItem(::Ozone::Sizer* sizer, int proportion, int flag, int border, ::Ozone::Object* userData)
overload2:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[1]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg1 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[2]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg2 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[3]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg3 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[4], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg4 = userData_instance;

        instance = new Ozone::SizerItem(__arg0, __arg1, __arg2, __arg3, __arg4);

        goto wrap;
    }

    // SizerItem(::Ozone::Sizer* sizer, const ::Ozone::SizerFlags& flags)
overload3:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *flags_instance;

        instance = new Ozone::SizerItem(__arg0, __arg1);

        goto wrap;
    }

    // SizerItem(int width, int height, int proportion, int flag, int border, ::Ozone::Object* userData)
overload4:
    {
        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[0]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg0 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[1]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg1 = height;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[2]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg2 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[3]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg3 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[4]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg4 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[5], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg5 = userData_instance;

        instance = new Ozone::SizerItem(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);

        goto wrap;
    }

    // SizerItem(int width, int height, const ::Ozone::SizerFlags& flags)
overload5:
    {
        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[0]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg0 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[1]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg1 = height;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[2], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg2 = *flags_instance;

        instance = new Ozone::SizerItem(__arg0, __arg1, __arg2);

        goto wrap;
    }

    // SizerItem()
overload6:
    {
        instance = new Ozone::SizerItem();
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_SizerItem);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_SizerItem);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::SizerItem::DeleteWindows
static JSValue callback_method_Ozone_SizerItem_DeleteWindows(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    instance->DeleteWindows();

    return JS_UNDEFINED;
}

// Ozone::SizerItem::DetachSizer
static JSValue callback_method_Ozone_SizerItem_DetachSizer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    instance->DetachSizer();

    return JS_UNDEFINED;
}

// Ozone::SizerItem::DetachWindow
static JSValue callback_method_Ozone_SizerItem_DetachWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    instance->DetachWindow();

    return JS_UNDEFINED;
}

// Ozone::SizerItem::GetSize
static JSValue callback_method_Ozone_SizerItem_GetSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetSize();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizerItem::CalcMin
static JSValue callback_method_Ozone_SizerItem_CalcMin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->CalcMin();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizerItem::SetDimension
static JSValue callback_method_Ozone_SizerItem_SetDimension(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetDimension(const ::Ozone::Point& pos, const ::Ozone::Size& size)
overload0:
    {
        Ozone::Point* pos_instance = (Ozone::Point*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *pos_instance;

        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *size_instance;

        instance->SetDimension(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::GetMinSize
static JSValue callback_method_Ozone_SizerItem_GetMinSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetMinSize();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizerItem::GetMinSizeWithBorder
static JSValue callback_method_Ozone_SizerItem_GetMinSizeWithBorder(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetMinSizeWithBorder();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizerItem::GetMaxSize
static JSValue callback_method_Ozone_SizerItem_GetMaxSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetMaxSize();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizerItem::GetMaxSizeWithBorder
static JSValue callback_method_Ozone_SizerItem_GetMaxSizeWithBorder(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetMaxSizeWithBorder();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizerItem::SetMinSize
static JSValue callback_method_Ozone_SizerItem_SetMinSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetMinSize(const ::Ozone::Size& size)
overload0:
    {
        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *size_instance;

        instance->SetMinSize(__arg0);


        return JS_UNDEFINED;
    }

    // void SetMinSize(int x, int y)
overload1:
    {
        int x;
        int32_t _x;
        if (JS_ToInt32(ctx, &_x, argv[0]))
            return JS_EXCEPTION;
        x = (int)_x;
        auto __arg0 = x;

        int y;
        int32_t _y;
        if (JS_ToInt32(ctx, &_y, argv[1]))
            return JS_EXCEPTION;
        y = (int)_y;
        auto __arg1 = y;

        instance->SetMinSize(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::SetInitSize
static JSValue callback_method_Ozone_SizerItem_SetInitSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetInitSize(int x, int y)
overload0:
    {
        int x;
        int32_t _x;
        if (JS_ToInt32(ctx, &_x, argv[0]))
            return JS_EXCEPTION;
        x = (int)_x;
        auto __arg0 = x;

        int y;
        int32_t _y;
        if (JS_ToInt32(ctx, &_y, argv[1]))
            return JS_EXCEPTION;
        y = (int)_y;
        auto __arg1 = y;

        instance->SetInitSize(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::SetRatio
static JSValue callback_method_Ozone_SizerItem_SetRatio(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto overload1;

    if (JS_IsNumber(argv[0]))
        goto overload2;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetRatio(int width, int height)
overload0:
    {
        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[0]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg0 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[1]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg1 = height;

        instance->SetRatio(__arg0, __arg1);


        return JS_UNDEFINED;
    }

    // void SetRatio(const ::Ozone::Size& size)
overload1:
    {
        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *size_instance;

        instance->SetRatio(__arg0);


        return JS_UNDEFINED;
    }

    // void SetRatio(float ratio)
overload2:
    {
        float ratio;
        double _ratio;
        if (JS_ToFloat64(ctx, &_ratio, argv[0]))
            return JS_EXCEPTION;
        ratio = (float)_ratio;
        auto __arg0 = ratio;

        instance->SetRatio(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::GetRatio
static JSValue callback_method_Ozone_SizerItem_GetRatio(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    float __ret = instance->GetRatio();

    JSValue ____ret = JS_NewFloat64(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItem::GetRect
static JSValue callback_method_Ozone_SizerItem_GetRect(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Rect __ret = instance->GetRect();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Rect, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizerItem::SetId
static JSValue callback_method_Ozone_SizerItem_SetId(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetId(int id)
overload0:
    {
        int id;
        int32_t _id;
        if (JS_ToInt32(ctx, &_id, argv[0]))
            return JS_EXCEPTION;
        id = (int)_id;
        auto __arg0 = id;

        instance->SetId(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::GetId
static JSValue callback_method_Ozone_SizerItem_GetId(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetId();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItem::IsWindow
static JSValue callback_method_Ozone_SizerItem_IsWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsWindow();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItem::IsSizer
static JSValue callback_method_Ozone_SizerItem_IsSizer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsSizer();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItem::IsSpacer
static JSValue callback_method_Ozone_SizerItem_IsSpacer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsSpacer();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItem::SetProportion
static JSValue callback_method_Ozone_SizerItem_SetProportion(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetProportion(int proportion)
overload0:
    {
        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[0]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg0 = proportion;

        instance->SetProportion(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::GetProportion
static JSValue callback_method_Ozone_SizerItem_GetProportion(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetProportion();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItem::SetFlag
static JSValue callback_method_Ozone_SizerItem_SetFlag(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetFlag(int flag)
overload0:
    {
        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[0]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg0 = flag;

        instance->SetFlag(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::GetFlag
static JSValue callback_method_Ozone_SizerItem_GetFlag(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetFlag();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItem::SetBorder
static JSValue callback_method_Ozone_SizerItem_SetBorder(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetBorder(int border)
overload0:
    {
        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[0]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg0 = border;

        instance->SetBorder(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::GetBorder
static JSValue callback_method_Ozone_SizerItem_GetBorder(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetBorder();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItem::GetWindow
static JSValue callback_method_Ozone_SizerItem_GetWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->GetWindow();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT, (void*) __ret);

    return ____ret;
}

// Ozone::SizerItem::GetSizer
static JSValue callback_method_Ozone_SizerItem_GetSizer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Sizer* __ret = instance->GetSizer();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::SizerItem::GetSpacer
static JSValue callback_method_Ozone_SizerItem_GetSpacer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetSpacer();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizerItem::IsShown
static JSValue callback_method_Ozone_SizerItem_IsShown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsShown();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItem::Show
static JSValue callback_method_Ozone_SizerItem_Show(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Show(bool show)
overload0:
    {
        bool show;
        show = JS_ToBool(ctx, argv[0]);
        if (show == -1)
            return JS_EXCEPTION;
        auto __arg0 = show;

        instance->Show(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::SetUserData
static JSValue callback_method_Ozone_SizerItem_SetUserData(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetUserData(::Ozone::Object* userData)
overload0:
    {
        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = userData_instance;

        instance->SetUserData(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::GetUserData
static JSValue callback_method_Ozone_SizerItem_GetUserData(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Object* __ret = instance->GetUserData();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

    return ____ret;
}

// Ozone::SizerItem::GetPosition
static JSValue callback_method_Ozone_SizerItem_GetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    ::Ozone::Point __ret = instance->GetPosition();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::SizerItem::InformFirstDirection
static JSValue callback_method_Ozone_SizerItem_InformFirstDirection(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool InformFirstDirection(int direction, int size, int availableOtherDir)
overload0:
    {
        int direction;
        int32_t _direction;
        if (JS_ToInt32(ctx, &_direction, argv[0]))
            return JS_EXCEPTION;
        direction = (int)_direction;
        auto __arg0 = direction;

        int size;
        int32_t _size;
        if (JS_ToInt32(ctx, &_size, argv[1]))
            return JS_EXCEPTION;
        size = (int)_size;
        auto __arg1 = size;

        int availableOtherDir;
        int32_t _availableOtherDir;
        if (JS_ToInt32(ctx, &_availableOtherDir, argv[2]))
            return JS_EXCEPTION;
        availableOtherDir = (int)_availableOtherDir;
        auto __arg2 = availableOtherDir;

        bool __ret = instance->InformFirstDirection(__arg0, __arg1, __arg2);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::SizerItem::AssignWindow
static JSValue callback_method_Ozone_SizerItem_AssignWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AssignWindow(::Ozone::Window* window)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        instance->AssignWindow(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::AssignSizer
static JSValue callback_method_Ozone_SizerItem_AssignSizer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AssignSizer(::Ozone::Sizer* sizer)
overload0:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        instance->AssignSizer(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItem::AssignSpacer
static JSValue callback_method_Ozone_SizerItem_AssignSpacer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AssignSpacer(const ::Ozone::Size& size)
overload0:
    {
        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *size_instance;

        instance->AssignSpacer(__arg0);


        return JS_UNDEFINED;
    }

    // void AssignSpacer(int w, int h)
overload1:
    {
        int w;
        int32_t _w;
        if (JS_ToInt32(ctx, &_w, argv[0]))
            return JS_EXCEPTION;
        w = (int)_w;
        auto __arg0 = w;

        int h;
        int32_t _h;
        if (JS_ToInt32(ctx, &_h, argv[1]))
            return JS_EXCEPTION;
        h = (int)_h;
        auto __arg1 = h;

        instance->AssignSpacer(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

static JSValue callback_class_Ozone_SizerItem_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "SizerItem");
}

void finalizer_Ozone_SizerItem(JSRuntime *rt, JSValue val)
{
    Ozone::SizerItem* instance = (Ozone::SizerItem*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_SizerItem
{
    "SizerItem",
    .finalizer = finalizer_Ozone_SizerItem
};

static JSCFunctionListEntry funcDef_Ozone_SizerItem[]
{
    JS_CFUNC_DEF("DeleteWindows", 0, callback_method_Ozone_SizerItem_DeleteWindows),
    JS_CFUNC_DEF("DetachSizer", 0, callback_method_Ozone_SizerItem_DetachSizer),
    JS_CFUNC_DEF("DetachWindow", 0, callback_method_Ozone_SizerItem_DetachWindow),
    JS_CFUNC_DEF("GetSize", 0, callback_method_Ozone_SizerItem_GetSize),
    JS_CFUNC_DEF("CalcMin", 0, callback_method_Ozone_SizerItem_CalcMin),
    JS_CFUNC_DEF("SetDimension", 2, callback_method_Ozone_SizerItem_SetDimension),
    JS_CFUNC_DEF("GetMinSize", 0, callback_method_Ozone_SizerItem_GetMinSize),
    JS_CFUNC_DEF("GetMinSizeWithBorder", 0, callback_method_Ozone_SizerItem_GetMinSizeWithBorder),
    JS_CFUNC_DEF("GetMaxSize", 0, callback_method_Ozone_SizerItem_GetMaxSize),
    JS_CFUNC_DEF("GetMaxSizeWithBorder", 0, callback_method_Ozone_SizerItem_GetMaxSizeWithBorder),
    JS_CFUNC_DEF("SetMinSize", 2, callback_method_Ozone_SizerItem_SetMinSize),
    JS_CFUNC_DEF("SetInitSize", 2, callback_method_Ozone_SizerItem_SetInitSize),
    JS_CFUNC_DEF("SetRatio", 2, callback_method_Ozone_SizerItem_SetRatio),
    JS_CFUNC_DEF("GetRatio", 0, callback_method_Ozone_SizerItem_GetRatio),
    JS_CFUNC_DEF("GetRect", 0, callback_method_Ozone_SizerItem_GetRect),
    JS_CFUNC_DEF("SetId", 1, callback_method_Ozone_SizerItem_SetId),
    JS_CFUNC_DEF("GetId", 0, callback_method_Ozone_SizerItem_GetId),
    JS_CFUNC_DEF("IsWindow", 0, callback_method_Ozone_SizerItem_IsWindow),
    JS_CFUNC_DEF("IsSizer", 0, callback_method_Ozone_SizerItem_IsSizer),
    JS_CFUNC_DEF("IsSpacer", 0, callback_method_Ozone_SizerItem_IsSpacer),
    JS_CFUNC_DEF("SetProportion", 1, callback_method_Ozone_SizerItem_SetProportion),
    JS_CFUNC_DEF("GetProportion", 0, callback_method_Ozone_SizerItem_GetProportion),
    JS_CFUNC_DEF("SetFlag", 1, callback_method_Ozone_SizerItem_SetFlag),
    JS_CFUNC_DEF("GetFlag", 0, callback_method_Ozone_SizerItem_GetFlag),
    JS_CFUNC_DEF("SetBorder", 1, callback_method_Ozone_SizerItem_SetBorder),
    JS_CFUNC_DEF("GetBorder", 0, callback_method_Ozone_SizerItem_GetBorder),
    JS_CFUNC_DEF("GetWindow", 0, callback_method_Ozone_SizerItem_GetWindow),
    JS_CFUNC_DEF("GetSizer", 0, callback_method_Ozone_SizerItem_GetSizer),
    JS_CFUNC_DEF("GetSpacer", 0, callback_method_Ozone_SizerItem_GetSpacer),
    JS_CFUNC_DEF("IsShown", 0, callback_method_Ozone_SizerItem_IsShown),
    JS_CFUNC_DEF("Show", 1, callback_method_Ozone_SizerItem_Show),
    JS_CFUNC_DEF("SetUserData", 1, callback_method_Ozone_SizerItem_SetUserData),
    JS_CFUNC_DEF("GetUserData", 0, callback_method_Ozone_SizerItem_GetUserData),
    JS_CFUNC_DEF("GetPosition", 0, callback_method_Ozone_SizerItem_GetPosition),
    JS_CFUNC_DEF("InformFirstDirection", 3, callback_method_Ozone_SizerItem_InformFirstDirection),
    JS_CFUNC_DEF("AssignWindow", 1, callback_method_Ozone_SizerItem_AssignWindow),
    JS_CFUNC_DEF("AssignSizer", 1, callback_method_Ozone_SizerItem_AssignSizer),
    JS_CFUNC_DEF("AssignSpacer", 2, callback_method_Ozone_SizerItem_AssignSpacer),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_SizerItem_toString),
};

static void register_class_Ozone_SizerItem(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "SizerItem");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_SizerItem);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_SizerItem, &classDef_Ozone_SizerItem);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_SizerItem, sizeof(funcDef_Ozone_SizerItem) / sizeof(funcDef_Ozone_SizerItem[0]));
        JS_SetClassProto(ctx, classId_Ozone_SizerItem, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_SizerItem_SizerItem, "SizerItem", 6, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "SizerItem", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_SizerItem);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Object);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_SizerItemList;

// Ozone::SizerItemList::SizerItemList
static JSValue callback_method_Ozone_SizerItemList_SizerItemList(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance;

    if (JS_IsNumber(argv[0]))
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // SizerItemList(::Ozone::KeyType keyType)
overload0:
    {
        unsigned int keyType;
        uint32_t _keyType;
        if (JS_ToUint32(ctx, &_keyType, argv[0]))
            return JS_EXCEPTION;
        keyType = (unsigned int)_keyType;
        auto __arg0 = (::Ozone::KeyType)keyType;

        instance = new Ozone::SizerItemList(__arg0);

        goto wrap;
    }

    // explicit SizerItemList(unsigned long n, ::Ozone::SizerItem*const & v)
overload1:
    {
        unsigned long n;
        uint32_t _n;
        if (JS_ToUint32(ctx, &_n, argv[0]))
            return JS_EXCEPTION;
        n = (unsigned long)_n;
        auto __arg0 = n;

        Ozone::SizerItem* v_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg1 = v_instance;

        instance = new Ozone::SizerItemList(__arg0, __arg1);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_SizerItemList);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_SizerItemList);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::SizerItemList::operator[]
static JSValue callback_method_Ozone_SizerItemList_operator_Subscript(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* operator[](unsigned long index) const
overload0:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        ::Ozone::SizerItem* __ret = instance->operator[](__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::SizerItemList::DeleteObject
static JSValue callback_method_Ozone_SizerItemList_DeleteObject(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool DeleteObject(::Ozone::SizerItem* object)
overload0:
    {
        Ozone::SizerItem* object_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = object_instance;

        bool __ret = instance->DeleteObject(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::SizerItemList::Member
static JSValue callback_method_Ozone_SizerItemList_Member(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Member(const ::Ozone::SizerItem* object) const
overload0:
    {
        Ozone::SizerItem* object_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = object_instance;

        bool __ret = instance->Member(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::SizerItemList::IndexOf
static JSValue callback_method_Ozone_SizerItemList_IndexOf(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // int IndexOf(::Ozone::SizerItem* object) const
overload0:
    {
        Ozone::SizerItem* object_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = object_instance;

        int __ret = instance->IndexOf(__arg0);

        JSValue ____ret = JS_NewInt32(ctx, __ret);

        return ____ret;
    }
}

// Ozone::SizerItemList::resize
static JSValue callback_method_Ozone_SizerItemList_resize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void resize(unsigned long n, ::Ozone::SizerItem* v)
overload0:
    {
        unsigned long n;
        uint32_t _n;
        if (JS_ToUint32(ctx, &_n, argv[0]))
            return JS_EXCEPTION;
        n = (unsigned long)_n;
        auto __arg0 = n;

        Ozone::SizerItem* v_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg1 = v_instance;

        instance->resize(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItemList::size
static JSValue callback_method_Ozone_SizerItemList_size(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    unsigned long __ret = instance->size();

    JSValue ____ret = JS_NewUint32(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItemList::max_size
static JSValue callback_method_Ozone_SizerItemList_max_size(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    unsigned long __ret = instance->max_size();

    JSValue ____ret = JS_NewUint32(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItemList::empty
static JSValue callback_method_Ozone_SizerItemList_empty(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->empty();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::SizerItemList::push_front
static JSValue callback_method_Ozone_SizerItemList_push_front(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void push_front(::Ozone::SizerItem*const & v)
overload0:
    {
        Ozone::SizerItem* v_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = v_instance;

        instance->push_front(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItemList::pop_front
static JSValue callback_method_Ozone_SizerItemList_pop_front(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    instance->pop_front();

    return JS_UNDEFINED;
}

// Ozone::SizerItemList::push_back
static JSValue callback_method_Ozone_SizerItemList_push_back(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void push_back(::Ozone::SizerItem*const & v)
overload0:
    {
        Ozone::SizerItem* v_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = v_instance;

        instance->push_back(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItemList::pop_back
static JSValue callback_method_Ozone_SizerItemList_pop_back(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    instance->pop_back();

    return JS_UNDEFINED;
}

// Ozone::SizerItemList::assign
static JSValue callback_method_Ozone_SizerItemList_assign(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void assign(unsigned long n, ::Ozone::SizerItem*const & v)
overload0:
    {
        unsigned long n;
        uint32_t _n;
        if (JS_ToUint32(ctx, &_n, argv[0]))
            return JS_EXCEPTION;
        n = (unsigned long)_n;
        auto __arg0 = n;

        Ozone::SizerItem* v_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg1 = v_instance;

        instance->assign(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItemList::clear
static JSValue callback_method_Ozone_SizerItemList_clear(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    instance->clear();

    return JS_UNDEFINED;
}

// Ozone::SizerItemList::remove
static JSValue callback_method_Ozone_SizerItemList_remove(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void remove(::Ozone::SizerItem*const & v)
overload0:
    {
        Ozone::SizerItem* v_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = v_instance;

        instance->remove(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::SizerItemList::reverse
static JSValue callback_method_Ozone_SizerItemList_reverse(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(this_val, 0);

    instance->reverse();

    return JS_UNDEFINED;
}

static JSValue callback_class_Ozone_SizerItemList_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "SizerItemList");
}

void finalizer_Ozone_SizerItemList(JSRuntime *rt, JSValue val)
{
    Ozone::SizerItemList* instance = (Ozone::SizerItemList*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_SizerItemList
{
    "SizerItemList",
    .finalizer = finalizer_Ozone_SizerItemList
};

static JSCFunctionListEntry funcDef_Ozone_SizerItemList[]
{
    JS_CFUNC_DEF("operator[]", 1, callback_method_Ozone_SizerItemList_operator_Subscript),
    JS_CFUNC_DEF("DeleteObject", 1, callback_method_Ozone_SizerItemList_DeleteObject),
    JS_CFUNC_DEF("Member", 1, callback_method_Ozone_SizerItemList_Member),
    JS_CFUNC_DEF("IndexOf", 1, callback_method_Ozone_SizerItemList_IndexOf),
    JS_CFUNC_DEF("resize", 2, callback_method_Ozone_SizerItemList_resize),
    JS_CFUNC_DEF("size", 0, callback_method_Ozone_SizerItemList_size),
    JS_CFUNC_DEF("max_size", 0, callback_method_Ozone_SizerItemList_max_size),
    JS_CFUNC_DEF("empty", 0, callback_method_Ozone_SizerItemList_empty),
    JS_CFUNC_DEF("push_front", 1, callback_method_Ozone_SizerItemList_push_front),
    JS_CFUNC_DEF("pop_front", 0, callback_method_Ozone_SizerItemList_pop_front),
    JS_CFUNC_DEF("push_back", 1, callback_method_Ozone_SizerItemList_push_back),
    JS_CFUNC_DEF("pop_back", 0, callback_method_Ozone_SizerItemList_pop_back),
    JS_CFUNC_DEF("assign", 2, callback_method_Ozone_SizerItemList_assign),
    JS_CFUNC_DEF("clear", 0, callback_method_Ozone_SizerItemList_clear),
    JS_CFUNC_DEF("remove", 1, callback_method_Ozone_SizerItemList_remove),
    JS_CFUNC_DEF("reverse", 0, callback_method_Ozone_SizerItemList_reverse),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_SizerItemList_toString),
};

static void register_class_Ozone_SizerItemList(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "SizerItemList");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_SizerItemList);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_SizerItemList, &classDef_Ozone_SizerItemList);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_SizerItemList, sizeof(funcDef_Ozone_SizerItemList) / sizeof(funcDef_Ozone_SizerItemList[0]));
        JS_SetClassProto(ctx, classId_Ozone_SizerItemList, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_SizerItemList_SizerItemList, "SizerItemList", 2, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "SizerItemList", ctor);
    }
}

JSClassID classId_Ozone_Sizer;

// Ozone::Sizer::Sizer
static JSValue callback_method_Ozone_Sizer_Sizer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance;

    instance = new Ozone::Sizer();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_Sizer);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_Sizer);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::Sizer::Add
static JSValue callback_method_Ozone_Sizer_Add(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsNumber(argv[0]))
        goto typecheck3;

    if (JS_IsObject(argv[0]))
        goto overload6;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck4;

    if (JS_IsObject(argv[1]))
        goto overload3;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[1]))
        goto typecheck5;

    if (JS_IsObject(argv[1]))
        goto overload4;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[1]))
        goto typecheck6;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[2]))
        goto typecheck7;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[2]))
        goto typecheck8;

    goto error;

typecheck6:
    if (JS_IsNumber(argv[2]))
        goto typecheck9;

    if (JS_IsObject(argv[2]))
        goto overload5;

    goto error;

typecheck7:
    if (JS_IsNumber(argv[3]))
        goto typecheck10;

    goto error;

typecheck8:
    if (JS_IsNumber(argv[3]))
        goto typecheck11;

    goto error;

typecheck9:
    if (JS_IsNumber(argv[3]))
        goto typecheck12;

    goto error;

typecheck10:
    if (JS_IsObject(argv[4]))
        goto overload0;

    goto error;

typecheck11:
    if (JS_IsObject(argv[4]))
        goto overload1;

    goto error;

typecheck12:
    if (JS_IsNumber(argv[4]))
        goto typecheck13;

    goto error;

typecheck13:
    if (JS_IsObject(argv[5]))
        goto overload2;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* Add(::Ozone::Window* window, int proportion, int flag, int border, ::Ozone::Object* userData)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[1]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg1 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[2]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg2 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[3]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg3 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[4], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg4 = userData_instance;

        ::Ozone::SizerItem* __ret = instance->Add(__arg0, __arg1, __arg2, __arg3, __arg4);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Add(::Ozone::Sizer* sizer, int proportion, int flag, int border, ::Ozone::Object* userData)
overload1:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[1]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg1 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[2]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg2 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[3]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg3 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[4], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg4 = userData_instance;

        ::Ozone::SizerItem* __ret = instance->Add(__arg0, __arg1, __arg2, __arg3, __arg4);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Add(int width, int height, int proportion, int flag, int border, ::Ozone::Object* userData)
overload2:
    {
        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[0]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg0 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[1]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg1 = height;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[2]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg2 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[3]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg3 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[4]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg4 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[5], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg5 = userData_instance;

        ::Ozone::SizerItem* __ret = instance->Add(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Add(::Ozone::Window* window, const ::Ozone::SizerFlags& flags)
overload3:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *flags_instance;

        ::Ozone::SizerItem* __ret = instance->Add(__arg0, __arg1);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Add(::Ozone::Sizer* sizer, const ::Ozone::SizerFlags& flags)
overload4:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *flags_instance;

        ::Ozone::SizerItem* __ret = instance->Add(__arg0, __arg1);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Add(int width, int height, const ::Ozone::SizerFlags& flags)
overload5:
    {
        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[0]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg0 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[1]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg1 = height;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[2], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg2 = *flags_instance;

        ::Ozone::SizerItem* __ret = instance->Add(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Add(::Ozone::SizerItem* item)
overload6:
    {
        Ozone::SizerItem* item_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = item_instance;

        ::Ozone::SizerItem* __ret = instance->Add(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::Sizer::AddSpacer
static JSValue callback_method_Ozone_Sizer_AddSpacer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* AddSpacer(int size)
overload0:
    {
        int size;
        int32_t _size;
        if (JS_ToInt32(ctx, &_size, argv[0]))
            return JS_EXCEPTION;
        size = (int)_size;
        auto __arg0 = size;

        ::Ozone::SizerItem* __ret = instance->AddSpacer(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::Sizer::AddStretchSpacer
static JSValue callback_method_Ozone_Sizer_AddStretchSpacer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* AddStretchSpacer(int prop)
overload0:
    {
        int prop;
        int32_t _prop;
        if (JS_ToInt32(ctx, &_prop, argv[0]))
            return JS_EXCEPTION;
        prop = (int)_prop;
        auto __arg0 = prop;

        ::Ozone::SizerItem* __ret = instance->AddStretchSpacer(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::Sizer::Insert
static JSValue callback_method_Ozone_Sizer_Insert(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 7)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto typecheck2;

    if (JS_IsObject(argv[1]))
        goto typecheck3;

    if (JS_IsNumber(argv[1]))
        goto typecheck4;

    if (JS_IsObject(argv[1]))
        goto overload6;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto typecheck5;

    if (JS_IsObject(argv[2]))
        goto overload3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto typecheck6;

    if (JS_IsObject(argv[2]))
        goto overload4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[2]))
        goto typecheck7;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[3]))
        goto typecheck8;

    goto error;

typecheck6:
    if (JS_IsNumber(argv[3]))
        goto typecheck9;

    goto error;

typecheck7:
    if (JS_IsNumber(argv[3]))
        goto typecheck10;

    if (JS_IsObject(argv[3]))
        goto overload5;

    goto error;

typecheck8:
    if (JS_IsNumber(argv[4]))
        goto typecheck11;

    goto error;

typecheck9:
    if (JS_IsNumber(argv[4]))
        goto typecheck12;

    goto error;

typecheck10:
    if (JS_IsNumber(argv[4]))
        goto typecheck13;

    goto error;

typecheck11:
    if (JS_IsObject(argv[5]))
        goto overload0;

    goto error;

typecheck12:
    if (JS_IsObject(argv[5]))
        goto overload1;

    goto error;

typecheck13:
    if (JS_IsNumber(argv[5]))
        goto typecheck14;

    goto error;

typecheck14:
    if (JS_IsObject(argv[6]))
        goto overload2;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* Insert(unsigned long index, ::Ozone::Window* window, int proportion, int flag, int border, ::Ozone::Object* userData)
overload0:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg1 = window_instance;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[2]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg2 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[3]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg3 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[4]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg4 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[5], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg5 = userData_instance;

        ::Ozone::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Insert(unsigned long index, ::Ozone::Sizer* sizer, int proportion, int flag, int border, ::Ozone::Object* userData)
overload1:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg1 = sizer_instance;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[2]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg2 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[3]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg3 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[4]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg4 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[5], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg5 = userData_instance;

        ::Ozone::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Insert(unsigned long index, int width, int height, int proportion, int flag, int border, ::Ozone::Object* userData)
overload2:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[1]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg1 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[2]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg2 = height;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[3]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg3 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[4]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg4 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[5]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg5 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[6], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg6 = userData_instance;

        ::Ozone::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Insert(unsigned long index, ::Ozone::Window* window, const ::Ozone::SizerFlags& flags)
overload3:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg1 = window_instance;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[2], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg2 = *flags_instance;

        ::Ozone::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Insert(unsigned long index, ::Ozone::Sizer* sizer, const ::Ozone::SizerFlags& flags)
overload4:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg1 = sizer_instance;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[2], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg2 = *flags_instance;

        ::Ozone::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Insert(unsigned long index, int width, int height, const ::Ozone::SizerFlags& flags)
overload5:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[1]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg1 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[2]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg2 = height;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[3], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg3 = *flags_instance;

        ::Ozone::SizerItem* __ret = instance->Insert(__arg0, __arg1, __arg2, __arg3);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Insert(unsigned long index, ::Ozone::SizerItem* item)
overload6:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        Ozone::SizerItem* item_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg1 = item_instance;

        ::Ozone::SizerItem* __ret = instance->Insert(__arg0, __arg1);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::Sizer::InsertSpacer
static JSValue callback_method_Ozone_Sizer_InsertSpacer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* InsertSpacer(unsigned long index, int size)
overload0:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        int size;
        int32_t _size;
        if (JS_ToInt32(ctx, &_size, argv[1]))
            return JS_EXCEPTION;
        size = (int)_size;
        auto __arg1 = size;

        ::Ozone::SizerItem* __ret = instance->InsertSpacer(__arg0, __arg1);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::Sizer::InsertStretchSpacer
static JSValue callback_method_Ozone_Sizer_InsertStretchSpacer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* InsertStretchSpacer(unsigned long index, int prop)
overload0:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        int prop;
        int32_t _prop;
        if (JS_ToInt32(ctx, &_prop, argv[1]))
            return JS_EXCEPTION;
        prop = (int)_prop;
        auto __arg1 = prop;

        ::Ozone::SizerItem* __ret = instance->InsertStretchSpacer(__arg0, __arg1);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::Sizer::Prepend
static JSValue callback_method_Ozone_Sizer_Prepend(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 6)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsNumber(argv[0]))
        goto typecheck3;

    if (JS_IsObject(argv[0]))
        goto overload6;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck4;

    if (JS_IsObject(argv[1]))
        goto overload3;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[1]))
        goto typecheck5;

    if (JS_IsObject(argv[1]))
        goto overload4;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[1]))
        goto typecheck6;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[2]))
        goto typecheck7;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[2]))
        goto typecheck8;

    goto error;

typecheck6:
    if (JS_IsNumber(argv[2]))
        goto typecheck9;

    if (JS_IsObject(argv[2]))
        goto overload5;

    goto error;

typecheck7:
    if (JS_IsNumber(argv[3]))
        goto typecheck10;

    goto error;

typecheck8:
    if (JS_IsNumber(argv[3]))
        goto typecheck11;

    goto error;

typecheck9:
    if (JS_IsNumber(argv[3]))
        goto typecheck12;

    goto error;

typecheck10:
    if (JS_IsObject(argv[4]))
        goto overload0;

    goto error;

typecheck11:
    if (JS_IsObject(argv[4]))
        goto overload1;

    goto error;

typecheck12:
    if (JS_IsNumber(argv[4]))
        goto typecheck13;

    goto error;

typecheck13:
    if (JS_IsObject(argv[5]))
        goto overload2;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* Prepend(::Ozone::Window* window, int proportion, int flag, int border, ::Ozone::Object* userData)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[1]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg1 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[2]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg2 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[3]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg3 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[4], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg4 = userData_instance;

        ::Ozone::SizerItem* __ret = instance->Prepend(__arg0, __arg1, __arg2, __arg3, __arg4);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Prepend(::Ozone::Sizer* sizer, int proportion, int flag, int border, ::Ozone::Object* userData)
overload1:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[1]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg1 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[2]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg2 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[3]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg3 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[4], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg4 = userData_instance;

        ::Ozone::SizerItem* __ret = instance->Prepend(__arg0, __arg1, __arg2, __arg3, __arg4);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Prepend(int width, int height, int proportion, int flag, int border, ::Ozone::Object* userData)
overload2:
    {
        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[0]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg0 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[1]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg1 = height;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[2]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg2 = proportion;

        int flag;
        int32_t _flag;
        if (JS_ToInt32(ctx, &_flag, argv[3]))
            return JS_EXCEPTION;
        flag = (int)_flag;
        auto __arg3 = flag;

        int border;
        int32_t _border;
        if (JS_ToInt32(ctx, &_border, argv[4]))
            return JS_EXCEPTION;
        border = (int)_border;
        auto __arg4 = border;

        Ozone::Object* userData_instance = (Ozone::Object*) JS_Interop_GetInstance( argv[5], \
            classId_Ozone_Object, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg5 = userData_instance;

        ::Ozone::SizerItem* __ret = instance->Prepend(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Prepend(::Ozone::Window* window, const ::Ozone::SizerFlags& flags)
overload3:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *flags_instance;

        ::Ozone::SizerItem* __ret = instance->Prepend(__arg0, __arg1);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Prepend(::Ozone::Sizer* sizer, const ::Ozone::SizerFlags& flags)
overload4:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *flags_instance;

        ::Ozone::SizerItem* __ret = instance->Prepend(__arg0, __arg1);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Prepend(int width, int height, const ::Ozone::SizerFlags& flags)
overload5:
    {
        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[0]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg0 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[1]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg1 = height;

        Ozone::SizerFlags* flags_instance = (Ozone::SizerFlags*) JS_Interop_GetInstance( argv[2], \
            classId_Ozone_SizerFlags, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg2 = *flags_instance;

        ::Ozone::SizerItem* __ret = instance->Prepend(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* Prepend(::Ozone::SizerItem* item)
overload6:
    {
        Ozone::SizerItem* item_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = item_instance;

        ::Ozone::SizerItem* __ret = instance->Prepend(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::Sizer::PrependSpacer
static JSValue callback_method_Ozone_Sizer_PrependSpacer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* PrependSpacer(int size)
overload0:
    {
        int size;
        int32_t _size;
        if (JS_ToInt32(ctx, &_size, argv[0]))
            return JS_EXCEPTION;
        size = (int)_size;
        auto __arg0 = size;

        ::Ozone::SizerItem* __ret = instance->PrependSpacer(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::Sizer::PrependStretchSpacer
static JSValue callback_method_Ozone_Sizer_PrependStretchSpacer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* PrependStretchSpacer(int prop)
overload0:
    {
        int prop;
        int32_t _prop;
        if (JS_ToInt32(ctx, &_prop, argv[0]))
            return JS_EXCEPTION;
        prop = (int)_prop;
        auto __arg0 = prop;

        ::Ozone::SizerItem* __ret = instance->PrependStretchSpacer(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::Sizer::SetContainingWindow
static JSValue callback_method_Ozone_Sizer_SetContainingWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetContainingWindow(::Ozone::Window* window)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        instance->SetContainingWindow(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Sizer::GetContainingWindow
static JSValue callback_method_Ozone_Sizer_GetContainingWindow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    ::Ozone::Window* __ret = instance->GetContainingWindow();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT, (void*) __ret);

    return ____ret;
}

// Ozone::Sizer::Remove
static JSValue callback_method_Ozone_Sizer_Remove(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsNumber(argv[0]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Remove(::Ozone::Sizer* sizer)
overload0:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        bool __ret = instance->Remove(__arg0);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Remove(int index)
overload1:
    {
        int index;
        int32_t _index;
        if (JS_ToInt32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (int)_index;
        auto __arg0 = index;

        bool __ret = instance->Remove(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Sizer::Detach
static JSValue callback_method_Ozone_Sizer_Detach(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto overload1;

    if (JS_IsNumber(argv[0]))
        goto overload2;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Detach(::Ozone::Window* window)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        bool __ret = instance->Detach(__arg0);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Detach(::Ozone::Sizer* sizer)
overload1:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        bool __ret = instance->Detach(__arg0);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Detach(int index)
overload2:
    {
        int index;
        int32_t _index;
        if (JS_ToInt32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (int)_index;
        auto __arg0 = index;

        bool __ret = instance->Detach(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Sizer::Replace
static JSValue callback_method_Ozone_Sizer_Replace(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsNumber(argv[0]))
        goto typecheck3;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto typecheck4;

    goto error;

typecheck2:
    if (JS_IsObject(argv[1]))
        goto typecheck5;

    goto error;

typecheck3:
    if (JS_IsObject(argv[1]))
        goto overload2;

    goto error;

typecheck4:
    if (JS_IsBool(argv[2]))
        goto overload0;

    goto error;

typecheck5:
    if (JS_IsBool(argv[2]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Replace(::Ozone::Window* oldwin, ::Ozone::Window* newwin, bool recursive)
overload0:
    {
        Ozone::Window* oldwin_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = oldwin_instance;

        Ozone::Window* newwin_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg1 = newwin_instance;

        bool recursive;
        recursive = JS_ToBool(ctx, argv[2]);
        if (recursive == -1)
            return JS_EXCEPTION;
        auto __arg2 = recursive;

        bool __ret = instance->Replace(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Replace(::Ozone::Sizer* oldsz, ::Ozone::Sizer* newsz, bool recursive)
overload1:
    {
        Ozone::Sizer* oldsz_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = oldsz_instance;

        Ozone::Sizer* newsz_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg1 = newsz_instance;

        bool recursive;
        recursive = JS_ToBool(ctx, argv[2]);
        if (recursive == -1)
            return JS_EXCEPTION;
        auto __arg2 = recursive;

        bool __ret = instance->Replace(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Replace(unsigned long index, ::Ozone::SizerItem* newitem)
overload2:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        Ozone::SizerItem* newitem_instance = (Ozone::SizerItem*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg1 = newitem_instance;

        bool __ret = instance->Replace(__arg0, __arg1);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Sizer::Clear
static JSValue callback_method_Ozone_Sizer_Clear(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void Clear(bool delete_windows)
overload0:
    {
        bool delete_windows;
        delete_windows = JS_ToBool(ctx, argv[0]);
        if (delete_windows == -1)
            return JS_EXCEPTION;
        auto __arg0 = delete_windows;

        instance->Clear(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Sizer::DeleteWindows
static JSValue callback_method_Ozone_Sizer_DeleteWindows(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    instance->DeleteWindows();

    return JS_UNDEFINED;
}

// Ozone::Sizer::InformFirstDirection
static JSValue callback_method_Ozone_Sizer_InformFirstDirection(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool InformFirstDirection(int _0, int _1, int _2)
overload0:
    {
        int _0;
        int32_t __0;
        if (JS_ToInt32(ctx, &__0, argv[0]))
            return JS_EXCEPTION;
        _0 = (int)__0;
        auto __arg0 = _0;

        int _1;
        int32_t __1;
        if (JS_ToInt32(ctx, &__1, argv[1]))
            return JS_EXCEPTION;
        _1 = (int)__1;
        auto __arg1 = _1;

        int _2;
        int32_t __2;
        if (JS_ToInt32(ctx, &__2, argv[2]))
            return JS_EXCEPTION;
        _2 = (int)__2;
        auto __arg2 = _2;

        bool __ret = instance->InformFirstDirection(__arg0, __arg1, __arg2);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Sizer::SetMinSize
static JSValue callback_method_Ozone_Sizer_SetMinSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto overload1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetMinSize(int width, int height)
overload0:
    {
        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[0]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg0 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[1]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg1 = height;

        instance->SetMinSize(__arg0, __arg1);


        return JS_UNDEFINED;
    }

    // void SetMinSize(const ::Ozone::Size& size)
overload1:
    {
        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *size_instance;

        instance->SetMinSize(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Sizer::SetItemMinSize
static JSValue callback_method_Ozone_Sizer_SetItemMinSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsNumber(argv[0]))
        goto typecheck3;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck4;

    if (JS_IsObject(argv[1]))
        goto overload1;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[1]))
        goto typecheck5;

    if (JS_IsObject(argv[1]))
        goto overload3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[1]))
        goto typecheck6;

    if (JS_IsObject(argv[1]))
        goto overload5;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    goto error;

typecheck5:
    if (JS_IsNumber(argv[2]))
        goto overload2;

    goto error;

typecheck6:
    if (JS_IsNumber(argv[2]))
        goto overload4;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool SetItemMinSize(::Ozone::Window* window, int width, int height)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[1]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg1 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[2]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg2 = height;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool SetItemMinSize(::Ozone::Window* window, const ::Ozone::Size& size)
overload1:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *size_instance;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool SetItemMinSize(::Ozone::Sizer* sizer, int width, int height)
overload2:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[1]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg1 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[2]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg2 = height;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool SetItemMinSize(::Ozone::Sizer* sizer, const ::Ozone::Size& size)
overload3:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *size_instance;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool SetItemMinSize(unsigned long index, int width, int height)
overload4:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[1]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg1 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[2]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg2 = height;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool SetItemMinSize(unsigned long index, const ::Ozone::Size& size)
overload5:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *size_instance;

        bool __ret = instance->SetItemMinSize(__arg0, __arg1);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Sizer::GetSize
static JSValue callback_method_Ozone_Sizer_GetSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetSize();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::Sizer::GetPosition
static JSValue callback_method_Ozone_Sizer_GetPosition(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    ::Ozone::Point __ret = instance->GetPosition();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::Sizer::GetMinSize
static JSValue callback_method_Ozone_Sizer_GetMinSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->GetMinSize();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::Sizer::CalcMin
static JSValue callback_method_Ozone_Sizer_CalcMin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->CalcMin();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::Sizer::RepositionChildren
static JSValue callback_method_Ozone_Sizer_RepositionChildren(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void RepositionChildren(const ::Ozone::Size& _0)
overload0:
    {
        Ozone::Size* _0_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *_0_instance;

        instance->RepositionChildren(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Sizer::RecalcSizes
static JSValue callback_method_Ozone_Sizer_RecalcSizes(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    instance->RecalcSizes();

    return JS_UNDEFINED;
}

// Ozone::Sizer::Layout
static JSValue callback_method_Ozone_Sizer_Layout(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    instance->Layout();

    return JS_UNDEFINED;
}

// Ozone::Sizer::ComputeFittingClientSize
static JSValue callback_method_Ozone_Sizer_ComputeFittingClientSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Size ComputeFittingClientSize(::Ozone::Window* window)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        ::Ozone::Size __ret = instance->ComputeFittingClientSize(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

        return ____ret;
    }
}

// Ozone::Sizer::ComputeFittingWindowSize
static JSValue callback_method_Ozone_Sizer_ComputeFittingWindowSize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Size ComputeFittingWindowSize(::Ozone::Window* window)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        ::Ozone::Size __ret = instance->ComputeFittingWindowSize(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

        return ____ret;
    }
}

// Ozone::Sizer::Fit
static JSValue callback_method_Ozone_Sizer_Fit(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::Size Fit(::Ozone::Window* window)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        ::Ozone::Size __ret = instance->Fit(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

        return ____ret;
    }
}

// Ozone::Sizer::FitInside
static JSValue callback_method_Ozone_Sizer_FitInside(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void FitInside(::Ozone::Window* window)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        instance->FitInside(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Sizer::SetSizeHints
static JSValue callback_method_Ozone_Sizer_SetSizeHints(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetSizeHints(::Ozone::Window* window)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        instance->SetSizeHints(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Sizer::SetDimension
static JSValue callback_method_Ozone_Sizer_SetDimension(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    if (JS_IsNumber(argv[0]))
        goto typecheck2;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto overload0;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[1]))
        goto typecheck3;

    goto error;

typecheck3:
    if (JS_IsNumber(argv[2]))
        goto typecheck4;

    goto error;

typecheck4:
    if (JS_IsNumber(argv[3]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetDimension(const ::Ozone::Point& pos, const ::Ozone::Size& size)
overload0:
    {
        Ozone::Point* pos_instance = (Ozone::Point*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Point, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *pos_instance;

        Ozone::Size* size_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *size_instance;

        instance->SetDimension(__arg0, __arg1);


        return JS_UNDEFINED;
    }

    // void SetDimension(int x, int y, int width, int height)
overload1:
    {
        int x;
        int32_t _x;
        if (JS_ToInt32(ctx, &_x, argv[0]))
            return JS_EXCEPTION;
        x = (int)_x;
        auto __arg0 = x;

        int y;
        int32_t _y;
        if (JS_ToInt32(ctx, &_y, argv[1]))
            return JS_EXCEPTION;
        y = (int)_y;
        auto __arg1 = y;

        int width;
        int32_t _width;
        if (JS_ToInt32(ctx, &_width, argv[2]))
            return JS_EXCEPTION;
        width = (int)_width;
        auto __arg2 = width;

        int height;
        int32_t _height;
        if (JS_ToInt32(ctx, &_height, argv[3]))
            return JS_EXCEPTION;
        height = (int)_height;
        auto __arg3 = height;

        instance->SetDimension(__arg0, __arg1, __arg2, __arg3);

        return JS_UNDEFINED;
    }
}

// Ozone::Sizer::GetItemCount
static JSValue callback_method_Ozone_Sizer_GetItemCount(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    unsigned long __ret = instance->GetItemCount();

    JSValue ____ret = JS_NewUint32(ctx, __ret);

    return ____ret;
}

// Ozone::Sizer::IsEmpty
static JSValue callback_method_Ozone_Sizer_IsEmpty(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsEmpty();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::Sizer::GetItem
static JSValue callback_method_Ozone_Sizer_GetItem(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsNumber(argv[0]))
        goto overload2;

    goto error;

typecheck1:
    if (JS_IsBool(argv[1]))
        goto overload0;

    goto error;

typecheck2:
    if (JS_IsBool(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* GetItem(::Ozone::Window* window, bool recursive)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        bool recursive;
        recursive = JS_ToBool(ctx, argv[1]);
        if (recursive == -1)
            return JS_EXCEPTION;
        auto __arg1 = recursive;

        ::Ozone::SizerItem* __ret = instance->GetItem(__arg0, __arg1);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* GetItem(::Ozone::Sizer* sizer, bool recursive)
overload1:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        bool recursive;
        recursive = JS_ToBool(ctx, argv[1]);
        if (recursive == -1)
            return JS_EXCEPTION;
        auto __arg1 = recursive;

        ::Ozone::SizerItem* __ret = instance->GetItem(__arg0, __arg1);


        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }

    // ::Ozone::SizerItem* GetItem(unsigned long index)
overload2:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        ::Ozone::SizerItem* __ret = instance->GetItem(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::Sizer::GetItemById
static JSValue callback_method_Ozone_Sizer_GetItemById(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsBool(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* GetItemById(int id, bool recursive)
overload0:
    {
        int id;
        int32_t _id;
        if (JS_ToInt32(ctx, &_id, argv[0]))
            return JS_EXCEPTION;
        id = (int)_id;
        auto __arg0 = id;

        bool recursive;
        recursive = JS_ToBool(ctx, argv[1]);
        if (recursive == -1)
            return JS_EXCEPTION;
        auto __arg1 = recursive;

        ::Ozone::SizerItem* __ret = instance->GetItemById(__arg0, __arg1);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::Sizer::Show
static JSValue callback_method_Ozone_Sizer_Show(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsNumber(argv[0]))
        goto typecheck3;

    if (JS_IsBool(argv[0]))
        goto overload3;

    goto error;

typecheck1:
    if (JS_IsBool(argv[1]))
        goto typecheck4;

    goto error;

typecheck2:
    if (JS_IsBool(argv[1]))
        goto typecheck5;

    goto error;

typecheck3:
    if (JS_IsBool(argv[1]))
        goto overload2;

    goto error;

typecheck4:
    if (JS_IsBool(argv[2]))
        goto overload0;

    goto error;

typecheck5:
    if (JS_IsBool(argv[2]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Show(::Ozone::Window* window, bool show, bool recursive)
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        bool show;
        show = JS_ToBool(ctx, argv[1]);
        if (show == -1)
            return JS_EXCEPTION;
        auto __arg1 = show;

        bool recursive;
        recursive = JS_ToBool(ctx, argv[2]);
        if (recursive == -1)
            return JS_EXCEPTION;
        auto __arg2 = recursive;

        bool __ret = instance->Show(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Show(::Ozone::Sizer* sizer, bool show, bool recursive)
overload1:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        bool show;
        show = JS_ToBool(ctx, argv[1]);
        if (show == -1)
            return JS_EXCEPTION;
        auto __arg1 = show;

        bool recursive;
        recursive = JS_ToBool(ctx, argv[2]);
        if (recursive == -1)
            return JS_EXCEPTION;
        auto __arg2 = recursive;

        bool __ret = instance->Show(__arg0, __arg1, __arg2);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Show(unsigned long index, bool show)
overload2:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        bool show;
        show = JS_ToBool(ctx, argv[1]);
        if (show == -1)
            return JS_EXCEPTION;
        auto __arg1 = show;

        bool __ret = instance->Show(__arg0, __arg1);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // void Show(bool show)
overload3:
    {
        bool show;
        show = JS_ToBool(ctx, argv[0]);
        if (show == -1)
            return JS_EXCEPTION;
        auto __arg0 = show;

        instance->Show(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Sizer::Hide
static JSValue callback_method_Ozone_Sizer_Hide(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto typecheck1;

    if (JS_IsObject(argv[0]))
        goto typecheck2;

    if (JS_IsNumber(argv[0]))
        goto overload2;

    goto error;

typecheck1:
    if (JS_IsBool(argv[1]))
        goto overload0;

    goto error;

typecheck2:
    if (JS_IsBool(argv[1]))
        goto overload1;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Hide(::Ozone::Sizer* sizer, bool recursive)
overload0:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        bool recursive;
        recursive = JS_ToBool(ctx, argv[1]);
        if (recursive == -1)
            return JS_EXCEPTION;
        auto __arg1 = recursive;

        bool __ret = instance->Hide(__arg0, __arg1);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Hide(::Ozone::Window* window, bool recursive)
overload1:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        bool recursive;
        recursive = JS_ToBool(ctx, argv[1]);
        if (recursive == -1)
            return JS_EXCEPTION;
        auto __arg1 = recursive;

        bool __ret = instance->Hide(__arg0, __arg1);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Hide(unsigned long index)
overload2:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        bool __ret = instance->Hide(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Sizer::IsShown
static JSValue callback_method_Ozone_Sizer_IsShown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto overload1;

    if (JS_IsNumber(argv[0]))
        goto overload2;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool IsShown(::Ozone::Window* window) const
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        bool __ret = instance->IsShown(__arg0);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool IsShown(::Ozone::Sizer* sizer) const
overload1:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        bool __ret = instance->IsShown(__arg0);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool IsShown(unsigned long index) const
overload2:
    {
        unsigned long index;
        uint32_t _index;
        if (JS_ToUint32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (unsigned long)_index;
        auto __arg0 = index;

        bool __ret = instance->IsShown(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::Sizer::ShowItems
static JSValue callback_method_Ozone_Sizer_ShowItems(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void ShowItems(bool show)
overload0:
    {
        bool show;
        show = JS_ToBool(ctx, argv[0]);
        if (show == -1)
            return JS_EXCEPTION;
        auto __arg0 = show;

        instance->ShowItems(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::Sizer::AreAnyItemsShown
static JSValue callback_method_Ozone_Sizer_AreAnyItemsShown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->AreAnyItemsShown();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_Sizer_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "Sizer");
}

void finalizer_Ozone_Sizer(JSRuntime *rt, JSValue val)
{
    Ozone::Sizer* instance = (Ozone::Sizer*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_Sizer
{
    "Sizer",
    .finalizer = finalizer_Ozone_Sizer
};

static JSCFunctionListEntry funcDef_Ozone_Sizer[]
{
    JS_CFUNC_DEF("Add", 6, callback_method_Ozone_Sizer_Add),
    JS_CFUNC_DEF("AddSpacer", 1, callback_method_Ozone_Sizer_AddSpacer),
    JS_CFUNC_DEF("AddStretchSpacer", 1, callback_method_Ozone_Sizer_AddStretchSpacer),
    JS_CFUNC_DEF("Insert", 7, callback_method_Ozone_Sizer_Insert),
    JS_CFUNC_DEF("InsertSpacer", 2, callback_method_Ozone_Sizer_InsertSpacer),
    JS_CFUNC_DEF("InsertStretchSpacer", 2, callback_method_Ozone_Sizer_InsertStretchSpacer),
    JS_CFUNC_DEF("Prepend", 6, callback_method_Ozone_Sizer_Prepend),
    JS_CFUNC_DEF("PrependSpacer", 1, callback_method_Ozone_Sizer_PrependSpacer),
    JS_CFUNC_DEF("PrependStretchSpacer", 1, callback_method_Ozone_Sizer_PrependStretchSpacer),
    JS_CFUNC_DEF("SetContainingWindow", 1, callback_method_Ozone_Sizer_SetContainingWindow),
    JS_CFUNC_DEF("GetContainingWindow", 0, callback_method_Ozone_Sizer_GetContainingWindow),
    JS_CFUNC_DEF("Remove", 1, callback_method_Ozone_Sizer_Remove),
    JS_CFUNC_DEF("Detach", 1, callback_method_Ozone_Sizer_Detach),
    JS_CFUNC_DEF("Replace", 3, callback_method_Ozone_Sizer_Replace),
    JS_CFUNC_DEF("Clear", 1, callback_method_Ozone_Sizer_Clear),
    JS_CFUNC_DEF("DeleteWindows", 0, callback_method_Ozone_Sizer_DeleteWindows),
    JS_CFUNC_DEF("InformFirstDirection", 3, callback_method_Ozone_Sizer_InformFirstDirection),
    JS_CFUNC_DEF("SetMinSize", 2, callback_method_Ozone_Sizer_SetMinSize),
    JS_CFUNC_DEF("SetItemMinSize", 3, callback_method_Ozone_Sizer_SetItemMinSize),
    JS_CFUNC_DEF("GetSize", 0, callback_method_Ozone_Sizer_GetSize),
    JS_CFUNC_DEF("GetPosition", 0, callback_method_Ozone_Sizer_GetPosition),
    JS_CFUNC_DEF("GetMinSize", 0, callback_method_Ozone_Sizer_GetMinSize),
    JS_CFUNC_DEF("CalcMin", 0, callback_method_Ozone_Sizer_CalcMin),
    JS_CFUNC_DEF("RepositionChildren", 1, callback_method_Ozone_Sizer_RepositionChildren),
    JS_CFUNC_DEF("RecalcSizes", 0, callback_method_Ozone_Sizer_RecalcSizes),
    JS_CFUNC_DEF("Layout", 0, callback_method_Ozone_Sizer_Layout),
    JS_CFUNC_DEF("ComputeFittingClientSize", 1, callback_method_Ozone_Sizer_ComputeFittingClientSize),
    JS_CFUNC_DEF("ComputeFittingWindowSize", 1, callback_method_Ozone_Sizer_ComputeFittingWindowSize),
    JS_CFUNC_DEF("Fit", 1, callback_method_Ozone_Sizer_Fit),
    JS_CFUNC_DEF("FitInside", 1, callback_method_Ozone_Sizer_FitInside),
    JS_CFUNC_DEF("SetSizeHints", 1, callback_method_Ozone_Sizer_SetSizeHints),
    JS_CFUNC_DEF("SetDimension", 4, callback_method_Ozone_Sizer_SetDimension),
    JS_CFUNC_DEF("GetItemCount", 0, callback_method_Ozone_Sizer_GetItemCount),
    JS_CFUNC_DEF("IsEmpty", 0, callback_method_Ozone_Sizer_IsEmpty),
    JS_CFUNC_DEF("GetItem", 2, callback_method_Ozone_Sizer_GetItem),
    JS_CFUNC_DEF("GetItemById", 2, callback_method_Ozone_Sizer_GetItemById),
    JS_CFUNC_DEF("Show", 3, callback_method_Ozone_Sizer_Show),
    JS_CFUNC_DEF("Hide", 2, callback_method_Ozone_Sizer_Hide),
    JS_CFUNC_DEF("IsShown", 1, callback_method_Ozone_Sizer_IsShown),
    JS_CFUNC_DEF("ShowItems", 1, callback_method_Ozone_Sizer_ShowItems),
    JS_CFUNC_DEF("AreAnyItemsShown", 0, callback_method_Ozone_Sizer_AreAnyItemsShown),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_Sizer_toString),
};

static void register_class_Ozone_Sizer(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "Sizer");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_Sizer);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_Sizer, &classDef_Ozone_Sizer);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_Sizer, sizeof(funcDef_Ozone_Sizer) / sizeof(funcDef_Ozone_Sizer[0]));
        JS_SetClassProto(ctx, classId_Ozone_Sizer, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_Sizer_Sizer, "Sizer", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "Sizer", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_Sizer);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Object);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_GridSizer;

// Ozone::GridSizer::GridSizer
static JSValue callback_method_Ozone_GridSizer_GridSizer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    if (JS_IsObject(argv[1]))
        goto overload1;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    if (JS_IsObject(argv[2]))
        goto overload3;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // GridSizer(int cols, int vgap, int hgap)
overload0:
    {
        int cols;
        int32_t _cols;
        if (JS_ToInt32(ctx, &_cols, argv[0]))
            return JS_EXCEPTION;
        cols = (int)_cols;
        auto __arg0 = cols;

        int vgap;
        int32_t _vgap;
        if (JS_ToInt32(ctx, &_vgap, argv[1]))
            return JS_EXCEPTION;
        vgap = (int)_vgap;
        auto __arg1 = vgap;

        int hgap;
        int32_t _hgap;
        if (JS_ToInt32(ctx, &_hgap, argv[2]))
            return JS_EXCEPTION;
        hgap = (int)_hgap;
        auto __arg2 = hgap;

        instance = new Ozone::GridSizer(__arg0, __arg1, __arg2);

        goto wrap;
    }

    // GridSizer(int cols, const ::Ozone::Size& gap)
overload1:
    {
        int cols;
        int32_t _cols;
        if (JS_ToInt32(ctx, &_cols, argv[0]))
            return JS_EXCEPTION;
        cols = (int)_cols;
        auto __arg0 = cols;

        Ozone::Size* gap_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *gap_instance;

        instance = new Ozone::GridSizer(__arg0, __arg1);

        goto wrap;
    }

    // GridSizer(int rows, int cols, int vgap, int hgap)
overload2:
    {
        int rows;
        int32_t _rows;
        if (JS_ToInt32(ctx, &_rows, argv[0]))
            return JS_EXCEPTION;
        rows = (int)_rows;
        auto __arg0 = rows;

        int cols;
        int32_t _cols;
        if (JS_ToInt32(ctx, &_cols, argv[1]))
            return JS_EXCEPTION;
        cols = (int)_cols;
        auto __arg1 = cols;

        int vgap;
        int32_t _vgap;
        if (JS_ToInt32(ctx, &_vgap, argv[2]))
            return JS_EXCEPTION;
        vgap = (int)_vgap;
        auto __arg2 = vgap;

        int hgap;
        int32_t _hgap;
        if (JS_ToInt32(ctx, &_hgap, argv[3]))
            return JS_EXCEPTION;
        hgap = (int)_hgap;
        auto __arg3 = hgap;

        instance = new Ozone::GridSizer(__arg0, __arg1, __arg2, __arg3);

        goto wrap;
    }

    // GridSizer(int rows, int cols, const ::Ozone::Size& gap)
overload3:
    {
        int rows;
        int32_t _rows;
        if (JS_ToInt32(ctx, &_rows, argv[0]))
            return JS_EXCEPTION;
        rows = (int)_rows;
        auto __arg0 = rows;

        int cols;
        int32_t _cols;
        if (JS_ToInt32(ctx, &_cols, argv[1]))
            return JS_EXCEPTION;
        cols = (int)_cols;
        auto __arg1 = cols;

        Ozone::Size* gap_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[2], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg2 = *gap_instance;

        instance = new Ozone::GridSizer(__arg0, __arg1, __arg2);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_GridSizer);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_GridSizer);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::GridSizer::RepositionChildren
static JSValue callback_method_Ozone_GridSizer_RepositionChildren(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void RepositionChildren(const ::Ozone::Size& minSize) override
overload0:
    {
        Ozone::Size* minSize_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *minSize_instance;

        instance->RepositionChildren(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GridSizer::CalcMin
static JSValue callback_method_Ozone_GridSizer_CalcMin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->CalcMin();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::GridSizer::SetCols
static JSValue callback_method_Ozone_GridSizer_SetCols(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetCols(int cols)
overload0:
    {
        int cols;
        int32_t _cols;
        if (JS_ToInt32(ctx, &_cols, argv[0]))
            return JS_EXCEPTION;
        cols = (int)_cols;
        auto __arg0 = cols;

        instance->SetCols(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GridSizer::SetRows
static JSValue callback_method_Ozone_GridSizer_SetRows(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetRows(int rows)
overload0:
    {
        int rows;
        int32_t _rows;
        if (JS_ToInt32(ctx, &_rows, argv[0]))
            return JS_EXCEPTION;
        rows = (int)_rows;
        auto __arg0 = rows;

        instance->SetRows(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GridSizer::SetVGap
static JSValue callback_method_Ozone_GridSizer_SetVGap(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetVGap(int gap)
overload0:
    {
        int gap;
        int32_t _gap;
        if (JS_ToInt32(ctx, &_gap, argv[0]))
            return JS_EXCEPTION;
        gap = (int)_gap;
        auto __arg0 = gap;

        instance->SetVGap(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GridSizer::SetHGap
static JSValue callback_method_Ozone_GridSizer_SetHGap(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetHGap(int gap)
overload0:
    {
        int gap;
        int32_t _gap;
        if (JS_ToInt32(ctx, &_gap, argv[0]))
            return JS_EXCEPTION;
        gap = (int)_gap;
        auto __arg0 = gap;

        instance->SetHGap(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::GridSizer::GetCols
static JSValue callback_method_Ozone_GridSizer_GetCols(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetCols();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::GridSizer::GetRows
static JSValue callback_method_Ozone_GridSizer_GetRows(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetRows();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::GridSizer::GetVGap
static JSValue callback_method_Ozone_GridSizer_GetVGap(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetVGap();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::GridSizer::GetHGap
static JSValue callback_method_Ozone_GridSizer_GetHGap(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetHGap();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::GridSizer::GetEffectiveColsCount
static JSValue callback_method_Ozone_GridSizer_GetEffectiveColsCount(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetEffectiveColsCount();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::GridSizer::GetEffectiveRowsCount
static JSValue callback_method_Ozone_GridSizer_GetEffectiveRowsCount(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetEffectiveRowsCount();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

static JSValue callback_class_Ozone_GridSizer_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "GridSizer");
}

void finalizer_Ozone_GridSizer(JSRuntime *rt, JSValue val)
{
    Ozone::GridSizer* instance = (Ozone::GridSizer*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_GridSizer
{
    "GridSizer",
    .finalizer = finalizer_Ozone_GridSizer
};

static JSCFunctionListEntry funcDef_Ozone_GridSizer[]
{
    JS_CFUNC_DEF("RepositionChildren", 1, callback_method_Ozone_GridSizer_RepositionChildren),
    JS_CFUNC_DEF("CalcMin", 0, callback_method_Ozone_GridSizer_CalcMin),
    JS_CFUNC_DEF("SetCols", 1, callback_method_Ozone_GridSizer_SetCols),
    JS_CFUNC_DEF("SetRows", 1, callback_method_Ozone_GridSizer_SetRows),
    JS_CFUNC_DEF("SetVGap", 1, callback_method_Ozone_GridSizer_SetVGap),
    JS_CFUNC_DEF("SetHGap", 1, callback_method_Ozone_GridSizer_SetHGap),
    JS_CFUNC_DEF("GetCols", 0, callback_method_Ozone_GridSizer_GetCols),
    JS_CFUNC_DEF("GetRows", 0, callback_method_Ozone_GridSizer_GetRows),
    JS_CFUNC_DEF("GetVGap", 0, callback_method_Ozone_GridSizer_GetVGap),
    JS_CFUNC_DEF("GetHGap", 0, callback_method_Ozone_GridSizer_GetHGap),
    JS_CFUNC_DEF("GetEffectiveColsCount", 0, callback_method_Ozone_GridSizer_GetEffectiveColsCount),
    JS_CFUNC_DEF("GetEffectiveRowsCount", 0, callback_method_Ozone_GridSizer_GetEffectiveRowsCount),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_GridSizer_toString),
};

static void register_class_Ozone_GridSizer(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "GridSizer");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_GridSizer);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_GridSizer, &classDef_Ozone_GridSizer);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_GridSizer, sizeof(funcDef_Ozone_GridSizer) / sizeof(funcDef_Ozone_GridSizer[0]));
        JS_SetClassProto(ctx, classId_Ozone_GridSizer, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_GridSizer_GridSizer, "GridSizer", 4, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "GridSizer", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_GridSizer);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Sizer);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_FlexGridSizer;

// Ozone::FlexGridSizer::FlexGridSizer
static JSValue callback_method_Ozone_FlexGridSizer_FlexGridSizer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 4)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    if (JS_IsObject(argv[1]))
        goto overload1;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    if (JS_IsObject(argv[2]))
        goto overload3;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // FlexGridSizer(int cols, int vgap, int hgap)
overload0:
    {
        int cols;
        int32_t _cols;
        if (JS_ToInt32(ctx, &_cols, argv[0]))
            return JS_EXCEPTION;
        cols = (int)_cols;
        auto __arg0 = cols;

        int vgap;
        int32_t _vgap;
        if (JS_ToInt32(ctx, &_vgap, argv[1]))
            return JS_EXCEPTION;
        vgap = (int)_vgap;
        auto __arg1 = vgap;

        int hgap;
        int32_t _hgap;
        if (JS_ToInt32(ctx, &_hgap, argv[2]))
            return JS_EXCEPTION;
        hgap = (int)_hgap;
        auto __arg2 = hgap;

        instance = new Ozone::FlexGridSizer(__arg0, __arg1, __arg2);

        goto wrap;
    }

    // FlexGridSizer(int cols, const ::Ozone::Size& gap)
overload1:
    {
        int cols;
        int32_t _cols;
        if (JS_ToInt32(ctx, &_cols, argv[0]))
            return JS_EXCEPTION;
        cols = (int)_cols;
        auto __arg0 = cols;

        Ozone::Size* gap_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg1 = *gap_instance;

        instance = new Ozone::FlexGridSizer(__arg0, __arg1);

        goto wrap;
    }

    // FlexGridSizer(int rows, int cols, int vgap, int hgap)
overload2:
    {
        int rows;
        int32_t _rows;
        if (JS_ToInt32(ctx, &_rows, argv[0]))
            return JS_EXCEPTION;
        rows = (int)_rows;
        auto __arg0 = rows;

        int cols;
        int32_t _cols;
        if (JS_ToInt32(ctx, &_cols, argv[1]))
            return JS_EXCEPTION;
        cols = (int)_cols;
        auto __arg1 = cols;

        int vgap;
        int32_t _vgap;
        if (JS_ToInt32(ctx, &_vgap, argv[2]))
            return JS_EXCEPTION;
        vgap = (int)_vgap;
        auto __arg2 = vgap;

        int hgap;
        int32_t _hgap;
        if (JS_ToInt32(ctx, &_hgap, argv[3]))
            return JS_EXCEPTION;
        hgap = (int)_hgap;
        auto __arg3 = hgap;

        instance = new Ozone::FlexGridSizer(__arg0, __arg1, __arg2, __arg3);

        goto wrap;
    }

    // FlexGridSizer(int rows, int cols, const ::Ozone::Size& gap)
overload3:
    {
        int rows;
        int32_t _rows;
        if (JS_ToInt32(ctx, &_rows, argv[0]))
            return JS_EXCEPTION;
        rows = (int)_rows;
        auto __arg0 = rows;

        int cols;
        int32_t _cols;
        if (JS_ToInt32(ctx, &_cols, argv[1]))
            return JS_EXCEPTION;
        cols = (int)_cols;
        auto __arg1 = cols;

        Ozone::Size* gap_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[2], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg2 = *gap_instance;

        instance = new Ozone::FlexGridSizer(__arg0, __arg1, __arg2);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_FlexGridSizer);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_FlexGridSizer);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::FlexGridSizer::AddGrowableRow
static JSValue callback_method_Ozone_FlexGridSizer_AddGrowableRow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddGrowableRow(unsigned long idx, int proportion)
overload0:
    {
        unsigned long idx;
        uint32_t _idx;
        if (JS_ToUint32(ctx, &_idx, argv[0]))
            return JS_EXCEPTION;
        idx = (unsigned long)_idx;
        auto __arg0 = idx;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[1]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg1 = proportion;

        instance->AddGrowableRow(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::FlexGridSizer::RemoveGrowableRow
static JSValue callback_method_Ozone_FlexGridSizer_RemoveGrowableRow(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void RemoveGrowableRow(unsigned long idx)
overload0:
    {
        unsigned long idx;
        uint32_t _idx;
        if (JS_ToUint32(ctx, &_idx, argv[0]))
            return JS_EXCEPTION;
        idx = (unsigned long)_idx;
        auto __arg0 = idx;

        instance->RemoveGrowableRow(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::FlexGridSizer::AddGrowableCol
static JSValue callback_method_Ozone_FlexGridSizer_AddGrowableCol(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 2 || argc > 2)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void AddGrowableCol(unsigned long idx, int proportion)
overload0:
    {
        unsigned long idx;
        uint32_t _idx;
        if (JS_ToUint32(ctx, &_idx, argv[0]))
            return JS_EXCEPTION;
        idx = (unsigned long)_idx;
        auto __arg0 = idx;

        int proportion;
        int32_t _proportion;
        if (JS_ToInt32(ctx, &_proportion, argv[1]))
            return JS_EXCEPTION;
        proportion = (int)_proportion;
        auto __arg1 = proportion;

        instance->AddGrowableCol(__arg0, __arg1);

        return JS_UNDEFINED;
    }
}

// Ozone::FlexGridSizer::RemoveGrowableCol
static JSValue callback_method_Ozone_FlexGridSizer_RemoveGrowableCol(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void RemoveGrowableCol(unsigned long idx)
overload0:
    {
        unsigned long idx;
        uint32_t _idx;
        if (JS_ToUint32(ctx, &_idx, argv[0]))
            return JS_EXCEPTION;
        idx = (unsigned long)_idx;
        auto __arg0 = idx;

        instance->RemoveGrowableCol(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::FlexGridSizer::IsRowGrowable
static JSValue callback_method_Ozone_FlexGridSizer_IsRowGrowable(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool IsRowGrowable(unsigned long idx)
overload0:
    {
        unsigned long idx;
        uint32_t _idx;
        if (JS_ToUint32(ctx, &_idx, argv[0]))
            return JS_EXCEPTION;
        idx = (unsigned long)_idx;
        auto __arg0 = idx;

        bool __ret = instance->IsRowGrowable(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::FlexGridSizer::IsColGrowable
static JSValue callback_method_Ozone_FlexGridSizer_IsColGrowable(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool IsColGrowable(unsigned long idx)
overload0:
    {
        unsigned long idx;
        uint32_t _idx;
        if (JS_ToUint32(ctx, &_idx, argv[0]))
            return JS_EXCEPTION;
        idx = (unsigned long)_idx;
        auto __arg0 = idx;

        bool __ret = instance->IsColGrowable(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

// Ozone::FlexGridSizer::SetFlexibleDirection
static JSValue callback_method_Ozone_FlexGridSizer_SetFlexibleDirection(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetFlexibleDirection(int direction)
overload0:
    {
        int direction;
        int32_t _direction;
        if (JS_ToInt32(ctx, &_direction, argv[0]))
            return JS_EXCEPTION;
        direction = (int)_direction;
        auto __arg0 = direction;

        instance->SetFlexibleDirection(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::FlexGridSizer::GetFlexibleDirection
static JSValue callback_method_Ozone_FlexGridSizer_GetFlexibleDirection(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    int __ret = instance->GetFlexibleDirection();

    JSValue ____ret = JS_NewInt32(ctx, __ret);

    return ____ret;
}

// Ozone::FlexGridSizer::SetNonFlexibleGrowMode
static JSValue callback_method_Ozone_FlexGridSizer_SetNonFlexibleGrowMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetNonFlexibleGrowMode(::Ozone::FlexSizerGrowMode mode)
overload0:
    {
        unsigned int mode;
        uint32_t _mode;
        if (JS_ToUint32(ctx, &_mode, argv[0]))
            return JS_EXCEPTION;
        mode = (unsigned int)_mode;
        auto __arg0 = (::Ozone::FlexSizerGrowMode)mode;

        instance->SetNonFlexibleGrowMode(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::FlexGridSizer::GetNonFlexibleGrowMode
static JSValue callback_method_Ozone_FlexGridSizer_GetNonFlexibleGrowMode(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    ::Ozone::FlexSizerGrowMode __ret = instance->GetNonFlexibleGrowMode();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::FlexGridSizer::RepositionChildren
static JSValue callback_method_Ozone_FlexGridSizer_RepositionChildren(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void RepositionChildren(const ::Ozone::Size& minSize) override
overload0:
    {
        Ozone::Size* minSize_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *minSize_instance;

        instance->RepositionChildren(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::FlexGridSizer::CalcMin
static JSValue callback_method_Ozone_FlexGridSizer_CalcMin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->CalcMin();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

static JSValue callback_class_Ozone_FlexGridSizer_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "FlexGridSizer");
}

void finalizer_Ozone_FlexGridSizer(JSRuntime *rt, JSValue val)
{
    Ozone::FlexGridSizer* instance = (Ozone::FlexGridSizer*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_FlexGridSizer
{
    "FlexGridSizer",
    .finalizer = finalizer_Ozone_FlexGridSizer
};

static JSCFunctionListEntry funcDef_Ozone_FlexGridSizer[]
{
    JS_CFUNC_DEF("AddGrowableRow", 2, callback_method_Ozone_FlexGridSizer_AddGrowableRow),
    JS_CFUNC_DEF("RemoveGrowableRow", 1, callback_method_Ozone_FlexGridSizer_RemoveGrowableRow),
    JS_CFUNC_DEF("AddGrowableCol", 2, callback_method_Ozone_FlexGridSizer_AddGrowableCol),
    JS_CFUNC_DEF("RemoveGrowableCol", 1, callback_method_Ozone_FlexGridSizer_RemoveGrowableCol),
    JS_CFUNC_DEF("IsRowGrowable", 1, callback_method_Ozone_FlexGridSizer_IsRowGrowable),
    JS_CFUNC_DEF("IsColGrowable", 1, callback_method_Ozone_FlexGridSizer_IsColGrowable),
    JS_CFUNC_DEF("SetFlexibleDirection", 1, callback_method_Ozone_FlexGridSizer_SetFlexibleDirection),
    JS_CFUNC_DEF("GetFlexibleDirection", 0, callback_method_Ozone_FlexGridSizer_GetFlexibleDirection),
    JS_CFUNC_DEF("SetNonFlexibleGrowMode", 1, callback_method_Ozone_FlexGridSizer_SetNonFlexibleGrowMode),
    JS_CFUNC_DEF("GetNonFlexibleGrowMode", 0, callback_method_Ozone_FlexGridSizer_GetNonFlexibleGrowMode),
    JS_CFUNC_DEF("RepositionChildren", 1, callback_method_Ozone_FlexGridSizer_RepositionChildren),
    JS_CFUNC_DEF("CalcMin", 0, callback_method_Ozone_FlexGridSizer_CalcMin),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_FlexGridSizer_toString),
};

static void register_class_Ozone_FlexGridSizer(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "FlexGridSizer");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_FlexGridSizer);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_FlexGridSizer, &classDef_Ozone_FlexGridSizer);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_FlexGridSizer, sizeof(funcDef_Ozone_FlexGridSizer) / sizeof(funcDef_Ozone_FlexGridSizer[0]));
        JS_SetClassProto(ctx, classId_Ozone_FlexGridSizer, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_FlexGridSizer_FlexGridSizer, "FlexGridSizer", 4, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "FlexGridSizer", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_FlexGridSizer);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_GridSizer);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_BoxSizer;

// Ozone::BoxSizer::BoxSizer
static JSValue callback_method_Ozone_BoxSizer_BoxSizer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::BoxSizer* instance;

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // BoxSizer(::Ozone::SizerOrientation orient)
overload0:
    {
        unsigned int orient;
        uint32_t _orient;
        if (JS_ToUint32(ctx, &_orient, argv[0]))
            return JS_EXCEPTION;
        orient = (unsigned int)_orient;
        auto __arg0 = (::Ozone::SizerOrientation)orient;

        instance = new Ozone::BoxSizer(__arg0);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_BoxSizer);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_BoxSizer);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::BoxSizer::AddSpacer
static JSValue callback_method_Ozone_BoxSizer_AddSpacer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::BoxSizer* instance = (Ozone::BoxSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // ::Ozone::SizerItem* AddSpacer(int size) override
overload0:
    {
        int size;
        int32_t _size;
        if (JS_ToInt32(ctx, &_size, argv[0]))
            return JS_EXCEPTION;
        size = (int)_size;
        auto __arg0 = size;

        ::Ozone::SizerItem* __ret = instance->AddSpacer(__arg0);

        JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_SizerItem, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) __ret);

        return ____ret;
    }
}

// Ozone::BoxSizer::GetOrientation
static JSValue callback_method_Ozone_BoxSizer_GetOrientation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::BoxSizer* instance = (Ozone::BoxSizer*) JS_GetOpaque(this_val, 0);

    ::Ozone::SizerOrientation __ret = instance->GetOrientation();

    JSValue ____ret = JS_NewInt32(ctx, (int32_t) __ret);

    return ____ret;
}

// Ozone::BoxSizer::IsVertical
static JSValue callback_method_Ozone_BoxSizer_IsVertical(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::BoxSizer* instance = (Ozone::BoxSizer*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->IsVertical();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::BoxSizer::SetOrientation
static JSValue callback_method_Ozone_BoxSizer_SetOrientation(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::BoxSizer* instance = (Ozone::BoxSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void SetOrientation(::Ozone::SizerOrientation orient)
overload0:
    {
        unsigned int orient;
        uint32_t _orient;
        if (JS_ToUint32(ctx, &_orient, argv[0]))
            return JS_EXCEPTION;
        orient = (unsigned int)_orient;
        auto __arg0 = (::Ozone::SizerOrientation)orient;

        instance->SetOrientation(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::BoxSizer::CalcMin
static JSValue callback_method_Ozone_BoxSizer_CalcMin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::BoxSizer* instance = (Ozone::BoxSizer*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->CalcMin();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::BoxSizer::RepositionChildren
static JSValue callback_method_Ozone_BoxSizer_RepositionChildren(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::BoxSizer* instance = (Ozone::BoxSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void RepositionChildren(const ::Ozone::Size& minSize) override
overload0:
    {
        Ozone::Size* minSize_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *minSize_instance;

        instance->RepositionChildren(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::BoxSizer::InformFirstDirection
static JSValue callback_method_Ozone_BoxSizer_InformFirstDirection(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::BoxSizer* instance = (Ozone::BoxSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsNumber(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsNumber(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool InformFirstDirection(int direction, int size, int availableOtherDir) override
overload0:
    {
        int direction;
        int32_t _direction;
        if (JS_ToInt32(ctx, &_direction, argv[0]))
            return JS_EXCEPTION;
        direction = (int)_direction;
        auto __arg0 = direction;

        int size;
        int32_t _size;
        if (JS_ToInt32(ctx, &_size, argv[1]))
            return JS_EXCEPTION;
        size = (int)_size;
        auto __arg1 = size;

        int availableOtherDir;
        int32_t _availableOtherDir;
        if (JS_ToInt32(ctx, &_availableOtherDir, argv[2]))
            return JS_EXCEPTION;
        availableOtherDir = (int)_availableOtherDir;
        auto __arg2 = availableOtherDir;

        bool __ret = instance->InformFirstDirection(__arg0, __arg1, __arg2);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

static JSValue callback_class_Ozone_BoxSizer_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "BoxSizer");
}

void finalizer_Ozone_BoxSizer(JSRuntime *rt, JSValue val)
{
    Ozone::BoxSizer* instance = (Ozone::BoxSizer*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_BoxSizer
{
    "BoxSizer",
    .finalizer = finalizer_Ozone_BoxSizer
};

static JSCFunctionListEntry funcDef_Ozone_BoxSizer[]
{
    JS_CFUNC_DEF("AddSpacer", 1, callback_method_Ozone_BoxSizer_AddSpacer),
    JS_CFUNC_DEF("GetOrientation", 0, callback_method_Ozone_BoxSizer_GetOrientation),
    JS_CFUNC_DEF("IsVertical", 0, callback_method_Ozone_BoxSizer_IsVertical),
    JS_CFUNC_DEF("SetOrientation", 1, callback_method_Ozone_BoxSizer_SetOrientation),
    JS_CFUNC_DEF("CalcMin", 0, callback_method_Ozone_BoxSizer_CalcMin),
    JS_CFUNC_DEF("RepositionChildren", 1, callback_method_Ozone_BoxSizer_RepositionChildren),
    JS_CFUNC_DEF("InformFirstDirection", 3, callback_method_Ozone_BoxSizer_InformFirstDirection),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_BoxSizer_toString),
};

static void register_class_Ozone_BoxSizer(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "BoxSizer");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_BoxSizer);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_BoxSizer, &classDef_Ozone_BoxSizer);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_BoxSizer, sizeof(funcDef_Ozone_BoxSizer) / sizeof(funcDef_Ozone_BoxSizer[0]));
        JS_SetClassProto(ctx, classId_Ozone_BoxSizer, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_BoxSizer_BoxSizer, "BoxSizer", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "BoxSizer", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_BoxSizer);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_Sizer);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_StaticBoxSizer;

// Ozone::StaticBoxSizer::StaticBoxSizer
static JSValue callback_method_Ozone_StaticBoxSizer_StaticBoxSizer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 3 || argc > 3)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::StaticBoxSizer* instance;

    if (JS_IsNumber(argv[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (JS_IsObject(argv[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (JS_IsString(argv[2]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // StaticBoxSizer(::Ozone::SizerOrientation orient, ::Ozone::Window* win, const char* label)
overload0:
    {
        unsigned int orient;
        uint32_t _orient;
        if (JS_ToUint32(ctx, &_orient, argv[0]))
            return JS_EXCEPTION;
        orient = (unsigned int)_orient;
        auto __arg0 = (::Ozone::SizerOrientation)orient;

        Ozone::Window* win_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[1], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg1 = win_instance;

        const char* label;
        label = JS_ToCString(ctx, argv[2]);
        if (!label)
            return JS_EXCEPTION;
        auto __arg2 = label;

        instance = new Ozone::StaticBoxSizer(__arg0, __arg1, __arg2);

        JS_FreeCString(ctx, label);
        goto wrap;
    }

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_StaticBoxSizer);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_StaticBoxSizer);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::StaticBoxSizer::CalcMin
static JSValue callback_method_Ozone_StaticBoxSizer_CalcMin(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::StaticBoxSizer* instance = (Ozone::StaticBoxSizer*) JS_GetOpaque(this_val, 0);

    ::Ozone::Size __ret = instance->CalcMin();

    JSValue ____ret = JS_Interop_CreateFromInstance(ctx, classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER, (void*) &__ret);

    return ____ret;
}

// Ozone::StaticBoxSizer::RepositionChildren
static JSValue callback_method_Ozone_StaticBoxSizer_RepositionChildren(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::StaticBoxSizer* instance = (Ozone::StaticBoxSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void RepositionChildren(const ::Ozone::Size& minSize) override
overload0:
    {
        Ozone::Size* minSize_instance = (Ozone::Size*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Size, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto &__arg0 = *minSize_instance;

        instance->RepositionChildren(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::StaticBoxSizer::ShowItems
static JSValue callback_method_Ozone_StaticBoxSizer_ShowItems(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::StaticBoxSizer* instance = (Ozone::StaticBoxSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsBool(argv[0]))
        goto overload0;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // void ShowItems(bool show) override
overload0:
    {
        bool show;
        show = JS_ToBool(ctx, argv[0]);
        if (show == -1)
            return JS_EXCEPTION;
        auto __arg0 = show;

        instance->ShowItems(__arg0);

        return JS_UNDEFINED;
    }
}

// Ozone::StaticBoxSizer::AreAnyItemsShown
static JSValue callback_method_Ozone_StaticBoxSizer_AreAnyItemsShown(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::StaticBoxSizer* instance = (Ozone::StaticBoxSizer*) JS_GetOpaque(this_val, 0);

    bool __ret = instance->AreAnyItemsShown();

    JSValue ____ret = JS_NewBool(ctx, __ret);

    return ____ret;
}

// Ozone::StaticBoxSizer::Detach
static JSValue callback_method_Ozone_StaticBoxSizer_Detach(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc < 1 || argc > 1)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::StaticBoxSizer* instance = (Ozone::StaticBoxSizer*) JS_GetOpaque(this_val, 0);

    if (JS_IsObject(argv[0]))
        goto overload0;

    if (JS_IsObject(argv[0]))
        goto overload1;

    if (JS_IsNumber(argv[0]))
        goto overload2;

    goto error;

error:
    return JS_ThrowTypeError(ctx, "Unsupported argument type");

    // bool Detach(::Ozone::Window* window) override
overload0:
    {
        Ozone::Window* window_instance = (Ozone::Window*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Window, JS_INTEROP_INSTANCE_SIGNAL_CONTEXT);
        auto __arg0 = window_instance;

        bool __ret = instance->Detach(__arg0);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Detach(::Ozone::Sizer* sizer) override
overload1:
    {
        Ozone::Sizer* sizer_instance = (Ozone::Sizer*) JS_Interop_GetInstance( argv[0], \
            classId_Ozone_Sizer, JS_INTEROP_INSTANCE_RAW_POINTER);
        auto __arg0 = sizer_instance;

        bool __ret = instance->Detach(__arg0);


        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }

    // bool Detach(int index) override
overload2:
    {
        int index;
        int32_t _index;
        if (JS_ToInt32(ctx, &_index, argv[0]))
            return JS_EXCEPTION;
        index = (int)_index;
        auto __arg0 = index;

        bool __ret = instance->Detach(__arg0);

        JSValue ____ret = JS_NewBool(ctx, __ret);

        return ____ret;
    }
}

static JSValue callback_class_Ozone_StaticBoxSizer_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "StaticBoxSizer");
}

void finalizer_Ozone_StaticBoxSizer(JSRuntime *rt, JSValue val)
{
    Ozone::StaticBoxSizer* instance = (Ozone::StaticBoxSizer*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_StaticBoxSizer
{
    "StaticBoxSizer",
    .finalizer = finalizer_Ozone_StaticBoxSizer
};

static JSCFunctionListEntry funcDef_Ozone_StaticBoxSizer[]
{
    JS_CFUNC_DEF("CalcMin", 0, callback_method_Ozone_StaticBoxSizer_CalcMin),
    JS_CFUNC_DEF("RepositionChildren", 1, callback_method_Ozone_StaticBoxSizer_RepositionChildren),
    JS_CFUNC_DEF("ShowItems", 1, callback_method_Ozone_StaticBoxSizer_ShowItems),
    JS_CFUNC_DEF("AreAnyItemsShown", 0, callback_method_Ozone_StaticBoxSizer_AreAnyItemsShown),
    JS_CFUNC_DEF("Detach", 1, callback_method_Ozone_StaticBoxSizer_Detach),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_StaticBoxSizer_toString),
};

static void register_class_Ozone_StaticBoxSizer(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "StaticBoxSizer");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_StaticBoxSizer);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_StaticBoxSizer, &classDef_Ozone_StaticBoxSizer);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_StaticBoxSizer, sizeof(funcDef_Ozone_StaticBoxSizer) / sizeof(funcDef_Ozone_StaticBoxSizer[0]));
        JS_SetClassProto(ctx, classId_Ozone_StaticBoxSizer, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_StaticBoxSizer_StaticBoxSizer, "StaticBoxSizer", 3, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "StaticBoxSizer", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_StaticBoxSizer);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_BoxSizer);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

JSClassID classId_Ozone_StdDialogButtonSizer;

// Ozone::StdDialogButtonSizer::StdDialogButtonSizer
static JSValue callback_method_Ozone_StdDialogButtonSizer_StdDialogButtonSizer(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::StdDialogButtonSizer* instance;

    instance = new Ozone::StdDialogButtonSizer();
    goto wrap;

wrap:
    JSValue proto;
    if (JS_IsUndefined(this_val))
        proto = JS_GetClassProto(ctx, classId_Ozone_StdDialogButtonSizer);
    else
        proto = JS_GetProperty(ctx, this_val, JS_ATOM_prototype);

    if (JS_IsException(proto))
        return proto;

    JSValue __obj = JS_NewObjectProtoClass(ctx, proto, classId_Ozone_StdDialogButtonSizer);
    JS_FreeValue(ctx, proto);

    JS_Interop_InitObject(ctx, __obj, JS_INTEROP_INSTANCE_RAW_POINTER, instance);
    JSObject* __js_obj = JS_VALUE_GET_OBJ(__obj);
    instance->__ExternalInstance = (void*) __js_obj;


    return __obj;
}

// Ozone::StdDialogButtonSizer::Realize
static JSValue callback_method_Ozone_StdDialogButtonSizer_Realize(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    if (argc > 0)
    {
        return JS_ThrowRangeError(ctx, "Unsupported number of arguments");
    }

    Ozone::StdDialogButtonSizer* instance = (Ozone::StdDialogButtonSizer*) JS_GetOpaque(this_val, 0);

    instance->Realize();

    return JS_UNDEFINED;
}

static JSValue callback_class_Ozone_StdDialogButtonSizer_toString(JSContext* ctx, JSValueConst this_val,
    int argc, JSValueConst* argv)
{
    return JS_NewString(ctx, "StdDialogButtonSizer");
}

void finalizer_Ozone_StdDialogButtonSizer(JSRuntime *rt, JSValue val)
{
    Ozone::StdDialogButtonSizer* instance = (Ozone::StdDialogButtonSizer*) JS_GetOpaque(val, 0);
}

static JSClassDef classDef_Ozone_StdDialogButtonSizer
{
    "StdDialogButtonSizer",
    .finalizer = finalizer_Ozone_StdDialogButtonSizer
};

static JSCFunctionListEntry funcDef_Ozone_StdDialogButtonSizer[]
{
    JS_CFUNC_DEF("Realize", 0, callback_method_Ozone_StdDialogButtonSizer_Realize),
    JS_CFUNC_DEF("toString", 0, callback_class_Ozone_StdDialogButtonSizer_toString),
};

static void register_class_Ozone_StdDialogButtonSizer(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (!set)
    {
        JS_AddModuleExport(ctx, m, "StdDialogButtonSizer");
        return;
    }

    if (phase == 0)
    {
        JS_NewClassID(&classId_Ozone_StdDialogButtonSizer);

        JS_NewClass(JS_GetRuntime(ctx), classId_Ozone_StdDialogButtonSizer, &classDef_Ozone_StdDialogButtonSizer);

        JSValue proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, funcDef_Ozone_StdDialogButtonSizer, sizeof(funcDef_Ozone_StdDialogButtonSizer) / sizeof(funcDef_Ozone_StdDialogButtonSizer[0]));
        JS_SetClassProto(ctx, classId_Ozone_StdDialogButtonSizer, proto);

        JSValue ctor = JS_NewCFunction2(ctx, callback_method_Ozone_StdDialogButtonSizer_StdDialogButtonSizer, "StdDialogButtonSizer", 1, JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, ctor, proto);

        JS_SetModuleExport(ctx, m, "StdDialogButtonSizer", ctor);
    }
    else if (phase == 1)
    {
        JSValue proto = JS_GetClassProto(ctx, classId_Ozone_StdDialogButtonSizer);
        JSValue baseProto = JS_GetClassProto(ctx, classId_Ozone_BoxSizer);
        int err = JS_SetPrototype(ctx, proto, baseProto);
        assert(err != -1);
        JS_FreeValue(ctx, baseProto);
        JS_FreeValue(ctx, proto);
    }
}

void register_ozone_sizer(JSContext *ctx, JSModuleDef *m, bool set, int phase)
{
    if (phase == 0)
    {
        register_enum_Ozone_FlexSizerGrowMode(ctx, m, set);
    }

    register_class_Ozone_SizerFlags(ctx, m, set, phase);

    register_class_Ozone_SizerSpacer(ctx, m, set, phase);

    register_class_Ozone_SizerItem(ctx, m, set, phase);

    register_class_Ozone_SizerItemList(ctx, m, set, phase);

    register_class_Ozone_Sizer(ctx, m, set, phase);

    register_class_Ozone_GridSizer(ctx, m, set, phase);

    register_class_Ozone_FlexGridSizer(ctx, m, set, phase);

    register_class_Ozone_BoxSizer(ctx, m, set, phase);

    register_class_Ozone_StaticBoxSizer(ctx, m, set, phase);

    register_class_Ozone_StdDialogButtonSizer(ctx, m, set, phase);
}

} // extern "C"
