//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace wxSharp
{
    [Flags]
    public enum WX_ANY_VALUE_BUFFER_SIZE : uint
    {
        WX_ANY_VALUE_BUFFER_SIZE = 16
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int wxSortFuncFor_wxAnyList(global::System.IntPtr _0, global::System.IntPtr _1);

    /// <summary>
    /// <para>    Intermediate template for the generic value type implementation.</para>
    /// </summary>
    /// <remarks>
    /// <para>    We can derive from this same value type for multiple actual types</para>
    /// <para>    (for instance, we can have wxAnyValueTypeImplInt for all signed</para>
    /// <para>    integer types), and also easily implement specialized templates</para>
    /// <para>    with specific dynamic type conversion.</para>
    /// </remarks>
    public unsafe partial class wxAnyValueTypeImplBase
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct Internal
        {
        }
    }

    public unsafe partial class wxAnyValueTypeImpl
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct Internal
        {
        }
    }

    public unsafe partial struct wxAnyValueBuffer
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public wxAnyValueBuffer.Alignment.Internal m_alignment;

            [FieldOffset(0)]
            public global::System.IntPtr m_ptr;

            [FieldOffset(0)]
            public fixed byte m_buffer[16];

            [FieldOffset(1)]
            public byte __dummy_m_buffer_1;

            [FieldOffset(2)]
            public byte __dummy_m_buffer_2;

            [FieldOffset(3)]
            public byte __dummy_m_buffer_3;

            [FieldOffset(4)]
            public byte __dummy_m_buffer_4;

            [FieldOffset(5)]
            public byte __dummy_m_buffer_5;

            [FieldOffset(6)]
            public byte __dummy_m_buffer_6;

            [FieldOffset(7)]
            public byte __dummy_m_buffer_7;

            [FieldOffset(8)]
            public byte __dummy_m_buffer_8;

            [FieldOffset(9)]
            public byte __dummy_m_buffer_9;

            [FieldOffset(10)]
            public byte __dummy_m_buffer_10;

            [FieldOffset(11)]
            public byte __dummy_m_buffer_11;

            [FieldOffset(12)]
            public byte __dummy_m_buffer_12;

            [FieldOffset(13)]
            public byte __dummy_m_buffer_13;

            [FieldOffset(14)]
            public byte __dummy_m_buffer_14;

            [FieldOffset(15)]
            public byte __dummy_m_buffer_15;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxAnyValueBufferC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public unsafe partial struct Alignment
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public long m_int64;

                [FieldOffset(0)]
                public void* m_longDouble;

                [FieldOffset(0)]
                public global::System.IntPtr m_funcPtr;

                [FieldOffset(0)]
                public global::System.IntPtr m_mFuncPtr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxAnyValueBuffer9AlignmentC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            private Alignment.Internal __instance;
            public Alignment.Internal __Instance { get { return __instance; } }

            public static Alignment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Alignment(native.ToPointer(), skipVTables);
            }

            public static Alignment __CreateInstance(Alignment.Internal native, bool skipVTables = false)
            {
                return new Alignment(native, skipVTables);
            }

            private Alignment(Alignment.Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Alignment(void* native, bool skipVTables = false) : this()
            {
                __instance = *(Internal*) native;
            }

            public Alignment(wxAnyValueBuffer.Alignment _0)
                : this()
            {
                var __arg0 = _0.__Instance;
                var arg0 = new global::System.IntPtr(&__arg0);
                fixed (Internal* __instancePtr = &__instance)
                {
                    Internal.cctor_1(new global::System.IntPtr(__instancePtr), arg0);
                }
            }

            public long m_int64
            {
                get
                {
                    return __instance.m_int64;
                }

                set
                {
                    __instance.m_int64 = value;
                }
            }

            public void* m_longDouble
            {
                get
                {
                    return __instance.m_longDouble;
                }

                set
                {
                    __instance.m_longDouble = value;
                }
            }

            public Action m_funcPtr
            {
                get
                {
                    var __ptr0 = __instance.m_funcPtr;
                    return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
                }

                set
                {
                    __instance.m_funcPtr = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
                }
            }
        }

        private wxAnyValueBuffer.Internal __instance;
        public wxAnyValueBuffer.Internal __Instance { get { return __instance; } }

        public static wxAnyValueBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAnyValueBuffer(native.ToPointer(), skipVTables);
        }

        public static wxAnyValueBuffer __CreateInstance(wxAnyValueBuffer.Internal native, bool skipVTables = false)
        {
            return new wxAnyValueBuffer(native, skipVTables);
        }

        private wxAnyValueBuffer(wxAnyValueBuffer.Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private wxAnyValueBuffer(void* native, bool skipVTables = false) : this()
        {
            __instance = *(Internal*) native;
        }

        public wxAnyValueBuffer(wxAnyValueBuffer _0)
            : this()
        {
            var __arg0 = _0.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            fixed (Internal* __instancePtr = &__instance)
            {
                Internal.cctor_1(new global::System.IntPtr(__instancePtr), arg0);
            }
        }

        public wxAnyValueBuffer.Alignment m_alignment;

        public global::System.IntPtr m_ptr
        {
            get
            {
                return __instance.m_ptr;
            }

            set
            {
                __instance.m_ptr = value;
            }
        }

        public byte[] m_buffer
        {
            get
            {
                fixed (byte* __arrPtr = __instance.m_buffer)
                {
                    byte[] __value = null;
                    if (__arrPtr != null)
                    {
                        __value = new byte[16];
                        for (int i = 0; i < 16; i++)
                            __value[i] = __arrPtr[i];
                    }
                    return __value;
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.m_buffer)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 16; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    public unsafe abstract partial class wxAnyValueType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14wxAnyValueTypeC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14wxAnyValueTypeC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14wxAnyValueTypeD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueType> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxAnyValueType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAnyValueTypeInternal(native.ToPointer(), skipVTables);
        }

        public static wxAnyValueType __CreateInstance(wxAnyValueType.Internal native, bool skipVTables = false)
        {
            return new wxAnyValueTypeInternal(native, skipVTables);
        }

        protected wxAnyValueType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        /// <summary>
        /// <para>        Default constructor.</para>
        /// </summary>
        /// 
        protected wxAnyValueType()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueType");
        }

        protected wxAnyValueType(wxAnyValueType _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueType");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxAnyValueType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            if (__slot != null)
            {
                var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
                ___dtor_0Delegate((__Instance + __PointerAdjustment));
            }
            else
                Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        /// <summary>
        /// <para>        This function is used for internal type matching.</para>
        /// </summary>
        /// 
        public abstract bool IsSameType(wxAnyValueType otherType);

        /// <summary>
        /// <para>        This function is called every time the data in wxAny</para>
        /// </summary>
        /// <remarks>
        /// <para>        buffer needs to be freed.</para>
        /// </remarks>
        public abstract void DeleteValue(wxAnyValueBuffer buf);

        /// <summary>
        /// <para>        Implement this for buffer-to-buffer copy.</para>
        /// </summary>
        /// <remarks>
        /// <para>        </para>
        /// <para>        </para>
        /// </remarks>
        public abstract void CopyBuffer(wxAnyValueBuffer src, wxAnyValueBuffer dst);

        /// <summary>
        /// <para>        Convert value into buffer of different type. Return false if</para>
        /// </summary>
        /// <remarks>
        /// <para>        not possible.</para>
        /// </remarks>
        public abstract bool ConvertValue(wxAnyValueBuffer src, wxAnyValueType dstType, wxAnyValueBuffer dst);

        #region Virtual table interop

        // virtual ~wxAnyValueType()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueType) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // bool IsSameType(const wxAnyValueType* otherType) const = 0
        private static Delegates.Func_bool_IntPtr_IntPtr _IsSameType_0DelegateInstance;

        private static bool _IsSameType_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr otherType)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueType) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueType __result0;
            if (otherType == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(otherType))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[otherType];
            else __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(otherType, skipVTables: true);
            var __ret = __target.IsSameType(__result0);
            return __ret;
        }

        // void DeleteValue(wxAnyValueBuffer& buf) const = 0
        private static Delegates.Action_IntPtr_IntPtr _DeleteValue_0DelegateInstance;

        private static void _DeleteValue_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr buf)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueType) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueBuffer __result0;
            if (buf == IntPtr.Zero) __result0 = new wxAnyValueBuffer();
            else __result0 = wxAnyValueBuffer.__CreateInstance(buf);
            __target.DeleteValue(__result0);
        }

        // void CopyBuffer(const wxAnyValueBuffer& src, wxAnyValueBuffer& dst) const = 0
        private static Delegates.Action_IntPtr_IntPtr_IntPtr _CopyBuffer_0DelegateInstance;

        private static void _CopyBuffer_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr src, global::System.IntPtr dst)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueType) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueBuffer __result0;
            if (src == IntPtr.Zero) __result0 = new wxAnyValueBuffer();
            else __result0 = wxAnyValueBuffer.__CreateInstance(src);
            wxAnyValueBuffer __result1;
            if (dst == IntPtr.Zero) __result1 = new wxAnyValueBuffer();
            else __result1 = wxAnyValueBuffer.__CreateInstance(dst);
            __target.CopyBuffer(__result0, __result1);
        }

        // bool ConvertValue(const wxAnyValueBuffer& src, wxAnyValueType* dstType, wxAnyValueBuffer& dst) const = 0
        private static Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr _ConvertValue_0DelegateInstance;

        private static bool _ConvertValue_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr src, global::System.IntPtr dstType, global::System.IntPtr dst)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueType) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueBuffer __result0;
            if (src == IntPtr.Zero) __result0 = new wxAnyValueBuffer();
            else __result0 = wxAnyValueBuffer.__CreateInstance(src);
            wxAnyValueType __result1;
            if (dstType == IntPtr.Zero) __result1 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(dstType))
                __result1 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[dstType];
            else __result1 = (wxAnyValueType) wxAnyValueType.__CreateInstance(dstType, skipVTables: true);
            wxAnyValueBuffer __result2;
            if (dst == IntPtr.Zero) __result2 = new wxAnyValueBuffer();
            else __result2 = wxAnyValueBuffer.__CreateInstance(dst);
            var __ret = __target.ConvertValue(__result0, __result1, __result2);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _IsSameType_0DelegateInstance += _IsSameType_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsSameType_0DelegateInstance).ToPointer();
                _DeleteValue_0DelegateInstance += _DeleteValue_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DeleteValue_0DelegateInstance).ToPointer();
                _CopyBuffer_0DelegateInstance += _CopyBuffer_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_CopyBuffer_0DelegateInstance).ToPointer();
                _ConvertValue_0DelegateInstance += _ConvertValue_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ConvertValue_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxAnyValueTypeScopedPtr : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr m_ptr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN23wxAnyValueTypeScopedPtrC2EP14wxAnyValueType")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN23wxAnyValueTypeScopedPtrC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN23wxAnyValueTypeScopedPtrD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK23wxAnyValueTypeScopedPtr3getEv")]
            internal static extern global::System.IntPtr get_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeScopedPtr> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeScopedPtr>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxAnyValueTypeScopedPtr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAnyValueTypeScopedPtr(native.ToPointer(), skipVTables);
        }

        public static wxAnyValueTypeScopedPtr __CreateInstance(wxAnyValueTypeScopedPtr.Internal native, bool skipVTables = false)
        {
            return new wxAnyValueTypeScopedPtr(native, skipVTables);
        }

        private static void* __CopyValue(wxAnyValueTypeScopedPtr.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            *(wxAnyValueTypeScopedPtr.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxAnyValueTypeScopedPtr(wxAnyValueTypeScopedPtr.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxAnyValueTypeScopedPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxAnyValueTypeScopedPtr(wxAnyValueType ptr)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = ReferenceEquals(ptr, null) ? global::System.IntPtr.Zero : ptr.__Instance;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
        }

        public wxAnyValueTypeScopedPtr(wxAnyValueTypeScopedPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((wxAnyValueTypeScopedPtr.Internal*) __Instance) = *((wxAnyValueTypeScopedPtr.Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxAnyValueTypeScopedPtr __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public wxAnyValueType get()
        {
            var __ret = Internal.get_0((__Instance + __PointerAdjustment));
            wxAnyValueType __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[__ret];
            else wxAnyValueType.NativeToManagedMap[__ret] = __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(__ret);
            return __result0;
        }
    }

    public unsafe partial class wxAnyValueTypeImplInt : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN21wxAnyValueTypeImplIntC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN21wxAnyValueTypeImplIntC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN21wxAnyValueTypeImplInt11IsSameClassEPK14wxAnyValueType")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSameClass_0(global::System.IntPtr otherType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN21wxAnyValueTypeImplInt11GetInstanceEv")]
            internal static extern global::System.IntPtr GetInstance_0();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplInt> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplInt>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxAnyValueTypeImplInt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplInt(native.ToPointer(), skipVTables);
        }

        public static wxAnyValueTypeImplInt __CreateInstance(wxAnyValueTypeImplInt.Internal native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplInt(native, skipVTables);
        }

        private static void* __CopyValue(wxAnyValueTypeImplInt.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            wxAnyValueTypeImplInt.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxAnyValueTypeImplInt(wxAnyValueTypeImplInt.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxAnyValueTypeImplInt(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxAnyValueTypeImplInt()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplInt");
        }

        public wxAnyValueTypeImplInt(wxAnyValueTypeImplInt _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplInt");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxAnyValueTypeImplInt __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___dtor_0Delegate((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public override bool IsSameType(wxAnyValueType otherType)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___IsSameType_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = ___IsSameType_0Delegate((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public override bool ConvertValue(wxAnyValueBuffer src, wxAnyValueType dstType, wxAnyValueBuffer dst)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
            var ___ConvertValue_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr));
            var __arg0 = src.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            var arg1 = ReferenceEquals(dstType, null) ? global::System.IntPtr.Zero : dstType.__Instance;
            var __arg2 = dst.__Instance;
            var arg2 = new global::System.IntPtr(&__arg2);
            var __ret = ___ConvertValue_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            return __ret;
        }

        public static bool IsSameClass(wxAnyValueType otherType)
        {
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = Internal.IsSameClass_0(arg0);
            return __ret;
        }

        public static wxAnyValueType GetInstance()
        {
            var __ret = Internal.GetInstance_0();
            wxAnyValueType __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[__ret];
            else wxAnyValueType.NativeToManagedMap[__ret] = __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // virtual ~wxAnyValueTypeImplInt()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplInt) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_bool_IntPtr_IntPtr _IsSameType_0DelegateInstance;

        private static bool _IsSameType_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr otherType)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplInt) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueType __result0;
            if (otherType == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(otherType))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[otherType];
            else __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(otherType, skipVTables: true);
            var __ret = __target.IsSameType(__result0);
            return __ret;
        }

        // bool ConvertValue(const wxAnyValueBuffer& src, wxAnyValueType* dstType, wxAnyValueBuffer& dst) const wxOVERRIDE
        private static Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr _ConvertValue_0DelegateInstance;

        private static bool _ConvertValue_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr src, global::System.IntPtr dstType, global::System.IntPtr dst)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplInt) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueBuffer __result0;
            if (src == IntPtr.Zero) __result0 = new wxAnyValueBuffer();
            else __result0 = wxAnyValueBuffer.__CreateInstance(src);
            wxAnyValueType __result1;
            if (dstType == IntPtr.Zero) __result1 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(dstType))
                __result1 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[dstType];
            else __result1 = (wxAnyValueType) wxAnyValueType.__CreateInstance(dstType, skipVTables: true);
            wxAnyValueBuffer __result2;
            if (dst == IntPtr.Zero) __result2 = new wxAnyValueBuffer();
            else __result2 = wxAnyValueBuffer.__CreateInstance(dst);
            var __ret = __target.ConvertValue(__result0, __result1, __result2);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _IsSameType_0DelegateInstance += _IsSameType_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsSameType_0DelegateInstance).ToPointer();
                _ConvertValue_0DelegateInstance += _ConvertValue_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ConvertValue_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxAnyValueTypeImplUint : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN22wxAnyValueTypeImplUintC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN22wxAnyValueTypeImplUintC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN22wxAnyValueTypeImplUint11IsSameClassEPK14wxAnyValueType")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSameClass_0(global::System.IntPtr otherType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN22wxAnyValueTypeImplUint11GetInstanceEv")]
            internal static extern global::System.IntPtr GetInstance_0();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplUint> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplUint>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxAnyValueTypeImplUint __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplUint(native.ToPointer(), skipVTables);
        }

        public static wxAnyValueTypeImplUint __CreateInstance(wxAnyValueTypeImplUint.Internal native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplUint(native, skipVTables);
        }

        private static void* __CopyValue(wxAnyValueTypeImplUint.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            wxAnyValueTypeImplUint.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxAnyValueTypeImplUint(wxAnyValueTypeImplUint.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxAnyValueTypeImplUint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxAnyValueTypeImplUint()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplUint");
        }

        public wxAnyValueTypeImplUint(wxAnyValueTypeImplUint _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplUint");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxAnyValueTypeImplUint __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___dtor_0Delegate((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public override bool IsSameType(wxAnyValueType otherType)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___IsSameType_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = ___IsSameType_0Delegate((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public override bool ConvertValue(wxAnyValueBuffer src, wxAnyValueType dstType, wxAnyValueBuffer dst)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
            var ___ConvertValue_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr));
            var __arg0 = src.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            var arg1 = ReferenceEquals(dstType, null) ? global::System.IntPtr.Zero : dstType.__Instance;
            var __arg2 = dst.__Instance;
            var arg2 = new global::System.IntPtr(&__arg2);
            var __ret = ___ConvertValue_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            return __ret;
        }

        public static bool IsSameClass(wxAnyValueType otherType)
        {
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = Internal.IsSameClass_0(arg0);
            return __ret;
        }

        public static wxAnyValueType GetInstance()
        {
            var __ret = Internal.GetInstance_0();
            wxAnyValueType __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[__ret];
            else wxAnyValueType.NativeToManagedMap[__ret] = __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // virtual ~wxAnyValueTypeImplUint()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplUint) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_bool_IntPtr_IntPtr _IsSameType_0DelegateInstance;

        private static bool _IsSameType_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr otherType)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplUint) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueType __result0;
            if (otherType == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(otherType))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[otherType];
            else __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(otherType, skipVTables: true);
            var __ret = __target.IsSameType(__result0);
            return __ret;
        }

        // bool ConvertValue(const wxAnyValueBuffer& src, wxAnyValueType* dstType, wxAnyValueBuffer& dst) const wxOVERRIDE
        private static Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr _ConvertValue_0DelegateInstance;

        private static bool _ConvertValue_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr src, global::System.IntPtr dstType, global::System.IntPtr dst)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplUint) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueBuffer __result0;
            if (src == IntPtr.Zero) __result0 = new wxAnyValueBuffer();
            else __result0 = wxAnyValueBuffer.__CreateInstance(src);
            wxAnyValueType __result1;
            if (dstType == IntPtr.Zero) __result1 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(dstType))
                __result1 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[dstType];
            else __result1 = (wxAnyValueType) wxAnyValueType.__CreateInstance(dstType, skipVTables: true);
            wxAnyValueBuffer __result2;
            if (dst == IntPtr.Zero) __result2 = new wxAnyValueBuffer();
            else __result2 = wxAnyValueBuffer.__CreateInstance(dst);
            var __ret = __target.ConvertValue(__result0, __result1, __result2);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _IsSameType_0DelegateInstance += _IsSameType_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsSameType_0DelegateInstance).ToPointer();
                _ConvertValue_0DelegateInstance += _ConvertValue_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ConvertValue_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxAnyValueTypeImplwxString : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN26wxAnyValueTypeImplwxStringC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN26wxAnyValueTypeImplwxStringC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN26wxAnyValueTypeImplwxString11IsSameClassEPK14wxAnyValueType")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSameClass_0(global::System.IntPtr otherType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN26wxAnyValueTypeImplwxString11GetInstanceEv")]
            internal static extern global::System.IntPtr GetInstance_0();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplwxString> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplwxString>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxAnyValueTypeImplwxString __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplwxString(native.ToPointer(), skipVTables);
        }

        public static wxAnyValueTypeImplwxString __CreateInstance(wxAnyValueTypeImplwxString.Internal native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplwxString(native, skipVTables);
        }

        private static void* __CopyValue(wxAnyValueTypeImplwxString.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            wxAnyValueTypeImplwxString.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxAnyValueTypeImplwxString(wxAnyValueTypeImplwxString.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxAnyValueTypeImplwxString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxAnyValueTypeImplwxString()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplwxString");
        }

        public wxAnyValueTypeImplwxString(wxAnyValueTypeImplwxString _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplwxString");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxAnyValueTypeImplwxString __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___dtor_0Delegate((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public override bool IsSameType(wxAnyValueType otherType)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___IsSameType_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = ___IsSameType_0Delegate((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public override bool ConvertValue(wxAnyValueBuffer src, wxAnyValueType dstType, wxAnyValueBuffer dst)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
            var ___ConvertValue_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr));
            var __arg0 = src.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            var arg1 = ReferenceEquals(dstType, null) ? global::System.IntPtr.Zero : dstType.__Instance;
            var __arg2 = dst.__Instance;
            var arg2 = new global::System.IntPtr(&__arg2);
            var __ret = ___ConvertValue_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            return __ret;
        }

        public static bool IsSameClass(wxAnyValueType otherType)
        {
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = Internal.IsSameClass_0(arg0);
            return __ret;
        }

        public static wxAnyValueType GetInstance()
        {
            var __ret = Internal.GetInstance_0();
            wxAnyValueType __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[__ret];
            else wxAnyValueType.NativeToManagedMap[__ret] = __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // 
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplwxString) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_bool_IntPtr_IntPtr _IsSameType_0DelegateInstance;

        private static bool _IsSameType_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr otherType)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplwxString) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueType __result0;
            if (otherType == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(otherType))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[otherType];
            else __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(otherType, skipVTables: true);
            var __ret = __target.IsSameType(__result0);
            return __ret;
        }

        // 
        private static Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr _ConvertValue_0DelegateInstance;

        private static bool _ConvertValue_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr src, global::System.IntPtr dstType, global::System.IntPtr dst)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplwxString) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueBuffer __result0;
            if (src == IntPtr.Zero) __result0 = new wxAnyValueBuffer();
            else __result0 = wxAnyValueBuffer.__CreateInstance(src);
            wxAnyValueType __result1;
            if (dstType == IntPtr.Zero) __result1 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(dstType))
                __result1 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[dstType];
            else __result1 = (wxAnyValueType) wxAnyValueType.__CreateInstance(dstType, skipVTables: true);
            wxAnyValueBuffer __result2;
            if (dst == IntPtr.Zero) __result2 = new wxAnyValueBuffer();
            else __result2 = wxAnyValueBuffer.__CreateInstance(dst);
            var __ret = __target.ConvertValue(__result0, __result1, __result2);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _IsSameType_0DelegateInstance += _IsSameType_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsSameType_0DelegateInstance).ToPointer();
                _ConvertValue_0DelegateInstance += _ConvertValue_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ConvertValue_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxAnyValueTypeImplConstCharPtr : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN30wxAnyValueTypeImplConstCharPtrC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN30wxAnyValueTypeImplConstCharPtrC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN30wxAnyValueTypeImplConstCharPtr11IsSameClassEPK14wxAnyValueType")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSameClass_0(global::System.IntPtr otherType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN30wxAnyValueTypeImplConstCharPtr11GetInstanceEv")]
            internal static extern global::System.IntPtr GetInstance_0();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplConstCharPtr> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplConstCharPtr>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxAnyValueTypeImplConstCharPtr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplConstCharPtr(native.ToPointer(), skipVTables);
        }

        public static wxAnyValueTypeImplConstCharPtr __CreateInstance(wxAnyValueTypeImplConstCharPtr.Internal native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplConstCharPtr(native, skipVTables);
        }

        private static void* __CopyValue(wxAnyValueTypeImplConstCharPtr.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            wxAnyValueTypeImplConstCharPtr.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxAnyValueTypeImplConstCharPtr(wxAnyValueTypeImplConstCharPtr.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxAnyValueTypeImplConstCharPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxAnyValueTypeImplConstCharPtr()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplConstCharPtr");
        }

        public wxAnyValueTypeImplConstCharPtr(wxAnyValueTypeImplConstCharPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplConstCharPtr");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxAnyValueTypeImplConstCharPtr __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___dtor_0Delegate((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public override bool IsSameType(wxAnyValueType otherType)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___IsSameType_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = ___IsSameType_0Delegate((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public override bool ConvertValue(wxAnyValueBuffer src, wxAnyValueType dstType, wxAnyValueBuffer dst)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
            var ___ConvertValue_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr));
            var __arg0 = src.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            var arg1 = ReferenceEquals(dstType, null) ? global::System.IntPtr.Zero : dstType.__Instance;
            var __arg2 = dst.__Instance;
            var arg2 = new global::System.IntPtr(&__arg2);
            var __ret = ___ConvertValue_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            return __ret;
        }

        public static bool IsSameClass(wxAnyValueType otherType)
        {
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = Internal.IsSameClass_0(arg0);
            return __ret;
        }

        public static wxAnyValueType GetInstance()
        {
            var __ret = Internal.GetInstance_0();
            wxAnyValueType __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[__ret];
            else wxAnyValueType.NativeToManagedMap[__ret] = __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // 
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplConstCharPtr) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_bool_IntPtr_IntPtr _IsSameType_0DelegateInstance;

        private static bool _IsSameType_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr otherType)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplConstCharPtr) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueType __result0;
            if (otherType == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(otherType))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[otherType];
            else __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(otherType, skipVTables: true);
            var __ret = __target.IsSameType(__result0);
            return __ret;
        }

        // 
        private static Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr _ConvertValue_0DelegateInstance;

        private static bool _ConvertValue_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr src, global::System.IntPtr dstType, global::System.IntPtr dst)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplConstCharPtr) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueBuffer __result0;
            if (src == IntPtr.Zero) __result0 = new wxAnyValueBuffer();
            else __result0 = wxAnyValueBuffer.__CreateInstance(src);
            wxAnyValueType __result1;
            if (dstType == IntPtr.Zero) __result1 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(dstType))
                __result1 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[dstType];
            else __result1 = (wxAnyValueType) wxAnyValueType.__CreateInstance(dstType, skipVTables: true);
            wxAnyValueBuffer __result2;
            if (dst == IntPtr.Zero) __result2 = new wxAnyValueBuffer();
            else __result2 = wxAnyValueBuffer.__CreateInstance(dst);
            var __ret = __target.ConvertValue(__result0, __result1, __result2);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _IsSameType_0DelegateInstance += _IsSameType_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsSameType_0DelegateInstance).ToPointer();
                _ConvertValue_0DelegateInstance += _ConvertValue_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ConvertValue_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxAnyValueTypeImplConstWchar_tPtr : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN33wxAnyValueTypeImplConstWchar_tPtrC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN33wxAnyValueTypeImplConstWchar_tPtrC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN33wxAnyValueTypeImplConstWchar_tPtr11IsSameClassEPK14wxAnyValueType")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSameClass_0(global::System.IntPtr otherType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN33wxAnyValueTypeImplConstWchar_tPtr11GetInstanceEv")]
            internal static extern global::System.IntPtr GetInstance_0();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplConstWchar_tPtr> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplConstWchar_tPtr>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxAnyValueTypeImplConstWchar_tPtr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplConstWchar_tPtr(native.ToPointer(), skipVTables);
        }

        public static wxAnyValueTypeImplConstWchar_tPtr __CreateInstance(wxAnyValueTypeImplConstWchar_tPtr.Internal native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplConstWchar_tPtr(native, skipVTables);
        }

        private static void* __CopyValue(wxAnyValueTypeImplConstWchar_tPtr.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            wxAnyValueTypeImplConstWchar_tPtr.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxAnyValueTypeImplConstWchar_tPtr(wxAnyValueTypeImplConstWchar_tPtr.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxAnyValueTypeImplConstWchar_tPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxAnyValueTypeImplConstWchar_tPtr()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplConstWchar_tPtr");
        }

        public wxAnyValueTypeImplConstWchar_tPtr(wxAnyValueTypeImplConstWchar_tPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplConstWchar_tPtr");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxAnyValueTypeImplConstWchar_tPtr __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___dtor_0Delegate((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public override bool IsSameType(wxAnyValueType otherType)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___IsSameType_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = ___IsSameType_0Delegate((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public override bool ConvertValue(wxAnyValueBuffer src, wxAnyValueType dstType, wxAnyValueBuffer dst)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
            var ___ConvertValue_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr));
            var __arg0 = src.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            var arg1 = ReferenceEquals(dstType, null) ? global::System.IntPtr.Zero : dstType.__Instance;
            var __arg2 = dst.__Instance;
            var arg2 = new global::System.IntPtr(&__arg2);
            var __ret = ___ConvertValue_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            return __ret;
        }

        public static bool IsSameClass(wxAnyValueType otherType)
        {
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = Internal.IsSameClass_0(arg0);
            return __ret;
        }

        public static wxAnyValueType GetInstance()
        {
            var __ret = Internal.GetInstance_0();
            wxAnyValueType __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[__ret];
            else wxAnyValueType.NativeToManagedMap[__ret] = __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // 
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplConstWchar_tPtr) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_bool_IntPtr_IntPtr _IsSameType_0DelegateInstance;

        private static bool _IsSameType_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr otherType)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplConstWchar_tPtr) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueType __result0;
            if (otherType == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(otherType))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[otherType];
            else __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(otherType, skipVTables: true);
            var __ret = __target.IsSameType(__result0);
            return __ret;
        }

        // 
        private static Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr _ConvertValue_0DelegateInstance;

        private static bool _ConvertValue_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr src, global::System.IntPtr dstType, global::System.IntPtr dst)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplConstWchar_tPtr) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueBuffer __result0;
            if (src == IntPtr.Zero) __result0 = new wxAnyValueBuffer();
            else __result0 = wxAnyValueBuffer.__CreateInstance(src);
            wxAnyValueType __result1;
            if (dstType == IntPtr.Zero) __result1 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(dstType))
                __result1 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[dstType];
            else __result1 = (wxAnyValueType) wxAnyValueType.__CreateInstance(dstType, skipVTables: true);
            wxAnyValueBuffer __result2;
            if (dst == IntPtr.Zero) __result2 = new wxAnyValueBuffer();
            else __result2 = wxAnyValueBuffer.__CreateInstance(dst);
            var __ret = __target.ConvertValue(__result0, __result1, __result2);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _IsSameType_0DelegateInstance += _IsSameType_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsSameType_0DelegateInstance).ToPointer();
                _ConvertValue_0DelegateInstance += _ConvertValue_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ConvertValue_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxAnyValueTypeImplDouble : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN24wxAnyValueTypeImplDoubleC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN24wxAnyValueTypeImplDoubleC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN24wxAnyValueTypeImplDouble11IsSameClassEPK14wxAnyValueType")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSameClass_0(global::System.IntPtr otherType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN24wxAnyValueTypeImplDouble11GetInstanceEv")]
            internal static extern global::System.IntPtr GetInstance_0();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplDouble> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplDouble>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxAnyValueTypeImplDouble __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplDouble(native.ToPointer(), skipVTables);
        }

        public static wxAnyValueTypeImplDouble __CreateInstance(wxAnyValueTypeImplDouble.Internal native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplDouble(native, skipVTables);
        }

        private static void* __CopyValue(wxAnyValueTypeImplDouble.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            wxAnyValueTypeImplDouble.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxAnyValueTypeImplDouble(wxAnyValueTypeImplDouble.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxAnyValueTypeImplDouble(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxAnyValueTypeImplDouble()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplDouble");
        }

        public wxAnyValueTypeImplDouble(wxAnyValueTypeImplDouble _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplDouble");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxAnyValueTypeImplDouble __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___dtor_0Delegate((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public override bool IsSameType(wxAnyValueType otherType)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___IsSameType_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = ___IsSameType_0Delegate((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public override bool ConvertValue(wxAnyValueBuffer src, wxAnyValueType dstType, wxAnyValueBuffer dst)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
            var ___ConvertValue_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr));
            var __arg0 = src.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            var arg1 = ReferenceEquals(dstType, null) ? global::System.IntPtr.Zero : dstType.__Instance;
            var __arg2 = dst.__Instance;
            var arg2 = new global::System.IntPtr(&__arg2);
            var __ret = ___ConvertValue_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            return __ret;
        }

        public static bool IsSameClass(wxAnyValueType otherType)
        {
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = Internal.IsSameClass_0(arg0);
            return __ret;
        }

        public static wxAnyValueType GetInstance()
        {
            var __ret = Internal.GetInstance_0();
            wxAnyValueType __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[__ret];
            else wxAnyValueType.NativeToManagedMap[__ret] = __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // virtual ~wxAnyValueTypeImplDouble()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplDouble) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_bool_IntPtr_IntPtr _IsSameType_0DelegateInstance;

        private static bool _IsSameType_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr otherType)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplDouble) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueType __result0;
            if (otherType == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(otherType))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[otherType];
            else __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(otherType, skipVTables: true);
            var __ret = __target.IsSameType(__result0);
            return __ret;
        }

        // bool ConvertValue(const wxAnyValueBuffer& src, wxAnyValueType* dstType, wxAnyValueBuffer& dst) const wxOVERRIDE
        private static Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr _ConvertValue_0DelegateInstance;

        private static bool _ConvertValue_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr src, global::System.IntPtr dstType, global::System.IntPtr dst)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplDouble) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueBuffer __result0;
            if (src == IntPtr.Zero) __result0 = new wxAnyValueBuffer();
            else __result0 = wxAnyValueBuffer.__CreateInstance(src);
            wxAnyValueType __result1;
            if (dstType == IntPtr.Zero) __result1 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(dstType))
                __result1 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[dstType];
            else __result1 = (wxAnyValueType) wxAnyValueType.__CreateInstance(dstType, skipVTables: true);
            wxAnyValueBuffer __result2;
            if (dst == IntPtr.Zero) __result2 = new wxAnyValueBuffer();
            else __result2 = wxAnyValueBuffer.__CreateInstance(dst);
            var __ret = __target.ConvertValue(__result0, __result1, __result2);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _IsSameType_0DelegateInstance += _IsSameType_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsSameType_0DelegateInstance).ToPointer();
                _ConvertValue_0DelegateInstance += _ConvertValue_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ConvertValue_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxAnyValueTypeImplVariantData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN29wxAnyValueTypeImplVariantDataC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN29wxAnyValueTypeImplVariantDataC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN29wxAnyValueTypeImplVariantData11IsSameClassEPK14wxAnyValueType")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsSameClass_0(global::System.IntPtr otherType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN29wxAnyValueTypeImplVariantData11GetInstanceEv")]
            internal static extern global::System.IntPtr GetInstance_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN29wxAnyValueTypeImplVariantData8SetValueEP13wxVariantDataR16wxAnyValueBuffer")]
            internal static extern void SetValue_0(global::System.IntPtr value, global::System.IntPtr buf);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN29wxAnyValueTypeImplVariantData8GetValueERK16wxAnyValueBuffer")]
            internal static extern global::System.IntPtr GetValue_0(global::System.IntPtr buf);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplVariantData> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAnyValueTypeImplVariantData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxAnyValueTypeImplVariantData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplVariantData(native.ToPointer(), skipVTables);
        }

        public static wxAnyValueTypeImplVariantData __CreateInstance(wxAnyValueTypeImplVariantData.Internal native, bool skipVTables = false)
        {
            return new wxAnyValueTypeImplVariantData(native, skipVTables);
        }

        private static void* __CopyValue(wxAnyValueTypeImplVariantData.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            wxAnyValueTypeImplVariantData.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxAnyValueTypeImplVariantData(wxAnyValueTypeImplVariantData.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxAnyValueTypeImplVariantData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxAnyValueTypeImplVariantData()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplVariantData");
        }

        public wxAnyValueTypeImplVariantData(wxAnyValueTypeImplVariantData _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyValueTypeImplVariantData");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxAnyValueTypeImplVariantData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___dtor_0Delegate((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public override bool IsSameType(wxAnyValueType otherType)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___IsSameType_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = ___IsSameType_0Delegate((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public override bool ConvertValue(wxAnyValueBuffer src, wxAnyValueType dstType, wxAnyValueBuffer dst)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
            var ___ConvertValue_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr));
            var __arg0 = src.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            var arg1 = ReferenceEquals(dstType, null) ? global::System.IntPtr.Zero : dstType.__Instance;
            var __arg2 = dst.__Instance;
            var arg2 = new global::System.IntPtr(&__arg2);
            var __ret = ___ConvertValue_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            return __ret;
        }

        public static bool IsSameClass(wxAnyValueType otherType)
        {
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = Internal.IsSameClass_0(arg0);
            return __ret;
        }

        public static wxAnyValueType GetInstance()
        {
            var __ret = Internal.GetInstance_0();
            wxAnyValueType __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[__ret];
            else wxAnyValueType.NativeToManagedMap[__ret] = __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(__ret);
            return __result0;
        }

        public static void SetValue(wxVariantData value, wxAnyValueBuffer buf)
        {
            var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            var __arg1 = buf.__Instance;
            var arg1 = new global::System.IntPtr(&__arg1);
            Internal.SetValue_0(arg0, arg1);
        }

        public static wxVariantData GetValue(wxAnyValueBuffer buf)
        {
            var __arg0 = buf.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            var __ret = Internal.GetValue_0(arg0);
            wxVariantData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxVariantData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxVariantData) wxVariantData.NativeToManagedMap[__ret];
            else wxVariantData.NativeToManagedMap[__ret] = __result0 = (wxVariantData) wxVariantData.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // virtual ~wxAnyValueTypeImplVariantData()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplVariantData) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_bool_IntPtr_IntPtr _IsSameType_0DelegateInstance;

        private static bool _IsSameType_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr otherType)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplVariantData) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueType __result0;
            if (otherType == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(otherType))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[otherType];
            else __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(otherType, skipVTables: true);
            var __ret = __target.IsSameType(__result0);
            return __ret;
        }

        // bool ConvertValue(const wxAnyValueBuffer& src, wxAnyValueType* dstType, wxAnyValueBuffer& dst) const wxOVERRIDE
        private static Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr _ConvertValue_0DelegateInstance;

        private static bool _ConvertValue_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr src, global::System.IntPtr dstType, global::System.IntPtr dst)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyValueTypeImplVariantData) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxAnyValueBuffer __result0;
            if (src == IntPtr.Zero) __result0 = new wxAnyValueBuffer();
            else __result0 = wxAnyValueBuffer.__CreateInstance(src);
            wxAnyValueType __result1;
            if (dstType == IntPtr.Zero) __result1 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(dstType))
                __result1 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[dstType];
            else __result1 = (wxAnyValueType) wxAnyValueType.__CreateInstance(dstType, skipVTables: true);
            wxAnyValueBuffer __result2;
            if (dst == IntPtr.Zero) __result2 = new wxAnyValueBuffer();
            else __result2 = wxAnyValueBuffer.__CreateInstance(dst);
            var __ret = __target.ConvertValue(__result0, __result1, __result2);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _IsSameType_0DelegateInstance += _IsSameType_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsSameType_0DelegateInstance).ToPointer();
                _ConvertValue_0DelegateInstance += _ConvertValue_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ConvertValue_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxAny : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public wxAnyValueBuffer.Internal m_buffer;

            [FieldOffset(16)]
            public global::System.IntPtr m_type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxAnyC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxAnyC2EPKc")]
            internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxAnyC2ERKS_")]
            internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr any);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxAnyC2ERK9wxVariant")]
            internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr variant);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxAnyD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAny7GetTypeEv")]
            internal static extern global::System.IntPtr GetType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAny11HasSameTypeERKS_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasSameType_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAny6IsNullEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsNull_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxAny8MakeNullEv")]
            internal static extern void MakeNull_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqERK8wxString")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEPKc")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_1(global::System.IntPtr instance, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEa")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_3(global::System.IntPtr instance, sbyte value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEh")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_4(global::System.IntPtr instance, byte value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEs")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_5(global::System.IntPtr instance, short value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEt")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_6(global::System.IntPtr instance, ushort value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEi")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_7(global::System.IntPtr instance, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEj")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_8(global::System.IntPtr instance, uint value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEx")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_11(global::System.IntPtr instance, long value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEy")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_12(global::System.IntPtr instance, ulong value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEf")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_13(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEd")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_14(global::System.IntPtr instance, double value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAnyeqEb")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_15(global::System.IntPtr instance, bool value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxAny5GetAsEP9wxVariant")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetAs_1(global::System.IntPtr instance, global::System.IntPtr value);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAny> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxAny>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxAny __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAny(native.ToPointer(), skipVTables);
        }

        public static wxAny __CreateInstance(wxAny.Internal native, bool skipVTables = false)
        {
            return new wxAny(native, skipVTables);
        }

        private static void* __CopyValue(wxAny.Internal native)
        {
            var ret = Marshal.AllocHGlobal(32);
            wxAny.Internal.cctor_4(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxAny(wxAny.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxAny(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>        Default constructor.</para>
        /// </summary>
        /// 
        public wxAny()
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public wxAny(string value)
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = Marshal.StringToHGlobalAnsi(value);
            Internal.ctor_2((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
        }

        public wxAny(wxAny any)
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(any, null))
                throw new global::System.ArgumentNullException("any", "Cannot be null because it is a C++ reference (&).");
            var arg0 = any.__Instance;
            Internal.cctor_4((__Instance + __PointerAdjustment), arg0);
        }

        public wxAny(wxVariant variant)
        {
            __Instance = Marshal.AllocHGlobal(32);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(variant, null))
                throw new global::System.ArgumentNullException("variant", "Cannot be null because it is a C++ reference (&).");
            var arg0 = variant.__Instance;
            Internal.ctor_5((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxAny __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        /// <summary>
        /// <para>        Returns the value type as wxAnyValueType instance.</para>
        /// </summary>
        /// <remarks>
        /// <para>        </para>
        /// <para>        </para>
        /// </remarks>
        public wxAnyValueType GetType()
        {
            var __ret = Internal.GetType_0((__Instance + __PointerAdjustment));
            wxAnyValueType __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAnyValueType.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAnyValueType) wxAnyValueType.NativeToManagedMap[__ret];
            else wxAnyValueType.NativeToManagedMap[__ret] = __result0 = (wxAnyValueType) wxAnyValueType.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>        Returns </para>
        /// </summary>
        /// <remarks>
        /// <para>if this and another wxAny have the same</para>
        /// <para>        value type.</para>
        /// </remarks>
        public bool HasSameType(wxAny other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var arg0 = other.__Instance;
            var __ret = Internal.HasSameType_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        /// <summary>
        /// <para>        Tests if wxAny is null (that is, whether there is no data).</para>
        /// </summary>
        /// 
        public bool IsNull()
        {
            var __ret = Internal.IsNull_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>
        /// <para>        Makes wxAny null (that is, clears it).</para>
        /// </summary>
        /// 
        public void MakeNull()
        {
            Internal.MakeNull_0((__Instance + __PointerAdjustment));
        }

        public static bool operator !=(wxAny __op, wxString value)
        {
            return !(__op == value);
        }

        /// <summary>
        /// <para>        Equality operators.</para>
        /// </summary>
        /// 
        public static bool operator ==(wxAny __op, wxString value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var arg1 = value.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }

        public static bool operator !=(wxAny __op, string value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, string value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var arg1 = Marshal.StringToHGlobalAnsi(value);
            var __ret = Internal.OperatorEqualEqual_1(arg0, arg1);
            Marshal.FreeHGlobal(arg1);
            return __ret;
        }

        public static bool operator !=(wxAny __op, sbyte value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, sbyte value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var arg1 = value;
            var __ret = Internal.OperatorEqualEqual_3(arg0, arg1);
            return __ret;
        }

        public static bool operator !=(wxAny __op, byte value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, byte value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var __ret = Internal.OperatorEqualEqual_4(arg0, value);
            return __ret;
        }

        public static bool operator !=(wxAny __op, short value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, short value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var __ret = Internal.OperatorEqualEqual_5(arg0, value);
            return __ret;
        }

        public static bool operator !=(wxAny __op, ushort value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, ushort value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var __ret = Internal.OperatorEqualEqual_6(arg0, value);
            return __ret;
        }

        public static bool operator !=(wxAny __op, int value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, int value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var __ret = Internal.OperatorEqualEqual_7(arg0, value);
            return __ret;
        }

        public static bool operator !=(wxAny __op, uint value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, uint value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var __ret = Internal.OperatorEqualEqual_8(arg0, value);
            return __ret;
        }

        public static bool operator !=(wxAny __op, long value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, long value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var __ret = Internal.OperatorEqualEqual_11(arg0, value);
            return __ret;
        }

        public static bool operator !=(wxAny __op, ulong value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, ulong value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var __ret = Internal.OperatorEqualEqual_12(arg0, value);
            return __ret;
        }

        public static bool operator !=(wxAny __op, float value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var __ret = Internal.OperatorEqualEqual_13(arg0, value);
            return __ret;
        }

        public static bool operator !=(wxAny __op, double value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, double value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var __ret = Internal.OperatorEqualEqual_14(arg0, value);
            return __ret;
        }

        public static bool operator !=(wxAny __op, bool value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxAny __op, bool value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var __ret = Internal.OperatorEqualEqual_15(arg0, value);
            return __ret;
        }

        public bool GetAs(wxVariant value)
        {
            var arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            var __ret = Internal.GetAs_1((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }
    }

    public unsafe partial class wxwxAnyListNode : wxNodeBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public wxListKeyValue.Internal m_key;

            [FieldOffset(8)]
            public global::System.IntPtr m_data;

            [FieldOffset(12)]
            public global::System.IntPtr m_next;

            [FieldOffset(16)]
            public global::System.IntPtr m_previous;

            [FieldOffset(20)]
            public global::System.IntPtr m_list;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15wxwxAnyListNodeC2EP10wxListBasePS_S2_P5wxAnyRK9wxListKey")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr list, global::System.IntPtr previous, global::System.IntPtr next, global::System.IntPtr data, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK15wxwxAnyListNode7GetNextEv")]
            internal static extern global::System.IntPtr GetNext_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK15wxwxAnyListNode11GetPreviousEv")]
            internal static extern global::System.IntPtr GetPrevious_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK15wxwxAnyListNode7GetDataEv")]
            internal static extern global::System.IntPtr GetData_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15wxwxAnyListNode7SetDataEP5wxAny")]
            internal static extern void SetData_0(global::System.IntPtr instance, global::System.IntPtr data);
        }

        public static new wxwxAnyListNode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxwxAnyListNode(native.ToPointer(), skipVTables);
        }

        public static wxwxAnyListNode __CreateInstance(wxwxAnyListNode.Internal native, bool skipVTables = false)
        {
            return new wxwxAnyListNode(native, skipVTables);
        }

        private static void* __CopyValue(wxwxAnyListNode.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            *(wxwxAnyListNode.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxwxAnyListNode(wxwxAnyListNode.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxwxAnyListNode(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxwxAnyListNode(wxListBase list, wxwxAnyListNode previous, wxwxAnyListNode next, wxAny data, wxListKey key)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = ReferenceEquals(list, null) ? global::System.IntPtr.Zero : list.__Instance;
            var arg1 = ReferenceEquals(previous, null) ? global::System.IntPtr.Zero : previous.__Instance;
            var arg2 = ReferenceEquals(next, null) ? global::System.IntPtr.Zero : next.__Instance;
            var arg3 = ReferenceEquals(data, null) ? global::System.IntPtr.Zero : data.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg4 = key.__Instance;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3, arg4);
            SetupVTables(GetType().FullName == "wxSharp.wxwxAnyListNode");
        }

        public wxwxAnyListNode GetNext()
        {
            var __ret = Internal.GetNext_0((__Instance + __PointerAdjustment));
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxwxAnyListNode GetPrevious()
        {
            var __ret = Internal.GetPrevious_0((__Instance + __PointerAdjustment));
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxAny GetData()
        {
            var __ret = Internal.GetData_0((__Instance + __PointerAdjustment));
            wxAny __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAny.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAny) wxAny.NativeToManagedMap[__ret];
            else __result0 = wxAny.__CreateInstance(__ret);
            return __result0;
        }

        public void SetData(wxAny data)
        {
            var arg0 = ReferenceEquals(data, null) ? global::System.IntPtr.Zero : data.__Instance;
            Internal.SetData_0((__Instance + __PointerAdjustment), arg0);
        }

        protected override void DeleteData()
        {
            base.DeleteData();
        }

        #region Virtual table interop

        // 
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxwxAnyListNode) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Action_IntPtr _DeleteData_0DelegateInstance;

        private static void _DeleteData_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxwxAnyListNode) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.DeleteData();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _DeleteData_0DelegateInstance += _DeleteData_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_DeleteData_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxAnyList : wxListBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public uint m_count;

            [FieldOffset(8)]
            public byte m_destroy;

            [FieldOffset(12)]
            public global::System.IntPtr m_nodeFirst;

            [FieldOffset(16)]
            public global::System.IntPtr m_nodeLast;

            [FieldOffset(20)]
            public wxKeyType m_keyType;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyListC2E9wxKeyType")]
            internal static extern void ctor_0(global::System.IntPtr instance, wxKeyType keyType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyListC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyListC2EmRKP5wxAny")]
            internal static extern void ctor_3(global::System.IntPtr instance, uint n, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyListC2ERKNS_14const_iteratorES2_")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxAnyList8GetFirstEv")]
            internal static extern global::System.IntPtr GetFirst_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxAnyList7GetLastEv")]
            internal static extern global::System.IntPtr GetLast_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxAnyList4ItemEm")]
            internal static extern global::System.IntPtr Item_0(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6AppendEP5wxAny")]
            internal static extern global::System.IntPtr Append_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6InsertEP5wxAny")]
            internal static extern global::System.IntPtr Insert_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6InsertEmP5wxAny")]
            internal static extern global::System.IntPtr Insert_1(global::System.IntPtr instance, uint pos, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6InsertEP15wxwxAnyListNodeP5wxAny")]
            internal static extern global::System.IntPtr Insert_2(global::System.IntPtr instance, global::System.IntPtr prev, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6AppendElPv")]
            internal static extern global::System.IntPtr Append_1(global::System.IntPtr instance, int key, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6AppendEPKwPv")]
            internal static extern global::System.IntPtr Append_2(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList10DetachNodeEP15wxwxAnyListNode")]
            internal static extern global::System.IntPtr DetachNode_0(global::System.IntPtr instance, global::System.IntPtr node);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList10DeleteNodeEP15wxwxAnyListNode")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteNode_0(global::System.IntPtr instance, global::System.IntPtr node);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList12DeleteObjectEP5wxAny")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteObject_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList5EraseEP15wxwxAnyListNode")]
            internal static extern void Erase_0(global::System.IntPtr instance, global::System.IntPtr it);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxAnyList4FindEPK5wxAny")]
            internal static extern global::System.IntPtr Find_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxAnyList6MemberEPK5wxAny")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Member_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxAnyList7IndexOfEP5wxAny")]
            internal static extern int IndexOf_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList4SortEPFiPKvS1_E")]
            internal static extern void Sort_0(global::System.IntPtr instance, global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList4SortEPFiPPK5wxAnyS3_E")]
            internal static extern void Sort_1(global::System.IntPtr instance, global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList5beginEv")]
            internal static extern wxAnyList.iterator.Internal begin_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList3endEv")]
            internal static extern wxAnyList.iterator.Internal end_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6rbeginEv")]
            internal static extern wxAnyList.reverse_iterator.Internal rbegin_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList4rendEv")]
            internal static extern wxAnyList.reverse_iterator.Internal rend_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6resizeEmP5wxAny")]
            internal static extern void resize_0(global::System.IntPtr instance, uint n, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxAnyList4sizeEv")]
            internal static extern uint size_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxAnyList8max_sizeEv")]
            internal static extern uint max_size_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxAnyList5emptyEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool empty_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList5frontEv")]
            internal static extern global::System.IntPtr front_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList4backEv")]
            internal static extern global::System.IntPtr back_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList10push_frontERKP5wxAny")]
            internal static extern void push_front_0(global::System.IntPtr instance, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList9pop_frontEv")]
            internal static extern void pop_front_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList9push_backERKP5wxAny")]
            internal static extern void push_back_0(global::System.IntPtr instance, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList8pop_backEv")]
            internal static extern void pop_back_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6assignENS_14const_iteratorERKS0_")]
            internal static extern void assign_0(global::System.IntPtr instance, wxAnyList.const_iterator.Internal first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6assignEmRKP5wxAny")]
            internal static extern void assign_1(global::System.IntPtr instance, uint n, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6insertERKNS_8iteratorERKP5wxAny")]
            internal static extern wxAnyList.iterator.Internal insert_0(global::System.IntPtr instance, global::System.IntPtr it, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6insertERKNS_8iteratorEmRKP5wxAny")]
            internal static extern void insert_1(global::System.IntPtr instance, global::System.IntPtr it, uint n, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6insertERKNS_8iteratorENS_14const_iteratorERKS3_")]
            internal static extern void insert_2(global::System.IntPtr instance, global::System.IntPtr it, wxAnyList.const_iterator.Internal first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList5eraseERKNS_8iteratorE")]
            internal static extern wxAnyList.iterator.Internal erase_0(global::System.IntPtr instance, global::System.IntPtr it);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList5eraseERKNS_8iteratorES2_")]
            internal static extern wxAnyList.iterator.Internal erase_1(global::System.IntPtr instance, global::System.IntPtr first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList5clearEv")]
            internal static extern void clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6spliceERKNS_8iteratorERS_S2_S2_")]
            internal static extern void splice_0(global::System.IntPtr instance, global::System.IntPtr it, global::System.IntPtr l, global::System.IntPtr first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6spliceERKNS_8iteratorERS_")]
            internal static extern void splice_1(global::System.IntPtr instance, global::System.IntPtr it, global::System.IntPtr l);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6spliceERKNS_8iteratorERS_S2_")]
            internal static extern void splice_2(global::System.IntPtr instance, global::System.IntPtr it, global::System.IntPtr l, global::System.IntPtr first);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList6removeERKP5wxAny")]
            internal static extern void remove_0(global::System.IntPtr instance, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxAnyList7reverseEv")]
            internal static extern void reverse_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxAnyListixEm")]
            internal static extern global::System.IntPtr OperatorSubscript_0(global::System.IntPtr instance, uint index);
        }

        public class value_type { }

        public class base_value_type { }

        public unsafe partial class compatibility_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_ptr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList22compatibility_iteratorC2EP15wxwxAnyListNode")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr ptr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList22compatibility_iteratorC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK9wxAnyList22compatibility_iteratorcvP15wxwxAnyListNodeEv")]
                internal static extern global::System.IntPtr OperatorConversion_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, compatibility_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, compatibility_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static compatibility_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new compatibility_iterator(native.ToPointer(), skipVTables);
            }

            public static compatibility_iterator __CreateInstance(compatibility_iterator.Internal native, bool skipVTables = false)
            {
                return new compatibility_iterator(native, skipVTables);
            }

            private static void* __CopyValue(compatibility_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(4);
                *(compatibility_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private compatibility_iterator(compatibility_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected compatibility_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public compatibility_iterator(wxwxAnyListNode ptr)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(ptr, null) ? global::System.IntPtr.Zero : ptr.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
            }

            public compatibility_iterator(wxAnyList.compatibility_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((compatibility_iterator.Internal*) __Instance) = *((compatibility_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxAnyList.compatibility_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static implicit operator wxwxAnyListNode(wxAnyList.compatibility_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorConversion_0(arg0);
                wxwxAnyListNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
                else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
                return __result0;
            }
        }

        public unsafe partial class iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList8iteratorC2EP15wxwxAnyListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList8iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList8iteratorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList8iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList8iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK9wxAnyList8iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK9wxAnyList8iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public class value_type { }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new iterator(native.ToPointer(), skipVTables);
            }

            public static iterator __CreateInstance(iterator.Internal native, bool skipVTables = false)
            {
                return new iterator(native, skipVTables);
            }

            private static void* __CopyValue(iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private iterator(iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public iterator(wxwxAnyListNode node, wxwxAnyListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public iterator(wxAnyList.iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((iterator.Internal*) __Instance) = *((iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxAnyList.iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxAnyList.iterator operator ++(wxAnyList.iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxAnyList.iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxAnyList.iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxAnyList.iterator) wxAnyList.iterator.NativeToManagedMap[__ret];
                else __result0 = wxAnyList.iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxAnyList.iterator operator --(wxAnyList.iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxAnyList.iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxAnyList.iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxAnyList.iterator) wxAnyList.iterator.NativeToManagedMap[__ret];
                else __result0 = wxAnyList.iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxAnyList.iterator __op, wxAnyList.iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxAnyList.iterator __op, wxAnyList.iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxwxAnyListNode m_node
            {
                get
                {
                    wxwxAnyListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxwxAnyListNode m_init
            {
                get
                {
                    wxwxAnyListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class const_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList14const_iteratorC2EP15wxwxAnyListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList14const_iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList14const_iteratorC2ERKNS_8iteratorE")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList14const_iteratorC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList14const_iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList14const_iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK9wxAnyList14const_iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK9wxAnyList14const_iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public class value_type { }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static const_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new const_iterator(native.ToPointer(), skipVTables);
            }

            public static const_iterator __CreateInstance(const_iterator.Internal native, bool skipVTables = false)
            {
                return new const_iterator(native, skipVTables);
            }

            private static void* __CopyValue(const_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(const_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private const_iterator(const_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected const_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public const_iterator(wxwxAnyListNode node, wxwxAnyListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public const_iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public const_iterator(wxAnyList.iterator it)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(it, null))
                    throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
                var arg0 = it.__Instance;
                Internal.ctor_2((__Instance + __PointerAdjustment), arg0);
            }

            public const_iterator(wxAnyList.const_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((const_iterator.Internal*) __Instance) = *((const_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxAnyList.const_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxAnyList.const_iterator operator ++(wxAnyList.const_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxAnyList.const_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxAnyList.const_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxAnyList.const_iterator) wxAnyList.const_iterator.NativeToManagedMap[__ret];
                else __result0 = wxAnyList.const_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxAnyList.const_iterator operator --(wxAnyList.const_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxAnyList.const_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxAnyList.const_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxAnyList.const_iterator) wxAnyList.const_iterator.NativeToManagedMap[__ret];
                else __result0 = wxAnyList.const_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxAnyList.const_iterator __op, wxAnyList.const_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxAnyList.const_iterator __op, wxAnyList.const_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as const_iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxwxAnyListNode m_node
            {
                get
                {
                    wxwxAnyListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxwxAnyListNode m_init
            {
                get
                {
                    wxwxAnyListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class reverse_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList16reverse_iteratorC2EP15wxwxAnyListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList16reverse_iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList16reverse_iteratorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList16reverse_iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList16reverse_iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK9wxAnyList16reverse_iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK9wxAnyList16reverse_iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public class value_type { }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, reverse_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, reverse_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static reverse_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new reverse_iterator(native.ToPointer(), skipVTables);
            }

            public static reverse_iterator __CreateInstance(reverse_iterator.Internal native, bool skipVTables = false)
            {
                return new reverse_iterator(native, skipVTables);
            }

            private static void* __CopyValue(reverse_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(reverse_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private reverse_iterator(reverse_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected reverse_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public reverse_iterator(wxwxAnyListNode node, wxwxAnyListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public reverse_iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public reverse_iterator(wxAnyList.reverse_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((reverse_iterator.Internal*) __Instance) = *((reverse_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxAnyList.reverse_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxAnyList.reverse_iterator operator ++(wxAnyList.reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxAnyList.reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxAnyList.reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxAnyList.reverse_iterator) wxAnyList.reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxAnyList.reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxAnyList.reverse_iterator operator --(wxAnyList.reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxAnyList.reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxAnyList.reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxAnyList.reverse_iterator) wxAnyList.reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxAnyList.reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxAnyList.reverse_iterator __op, wxAnyList.reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxAnyList.reverse_iterator __op, wxAnyList.reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as reverse_iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxwxAnyListNode m_node
            {
                get
                {
                    wxwxAnyListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxwxAnyListNode m_init
            {
                get
                {
                    wxwxAnyListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class const_reverse_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList22const_reverse_iteratorC2EP15wxwxAnyListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList22const_reverse_iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList22const_reverse_iteratorC2ERKNS_16reverse_iteratorE")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList22const_reverse_iteratorC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList22const_reverse_iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9wxAnyList22const_reverse_iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK9wxAnyList22const_reverse_iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK9wxAnyList22const_reverse_iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public class value_type { }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_reverse_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_reverse_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static const_reverse_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new const_reverse_iterator(native.ToPointer(), skipVTables);
            }

            public static const_reverse_iterator __CreateInstance(const_reverse_iterator.Internal native, bool skipVTables = false)
            {
                return new const_reverse_iterator(native, skipVTables);
            }

            private static void* __CopyValue(const_reverse_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(const_reverse_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private const_reverse_iterator(const_reverse_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected const_reverse_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public const_reverse_iterator(wxwxAnyListNode node, wxwxAnyListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public const_reverse_iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public const_reverse_iterator(wxAnyList.reverse_iterator it)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(it, null))
                    throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
                var arg0 = it.__Instance;
                Internal.ctor_2((__Instance + __PointerAdjustment), arg0);
            }

            public const_reverse_iterator(wxAnyList.const_reverse_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((const_reverse_iterator.Internal*) __Instance) = *((const_reverse_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxAnyList.const_reverse_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxAnyList.const_reverse_iterator operator ++(wxAnyList.const_reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxAnyList.const_reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxAnyList.const_reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxAnyList.const_reverse_iterator) wxAnyList.const_reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxAnyList.const_reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxAnyList.const_reverse_iterator operator --(wxAnyList.const_reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxAnyList.const_reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxAnyList.const_reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxAnyList.const_reverse_iterator) wxAnyList.const_reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxAnyList.const_reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxAnyList.const_reverse_iterator __op, wxAnyList.const_reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxAnyList.const_reverse_iterator __op, wxAnyList.const_reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as const_reverse_iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxwxAnyListNode m_node
            {
                get
                {
                    wxwxAnyListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxwxAnyListNode m_init
            {
                get
                {
                    wxwxAnyListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxwxAnyListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public static new wxAnyList __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxAnyList(native.ToPointer(), skipVTables);
        }

        public static wxAnyList __CreateInstance(wxAnyList.Internal native, bool skipVTables = false)
        {
            return new wxAnyList(native, skipVTables);
        }

        private static void* __CopyValue(wxAnyList.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            wxAnyList.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxAnyList(wxAnyList.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxAnyList(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxAnyList(wxKeyType keyType)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = keyType;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyList");
        }

        public wxAnyList(wxAnyList list)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(list, null))
                throw new global::System.ArgumentNullException("list", "Cannot be null because it is a C++ reference (&).");
            var arg0 = list.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyList");
        }

        public wxAnyList(uint n, wxAny v)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg1 = v.__Instance;
            Internal.ctor_3((__Instance + __PointerAdjustment), n, arg1);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyList");
        }

        public wxAnyList(wxAnyList.const_iterator first, wxAnyList.const_iterator last)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg0 = first.__Instance;
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg1 = last.__Instance;
            Internal.ctor_4((__Instance + __PointerAdjustment), arg0, arg1);
            SetupVTables(GetType().FullName == "wxSharp.wxAnyList");
        }

        public wxwxAnyListNode GetFirst()
        {
            var __ret = Internal.GetFirst_0((__Instance + __PointerAdjustment));
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxwxAnyListNode GetLast()
        {
            var __ret = Internal.GetLast_0((__Instance + __PointerAdjustment));
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxwxAnyListNode Item(uint index)
        {
            var __ret = Internal.Item_0((__Instance + __PointerAdjustment), index);
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxwxAnyListNode Append(wxAny @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Append_0((__Instance + __PointerAdjustment), arg0);
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxwxAnyListNode Insert(wxAny @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Insert_0((__Instance + __PointerAdjustment), arg0);
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxwxAnyListNode Insert(uint pos, wxAny @object)
        {
            var arg1 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Insert_1((__Instance + __PointerAdjustment), pos, arg1);
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxwxAnyListNode Insert(wxwxAnyListNode prev, wxAny @object)
        {
            var arg0 = ReferenceEquals(prev, null) ? global::System.IntPtr.Zero : prev.__Instance;
            var arg1 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Insert_2((__Instance + __PointerAdjustment), arg0, arg1);
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxwxAnyListNode Append(int key, global::System.IntPtr @object)
        {
            var arg1 = @object;
            var __ret = Internal.Append_1((__Instance + __PointerAdjustment), key, arg1);
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxwxAnyListNode Append(string key, global::System.IntPtr @object)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(key);
            var arg1 = @object;
            var __ret = Internal.Append_2((__Instance + __PointerAdjustment), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxwxAnyListNode DetachNode(wxwxAnyListNode node)
        {
            var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
            var __ret = Internal.DetachNode_0((__Instance + __PointerAdjustment), arg0);
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public bool DeleteNode(wxwxAnyListNode node)
        {
            var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
            var __ret = Internal.DeleteNode_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public bool DeleteObject(wxAny @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.DeleteObject_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public void Erase(wxwxAnyListNode it)
        {
            var arg0 = ReferenceEquals(it, null) ? global::System.IntPtr.Zero : it.__Instance;
            Internal.Erase_0((__Instance + __PointerAdjustment), arg0);
        }

        public wxwxAnyListNode Find(wxAny @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Find_0((__Instance + __PointerAdjustment), arg0);
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public virtual wxwxAnyListNode Find(wxListKey key)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
            var ___Find_1Delegate = (Delegates.Func_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg0 = key.__Instance;
            var __ret = ___Find_1Delegate((__Instance + __PointerAdjustment), arg0);
            wxwxAnyListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxwxAnyListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxwxAnyListNode) wxwxAnyListNode.NativeToManagedMap[__ret];
            else wxwxAnyListNode.NativeToManagedMap[__ret] = __result0 = (wxwxAnyListNode) wxwxAnyListNode.__CreateInstance(__ret);
            return __result0;
        }

        public bool Member(wxAny @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Member_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public int IndexOf(wxAny @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.IndexOf_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public void Sort(wxSortCompareFunction func)
        {
            var arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            Internal.Sort_0((__Instance + __PointerAdjustment), arg0);
        }

        public void Sort(wxSortFuncFor_wxAnyList func)
        {
            var arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            Internal.Sort_1((__Instance + __PointerAdjustment), arg0);
        }

        protected override wxNodeBase CreateNode(wxNodeBase prev, wxNodeBase next, global::System.IntPtr data, wxListKey key)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___CreateNode_0Delegate = (Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(prev, null) ? global::System.IntPtr.Zero : prev.__Instance;
            var arg1 = ReferenceEquals(next, null) ? global::System.IntPtr.Zero : next.__Instance;
            var arg2 = data;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg3 = key.__Instance;
            var __ret = ___CreateNode_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        public wxAnyList.iterator begin()
        {
            var __ret = Internal.begin_0((__Instance + __PointerAdjustment));
            return wxAnyList.iterator.__CreateInstance(__ret);
        }

        public wxAnyList.iterator end()
        {
            var __ret = Internal.end_0((__Instance + __PointerAdjustment));
            return wxAnyList.iterator.__CreateInstance(__ret);
        }

        public wxAnyList.reverse_iterator rbegin()
        {
            var __ret = Internal.rbegin_0((__Instance + __PointerAdjustment));
            return wxAnyList.reverse_iterator.__CreateInstance(__ret);
        }

        public wxAnyList.reverse_iterator rend()
        {
            var __ret = Internal.rend_0((__Instance + __PointerAdjustment));
            return wxAnyList.reverse_iterator.__CreateInstance(__ret);
        }

        public void resize(uint n, wxAny v)
        {
            var arg1 = ReferenceEquals(v, null) ? global::System.IntPtr.Zero : v.__Instance;
            Internal.resize_0((__Instance + __PointerAdjustment), n, arg1);
        }

        public uint size()
        {
            var __ret = Internal.size_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public uint max_size()
        {
            var __ret = Internal.max_size_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool empty()
        {
            var __ret = Internal.empty_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxAny front()
        {
            var __ret = Internal.front_0((__Instance + __PointerAdjustment));
            wxAny __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAny.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAny) wxAny.NativeToManagedMap[__ret];
            else __result0 = wxAny.__CreateInstance(__ret);
            return __result0;
        }

        public wxAny back()
        {
            var __ret = Internal.back_0((__Instance + __PointerAdjustment));
            wxAny __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxAny.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxAny) wxAny.NativeToManagedMap[__ret];
            else __result0 = wxAny.__CreateInstance(__ret);
            return __result0;
        }

        public void push_front(wxAny v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg0 = v.__Instance;
            Internal.push_front_0((__Instance + __PointerAdjustment), arg0);
        }

        public void pop_front()
        {
            Internal.pop_front_0((__Instance + __PointerAdjustment));
        }

        public void push_back(wxAny v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg0 = v.__Instance;
            Internal.push_back_0((__Instance + __PointerAdjustment), arg0);
        }

        public void pop_back()
        {
            Internal.pop_back_0((__Instance + __PointerAdjustment));
        }

        public void assign(wxAnyList.const_iterator first, wxAnyList.const_iterator last)
        {
            var arg0 = ReferenceEquals(first, null) ? new wxAnyList.const_iterator.Internal() : *(wxAnyList.const_iterator.Internal*) (first.__Instance);
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg1 = last.__Instance;
            Internal.assign_0((__Instance + __PointerAdjustment), arg0, arg1);
        }

        public void assign(uint n, wxAny v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg1 = v.__Instance;
            Internal.assign_1((__Instance + __PointerAdjustment), n, arg1);
        }

        public wxAnyList.iterator insert(wxAnyList.iterator it, wxAny v)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg1 = v.__Instance;
            var __ret = Internal.insert_0((__Instance + __PointerAdjustment), arg0, arg1);
            return wxAnyList.iterator.__CreateInstance(__ret);
        }

        public void insert(wxAnyList.iterator it, uint n, wxAny v)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg2 = v.__Instance;
            Internal.insert_1((__Instance + __PointerAdjustment), arg0, n, arg2);
        }

        public void insert(wxAnyList.iterator it, wxAnyList.const_iterator first, wxAnyList.const_iterator last)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            var arg1 = ReferenceEquals(first, null) ? new wxAnyList.const_iterator.Internal() : *(wxAnyList.const_iterator.Internal*) (first.__Instance);
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg2 = last.__Instance;
            Internal.insert_2((__Instance + __PointerAdjustment), arg0, arg1, arg2);
        }

        public wxAnyList.iterator erase(wxAnyList.iterator it)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            var __ret = Internal.erase_0((__Instance + __PointerAdjustment), arg0);
            return wxAnyList.iterator.__CreateInstance(__ret);
        }

        public wxAnyList.iterator erase(wxAnyList.iterator first, wxAnyList.iterator last)
        {
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg0 = first.__Instance;
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg1 = last.__Instance;
            var __ret = Internal.erase_1((__Instance + __PointerAdjustment), arg0, arg1);
            return wxAnyList.iterator.__CreateInstance(__ret);
        }

        public void clear()
        {
            Internal.clear_0((__Instance + __PointerAdjustment));
        }

        public void splice(wxAnyList.iterator it, wxAnyList l, wxAnyList.iterator first, wxAnyList.iterator last)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(l, null))
                throw new global::System.ArgumentNullException("l", "Cannot be null because it is a C++ reference (&).");
            var arg1 = l.__Instance;
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg2 = first.__Instance;
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg3 = last.__Instance;
            Internal.splice_0((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3);
        }

        public void splice(wxAnyList.iterator it, wxAnyList l)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(l, null))
                throw new global::System.ArgumentNullException("l", "Cannot be null because it is a C++ reference (&).");
            var arg1 = l.__Instance;
            Internal.splice_1((__Instance + __PointerAdjustment), arg0, arg1);
        }

        public void splice(wxAnyList.iterator it, wxAnyList l, wxAnyList.iterator first)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(l, null))
                throw new global::System.ArgumentNullException("l", "Cannot be null because it is a C++ reference (&).");
            var arg1 = l.__Instance;
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg2 = first.__Instance;
            Internal.splice_2((__Instance + __PointerAdjustment), arg0, arg1, arg2);
        }

        public void remove(wxAny v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg0 = v.__Instance;
            Internal.remove_0((__Instance + __PointerAdjustment), arg0);
        }

        public void reverse()
        {
            Internal.reverse_0((__Instance + __PointerAdjustment));
        }

        public wxAny this[uint index]
        {
            get
            {
                var __ret = Internal.OperatorSubscript_0((__Instance + __PointerAdjustment), index);
                wxAny __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxAny.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxAny) wxAny.NativeToManagedMap[__ret];
                else __result0 = wxAny.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                *(wxAny.Internal*) Internal.OperatorSubscript_0((__Instance + __PointerAdjustment), index) = *(wxAny.Internal*) value.__Instance;
            }
        }

        #region Virtual table interop

        // wxAnyList
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _CreateNode_0DelegateInstance;

        private static global::System.IntPtr _CreateNode_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr prev, global::System.IntPtr next, global::System.IntPtr data, global::System.IntPtr key)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxNodeBase __result0;
            if (prev == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(prev))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[prev];
            else __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(prev, skipVTables: true);
            wxNodeBase __result1;
            if (next == IntPtr.Zero) __result1 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(next))
                __result1 = (wxNodeBase) wxNodeBase.NativeToManagedMap[next];
            else __result1 = (wxNodeBase) wxNodeBase.__CreateInstance(next, skipVTables: true);
            wxListKey __result3;
            if (key == IntPtr.Zero) __result3 = null;
            else if (wxListKey.NativeToManagedMap.ContainsKey(key))
                __result3 = (wxListKey) wxListKey.NativeToManagedMap[key];
            else __result3 = wxListKey.__CreateInstance(key);
            var __ret = __target.CreateNode(__result0, __result1, data, __result3);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // 
        private static Delegates.Func_IntPtr_IntPtr_IntPtr _Find_1DelegateInstance;

        private static global::System.IntPtr _Find_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr key)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxAnyList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxListKey __result0;
            if (key == IntPtr.Zero) __result0 = null;
            else if (wxListKey.NativeToManagedMap.ContainsKey(key))
                __result0 = (wxListKey) wxListKey.NativeToManagedMap[key];
            else __result0 = wxListKey.__CreateInstance(key);
            var __ret = __target.Find(__result0);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _CreateNode_0DelegateInstance += _CreateNode_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CreateNode_0DelegateInstance).ToPointer();
                _Find_1DelegateInstance += _Find_1DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Find_1DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    internal unsafe partial class wxAnyValueTypeInternal : wxAnyValueType, IDisposable
    {
        private static void* __CopyValue(wxAnyValueType.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            *(wxAnyValueType.Internal*) ret = native;
            return ret.ToPointer();
        }

        internal wxAnyValueTypeInternal(wxAnyValueType.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal wxAnyValueTypeInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
        }

        /// <summary>
        /// <para>        This function is used for internal type matching.</para>
        /// </summary>
        /// 
        public override bool IsSameType(wxAnyValueType otherType)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___IsSameType_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(otherType, null) ? global::System.IntPtr.Zero : otherType.__Instance;
            var __ret = ___IsSameType_0Delegate((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        /// <summary>
        /// <para>        This function is called every time the data in wxAny</para>
        /// </summary>
        /// <remarks>
        /// <para>        buffer needs to be freed.</para>
        /// </remarks>
        public override void DeleteValue(wxAnyValueBuffer buf)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
            var ___DeleteValue_0Delegate = (Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_IntPtr));
            var __arg0 = buf.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            ___DeleteValue_0Delegate((__Instance + __PointerAdjustment), arg0);
        }

        /// <summary>
        /// <para>        Implement this for buffer-to-buffer copy.</para>
        /// </summary>
        /// <remarks>
        /// <para>        </para>
        /// <para>        </para>
        /// </remarks>
        public override void CopyBuffer(wxAnyValueBuffer src, wxAnyValueBuffer dst)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 4);
            var ___CopyBuffer_0Delegate = (Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_IntPtr_IntPtr));
            var __arg0 = src.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            var __arg1 = dst.__Instance;
            var arg1 = new global::System.IntPtr(&__arg1);
            ___CopyBuffer_0Delegate((__Instance + __PointerAdjustment), arg0, arg1);
        }

        /// <summary>
        /// <para>        Convert value into buffer of different type. Return false if</para>
        /// </summary>
        /// <remarks>
        /// <para>        not possible.</para>
        /// </remarks>
        public override bool ConvertValue(wxAnyValueBuffer src, wxAnyValueType dstType, wxAnyValueBuffer dst)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
            var ___ConvertValue_0Delegate = (Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr_IntPtr_IntPtr_IntPtr));
            var __arg0 = src.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            var arg1 = ReferenceEquals(dstType, null) ? global::System.IntPtr.Zero : dstType.__Instance;
            var __arg2 = dst.__Instance;
            var arg2 = new global::System.IntPtr(&__arg2);
            var __ret = ___ConvertValue_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2);
            return __ret;
        }
    }

    public unsafe partial class any
    {
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z18wxAnyConvertStringRK8wxStringP14wxAnyValueTypeR16wxAnyValueBuffer")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool wxAnyConvertString_0(global::System.IntPtr value, global::System.IntPtr dstType, global::System.IntPtr dst);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z25wxPreRegisterAnyToVariantP26wxAnyToVariantRegistration")]
            internal static extern void wxPreRegisterAnyToVariant_0(global::System.IntPtr reg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z21wxConvertAnyToVariantRK5wxAnyP9wxVariant")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool wxConvertAnyToVariant_0(global::System.IntPtr any, global::System.IntPtr variant);
        }

        public static bool wxAnyConvertString(wxString value, wxAnyValueType dstType, wxAnyValueBuffer dst)
        {
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
            var arg0 = value.__Instance;
            var arg1 = ReferenceEquals(dstType, null) ? global::System.IntPtr.Zero : dstType.__Instance;
            var __arg2 = dst.__Instance;
            var arg2 = new global::System.IntPtr(&__arg2);
            var __ret = Internal.wxAnyConvertString_0(arg0, arg1, arg2);
            return __ret;
        }

        public static void wxPreRegisterAnyToVariant(wxAnyToVariantRegistration reg)
        {
            var arg0 = ReferenceEquals(reg, null) ? global::System.IntPtr.Zero : reg.__Instance;
            Internal.wxPreRegisterAnyToVariant_0(arg0);
        }

        public static bool wxConvertAnyToVariant(wxAny any, wxVariant variant)
        {
            if (ReferenceEquals(any, null))
                throw new global::System.ArgumentNullException("any", "Cannot be null because it is a C++ reference (&).");
            var arg0 = any.__Instance;
            var arg1 = ReferenceEquals(variant, null) ? global::System.IntPtr.Zero : variant.__Instance;
            var __ret = Internal.wxConvertAnyToVariant_0(arg0, arg1);
            return __ret;
        }
    }

    namespace wxPrivate
    {
        public unsafe static partial class wxAnyValueTypeOpsInplace
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        public unsafe static partial class wxAnyValueTypeOpsGeneric
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }

            public unsafe partial class DataHolder
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                }
            }
        }
    }
}
