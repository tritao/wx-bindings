//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace wxSharp
{
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int wxSortFuncFor_wxObjectList(global::System.IntPtr _0, global::System.IntPtr _1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int wxSortFuncFor_wxStringListBase(char** _0, char** _1);

    public unsafe partial struct wxListKeyValue
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public int integer;

            [FieldOffset(0)]
            public global::System.IntPtr @string;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14wxListKeyValueC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private wxListKeyValue.Internal __instance;
        public wxListKeyValue.Internal __Instance { get { return __instance; } }

        public static wxListKeyValue __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxListKeyValue(native.ToPointer(), skipVTables);
        }

        public static wxListKeyValue __CreateInstance(wxListKeyValue.Internal native, bool skipVTables = false)
        {
            return new wxListKeyValue(native, skipVTables);
        }

        private wxListKeyValue(wxListKeyValue.Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private wxListKeyValue(void* native, bool skipVTables = false) : this()
        {
            __instance = *(Internal*) native;
        }

        public wxListKeyValue(wxListKeyValue _0)
            : this()
        {
            var __arg0 = _0.__Instance;
            var arg0 = new global::System.IntPtr(&__arg0);
            fixed (Internal* __instancePtr = &__instance)
            {
                Internal.cctor_1(new global::System.IntPtr(__instancePtr), arg0);
            }
        }

        public int integer
        {
            get
            {
                return __instance.integer;
            }

            set
            {
                __instance.integer = value;
            }
        }

        public wxString @string
        {
            get
            {
                wxString __result0;
                if (__instance.@string == IntPtr.Zero) __result0 = null;
                else if (wxString.NativeToManagedMap.ContainsKey(__instance.@string))
                    __result0 = (wxString) wxString.NativeToManagedMap[__instance.@string];
                else __result0 = wxString.__CreateInstance(__instance.@string);
                return __result0;
            }

            set
            {
                __instance.@string = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class wxListKey : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public wxKeyType m_keyType;

            [FieldOffset(4)]
            public wxListKeyValue.Internal m_key;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxListKeyC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxListKeyC2El")]
            internal static extern void ctor_1(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxListKeyC2ERK8wxString")]
            internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxListKeyC2EPKc")]
            internal static extern void ctor_3(global::System.IntPtr instance, global::System.IntPtr s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxListKeyC2ERKS_")]
            internal static extern void cctor_5(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxListKeyD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxListKey10GetKeyTypeEv")]
            internal static extern wxKeyType GetKeyType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxListKey9GetStringEv")]
            internal static extern void GetString_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxListKey9GetNumberEv")]
            internal static extern int GetNumber_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9wxListKeyeqE14wxListKeyValue")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, wxListKeyValue.Internal value);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxListKey> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxListKey>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxListKey __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxListKey(native.ToPointer(), skipVTables);
        }

        public static wxListKey __CreateInstance(wxListKey.Internal native, bool skipVTables = false)
        {
            return new wxListKey(native, skipVTables);
        }

        private static void* __CopyValue(wxListKey.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            *(wxListKey.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxListKey(wxListKey.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxListKey(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxListKey()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public wxListKey(int i)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_1((__Instance + __PointerAdjustment), i);
        }

        public wxListKey(wxString s)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(s, null))
                throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
            var arg0 = s.__Instance;
            Internal.ctor_2((__Instance + __PointerAdjustment), arg0);
        }

        public wxListKey(string s)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = Marshal.StringToHGlobalAnsi(s);
            Internal.ctor_3((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
        }

        public wxListKey(wxListKey _0)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((wxListKey.Internal*) __Instance) = *((wxListKey.Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxListKey __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public wxKeyType GetKeyType()
        {
            var __ret = Internal.GetKeyType_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxString GetString()
        {
            var __ret = new wxString.Internal();
            Internal.GetString_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
            return wxString.__CreateInstance(__ret);
        }

        public int GetNumber()
        {
            var __ret = Internal.GetNumber_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public static bool operator !=(wxListKey __op, wxListKeyValue value)
        {
            return !(__op == value);
        }

        public static bool operator ==(wxListKey __op, wxListKeyValue value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var arg0 = __op.__Instance;
            var arg1 = value.__Instance;
            var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
            return __ret;
        }
    }

    public unsafe partial class wxNodeBase : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct Internal
        {
            [FieldOffset(4)]
            public wxListKeyValue.Internal m_key;

            [FieldOffset(8)]
            public global::System.IntPtr m_data;

            [FieldOffset(12)]
            public global::System.IntPtr m_next;

            [FieldOffset(16)]
            public global::System.IntPtr m_previous;

            [FieldOffset(20)]
            public global::System.IntPtr m_list;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxNodeBaseC2EP10wxListBasePS_S2_PvRK9wxListKey")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr list, global::System.IntPtr previous, global::System.IntPtr next, global::System.IntPtr data, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxNodeBase12GetKeyStringEv")]
            internal static extern void GetKeyString_0(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxNodeBase13GetKeyIntegerEv")]
            internal static extern int GetKeyInteger_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxNodeBase12SetKeyStringERK8wxString")]
            internal static extern void SetKeyString_0(global::System.IntPtr instance, global::System.IntPtr s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxNodeBase13SetKeyIntegerEl")]
            internal static extern void SetKeyInteger_0(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxNodeBase4NextEv")]
            internal static extern global::System.IntPtr Next_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxNodeBase8PreviousEv")]
            internal static extern global::System.IntPtr Previous_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxNodeBase4DataEv")]
            internal static extern global::System.IntPtr Data_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxNodeBase7GetNextEv")]
            internal static extern global::System.IntPtr GetNext_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxNodeBase11GetPreviousEv")]
            internal static extern global::System.IntPtr GetPrevious_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxNodeBase7GetDataEv")]
            internal static extern global::System.IntPtr GetData_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxNodeBase7SetDataEPv")]
            internal static extern void SetData_0(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxNodeBase7IndexOfEv")]
            internal static extern int IndexOf_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxNodeBase10GetDataPtrEv")]
            internal static extern void** GetDataPtr_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxNodeBase> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxNodeBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxNodeBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxNodeBase(native.ToPointer(), skipVTables);
        }

        public static wxNodeBase __CreateInstance(wxNodeBase.Internal native, bool skipVTables = false)
        {
            return new wxNodeBase(native, skipVTables);
        }

        private static void* __CopyValue(wxNodeBase.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            *(wxNodeBase.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxNodeBase(wxNodeBase.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxNodeBase(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxNodeBase(wxListBase list, wxNodeBase previous, wxNodeBase next, global::System.IntPtr data, wxListKey key)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = ReferenceEquals(list, null) ? global::System.IntPtr.Zero : list.__Instance;
            var arg1 = ReferenceEquals(previous, null) ? global::System.IntPtr.Zero : previous.__Instance;
            var arg2 = ReferenceEquals(next, null) ? global::System.IntPtr.Zero : next.__Instance;
            var arg3 = data;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg4 = key.__Instance;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3, arg4);
            SetupVTables(GetType().FullName == "wxSharp.wxNodeBase");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxNodeBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___dtor_0Delegate((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public wxString GetKeyString()
        {
            var __ret = new wxString.Internal();
            Internal.GetKeyString_0(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
            return wxString.__CreateInstance(__ret);
        }

        public int GetKeyInteger()
        {
            var __ret = Internal.GetKeyInteger_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void SetKeyString(wxString s)
        {
            if (ReferenceEquals(s, null))
                throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
            var arg0 = s.__Instance;
            Internal.SetKeyString_0((__Instance + __PointerAdjustment), arg0);
        }

        public void SetKeyInteger(int i)
        {
            Internal.SetKeyInteger_0((__Instance + __PointerAdjustment), i);
        }

        public wxObjectListNode Next()
        {
            var __ret = Internal.Next_0((__Instance + __PointerAdjustment));
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode Previous()
        {
            var __ret = Internal.Previous_0((__Instance + __PointerAdjustment));
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObject Data()
        {
            var __ret = Internal.Data_0((__Instance + __PointerAdjustment));
            wxObject __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObject.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObject) wxObject.NativeToManagedMap[__ret];
            else wxObject.NativeToManagedMap[__ret] = __result0 = (wxObject) wxObject.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase GetNext()
        {
            var __ret = Internal.GetNext_0((__Instance + __PointerAdjustment));
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase GetPrevious()
        {
            var __ret = Internal.GetPrevious_0((__Instance + __PointerAdjustment));
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected global::System.IntPtr GetData()
        {
            var __ret = Internal.GetData_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        protected void SetData(global::System.IntPtr data)
        {
            var arg0 = data;
            Internal.SetData_0((__Instance + __PointerAdjustment), arg0);
        }

        protected int IndexOf()
        {
            var __ret = Internal.IndexOf_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        protected virtual void DeleteData()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___DeleteData_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___DeleteData_0Delegate((__Instance + __PointerAdjustment));
        }

        public void** GetDataPtr()
        {
            var __ret = Internal.GetDataPtr_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        #region Virtual table interop

        // virtual ~wxNodeBase()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxNodeBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // void DeleteData()
        private static Delegates.Action_IntPtr _DeleteData_0DelegateInstance;

        private static void _DeleteData_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxNodeBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.DeleteData();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _DeleteData_0DelegateInstance += _DeleteData_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_DeleteData_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe abstract partial class wxListBase : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct Internal
        {
            [FieldOffset(4)]
            public uint m_count;

            [FieldOffset(8)]
            public byte m_destroy;

            [FieldOffset(12)]
            public global::System.IntPtr m_nodeFirst;

            [FieldOffset(16)]
            public global::System.IntPtr m_nodeLast;

            [FieldOffset(20)]
            public wxKeyType m_keyType;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBaseC2E9wxKeyType")]
            internal static extern void ctor_0(global::System.IntPtr instance, wxKeyType keyType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBaseC2EPvz")]
            internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBaseC2ERKS_")]
            internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBaseD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase8GetCountEv")]
            internal static extern uint GetCount_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase7IsEmptyEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsEmpty_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase5ClearEv")]
            internal static extern void Clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase14DeleteContentsEb")]
            internal static extern void DeleteContents_0(global::System.IntPtr instance, bool destroy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase17GetDeleteContentsEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetDeleteContents_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase10GetKeyTypeEv")]
            internal static extern wxKeyType GetKeyType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase10SetKeyTypeE9wxKeyType")]
            internal static extern void SetKeyType_0(global::System.IntPtr instance, wxKeyType keyType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase6NumberEv")]
            internal static extern int Number_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase5FirstEv")]
            internal static extern global::System.IntPtr First_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase4LastEv")]
            internal static extern global::System.IntPtr Last_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase3NthEm")]
            internal static extern global::System.IntPtr Nth_0(global::System.IntPtr instance, uint n);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBasecvR6wxListEv")]
            internal static extern global::System.IntPtr OperatorConversion_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase6AssignERKS_")]
            internal static extern void Assign_0(global::System.IntPtr instance, global::System.IntPtr list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase8GetFirstEv")]
            internal static extern global::System.IntPtr GetFirst_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase7GetLastEv")]
            internal static extern global::System.IntPtr GetLast_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase4ItemEm")]
            internal static extern global::System.IntPtr Item_0(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase7PrependEPv")]
            internal static extern global::System.IntPtr Prepend_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase6AppendEPv")]
            internal static extern global::System.IntPtr Append_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase6InsertEPv")]
            internal static extern global::System.IntPtr Insert_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase6InsertEmPv")]
            internal static extern global::System.IntPtr Insert_1(global::System.IntPtr instance, uint pos, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase6InsertEP10wxNodeBasePv")]
            internal static extern global::System.IntPtr Insert_2(global::System.IntPtr instance, global::System.IntPtr prev, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase6AppendElPv")]
            internal static extern global::System.IntPtr Append_1(global::System.IntPtr instance, int key, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase6AppendERK8wxStringPv")]
            internal static extern global::System.IntPtr Append_2(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase10DetachNodeEP10wxNodeBase")]
            internal static extern global::System.IntPtr DetachNode_0(global::System.IntPtr instance, global::System.IntPtr node);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase10DeleteNodeEP10wxNodeBase")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteNode_0(global::System.IntPtr instance, global::System.IntPtr node);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase12DeleteObjectEPv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteObject_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase4FindEPKv")]
            internal static extern global::System.IntPtr Find_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase4FindERK9wxListKey")]
            internal static extern global::System.IntPtr Find_1(global::System.IntPtr instance, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBase7IndexOfEPv")]
            internal static extern int IndexOf_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase4SortEPFiPKvS1_E")]
            internal static extern void Sort_0(global::System.IntPtr instance, global::System.IntPtr compfunc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase9FirstThatEPFiPvE")]
            internal static extern global::System.IntPtr FirstThat_0(global::System.IntPtr instance, global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase7ForEachEPFiPvE")]
            internal static extern void ForEach_0(global::System.IntPtr instance, global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase8LastThatEPFiPvE")]
            internal static extern global::System.IntPtr LastThat_0(global::System.IntPtr instance, global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase7ReverseEv")]
            internal static extern void Reverse_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxListBase11DeleteNodesEP10wxNodeBaseS1_")]
            internal static extern void DeleteNodes_0(global::System.IntPtr instance, global::System.IntPtr first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxListBaseixEm")]
            internal static extern global::System.IntPtr OperatorSubscript_0(global::System.IntPtr instance, uint n);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxListBase> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxListBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxListBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxListBaseInternal(native.ToPointer(), skipVTables);
        }

        public static wxListBase __CreateInstance(wxListBase.Internal native, bool skipVTables = false)
        {
            return new wxListBaseInternal(native, skipVTables);
        }

        protected wxListBase(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        protected wxListBase(wxKeyType keyType)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = keyType;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxListBase");
        }

        protected wxListBase(global::System.IntPtr @object)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = @object;
            Internal.ctor_2((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxListBase");
        }

        protected wxListBase(wxListBase _0)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_3((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxListBase");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxListBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            if (__slot != null)
            {
                var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
                ___dtor_0Delegate((__Instance + __PointerAdjustment));
            }
            else
                Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public uint GetCount()
        {
            var __ret = Internal.GetCount_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool IsEmpty()
        {
            var __ret = Internal.IsEmpty_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void Clear()
        {
            Internal.Clear_0((__Instance + __PointerAdjustment));
        }

        public void DeleteContents(bool destroy)
        {
            Internal.DeleteContents_0((__Instance + __PointerAdjustment), destroy);
        }

        public bool GetDeleteContents()
        {
            var __ret = Internal.GetDeleteContents_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxKeyType GetKeyType()
        {
            var __ret = Internal.GetKeyType_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void SetKeyType(wxKeyType keyType)
        {
            var arg0 = keyType;
            Internal.SetKeyType_0((__Instance + __PointerAdjustment), arg0);
        }

        public int Number()
        {
            var __ret = Internal.Number_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxObjectListNode First()
        {
            var __ret = Internal.First_0((__Instance + __PointerAdjustment));
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode Last()
        {
            var __ret = Internal.Last_0((__Instance + __PointerAdjustment));
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode Nth(uint n)
        {
            var __ret = Internal.Nth_0((__Instance + __PointerAdjustment), n);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public static implicit operator wxList(wxListBase __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var arg0 = __op.__Instance;
            var __ret = Internal.OperatorConversion_0(arg0);
            wxList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxList) wxList.NativeToManagedMap[__ret];
            else wxList.NativeToManagedMap[__ret] = __result0 = (wxList) wxList.__CreateInstance(__ret);
            return __result0;
        }

        protected abstract wxNodeBase CreateNode(wxNodeBase prev, wxNodeBase next, global::System.IntPtr data, wxListKey key);

        protected void Assign(wxListBase list)
        {
            if (ReferenceEquals(list, null))
                throw new global::System.ArgumentNullException("list", "Cannot be null because it is a C++ reference (&).");
            var arg0 = list.__Instance;
            Internal.Assign_0((__Instance + __PointerAdjustment), arg0);
        }

        protected wxNodeBase GetFirst()
        {
            var __ret = Internal.GetFirst_0((__Instance + __PointerAdjustment));
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase GetLast()
        {
            var __ret = Internal.GetLast_0((__Instance + __PointerAdjustment));
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase Item(uint index)
        {
            var __ret = Internal.Item_0((__Instance + __PointerAdjustment), index);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase Prepend(global::System.IntPtr @object)
        {
            var arg0 = @object;
            var __ret = Internal.Prepend_0((__Instance + __PointerAdjustment), arg0);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase Append(global::System.IntPtr @object)
        {
            var arg0 = @object;
            var __ret = Internal.Append_0((__Instance + __PointerAdjustment), arg0);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase Insert(global::System.IntPtr @object)
        {
            var arg0 = @object;
            var __ret = Internal.Insert_0((__Instance + __PointerAdjustment), arg0);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase Insert(uint pos, global::System.IntPtr @object)
        {
            var arg1 = @object;
            var __ret = Internal.Insert_1((__Instance + __PointerAdjustment), pos, arg1);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase Insert(wxNodeBase prev, global::System.IntPtr @object)
        {
            var arg0 = ReferenceEquals(prev, null) ? global::System.IntPtr.Zero : prev.__Instance;
            var arg1 = @object;
            var __ret = Internal.Insert_2((__Instance + __PointerAdjustment), arg0, arg1);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase Append(int key, global::System.IntPtr @object)
        {
            var arg1 = @object;
            var __ret = Internal.Append_1((__Instance + __PointerAdjustment), key, arg1);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase Append(wxString key, global::System.IntPtr @object)
        {
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg0 = key.__Instance;
            var arg1 = @object;
            var __ret = Internal.Append_2((__Instance + __PointerAdjustment), arg0, arg1);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase DetachNode(wxNodeBase node)
        {
            var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
            var __ret = Internal.DetachNode_0((__Instance + __PointerAdjustment), arg0);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected bool DeleteNode(wxNodeBase node)
        {
            var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
            var __ret = Internal.DeleteNode_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        protected bool DeleteObject(global::System.IntPtr @object)
        {
            var arg0 = @object;
            var __ret = Internal.DeleteObject_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        protected wxNodeBase Find(global::System.IntPtr @object)
        {
            var arg0 = @object;
            var __ret = Internal.Find_0((__Instance + __PointerAdjustment), arg0);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected wxNodeBase Find(wxListKey key)
        {
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg0 = key.__Instance;
            var __ret = Internal.Find_1((__Instance + __PointerAdjustment), arg0);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        protected int IndexOf(global::System.IntPtr @object)
        {
            var arg0 = @object;
            var __ret = Internal.IndexOf_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        protected void Sort(wxSortCompareFunction compfunc)
        {
            var arg0 = compfunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(compfunc);
            Internal.Sort_0((__Instance + __PointerAdjustment), arg0);
        }

        protected global::System.IntPtr FirstThat(wxListIterateFunction func)
        {
            var arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            var __ret = Internal.FirstThat_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        protected void ForEach(wxListIterateFunction func)
        {
            var arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            Internal.ForEach_0((__Instance + __PointerAdjustment), arg0);
        }

        protected global::System.IntPtr LastThat(wxListIterateFunction func)
        {
            var arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            var __ret = Internal.LastThat_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        protected void Reverse()
        {
            Internal.Reverse_0((__Instance + __PointerAdjustment));
        }

        protected void DeleteNodes(wxNodeBase first, wxNodeBase last)
        {
            var arg0 = ReferenceEquals(first, null) ? global::System.IntPtr.Zero : first.__Instance;
            var arg1 = ReferenceEquals(last, null) ? global::System.IntPtr.Zero : last.__Instance;
            Internal.DeleteNodes_0((__Instance + __PointerAdjustment), arg0, arg1);
        }

        protected global::System.IntPtr this[uint n]
        {
            get
            {
                var __ret = Internal.OperatorSubscript_0((__Instance + __PointerAdjustment), n);
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~wxListBase()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxListBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) = 0
        private static Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _CreateNode_0DelegateInstance;

        private static global::System.IntPtr _CreateNode_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr prev, global::System.IntPtr next, global::System.IntPtr data, global::System.IntPtr key)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxListBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxNodeBase __result0;
            if (prev == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(prev))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[prev];
            else __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(prev, skipVTables: true);
            wxNodeBase __result1;
            if (next == IntPtr.Zero) __result1 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(next))
                __result1 = (wxNodeBase) wxNodeBase.NativeToManagedMap[next];
            else __result1 = (wxNodeBase) wxNodeBase.__CreateInstance(next, skipVTables: true);
            wxListKey __result3;
            if (key == IntPtr.Zero) __result3 = null;
            else if (wxListKey.NativeToManagedMap.ContainsKey(key))
                __result3 = (wxListKey) wxListKey.NativeToManagedMap[key];
            else __result3 = wxListKey.__CreateInstance(key);
            var __ret = __target.CreateNode(__result0, __result1, data, __result3);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _CreateNode_0DelegateInstance += _CreateNode_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CreateNode_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxObjectListNode : wxNodeBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public wxListKeyValue.Internal m_key;

            [FieldOffset(8)]
            public global::System.IntPtr m_data;

            [FieldOffset(12)]
            public global::System.IntPtr m_next;

            [FieldOffset(16)]
            public global::System.IntPtr m_previous;

            [FieldOffset(20)]
            public global::System.IntPtr m_list;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxObjectListNodeC2EP10wxListBasePS_S2_P8wxObjectRK9wxListKey")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr list, global::System.IntPtr previous, global::System.IntPtr next, global::System.IntPtr data, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxObjectListNode7GetNextEv")]
            internal static extern global::System.IntPtr GetNext_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxObjectListNode11GetPreviousEv")]
            internal static extern global::System.IntPtr GetPrevious_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxObjectListNode7GetDataEv")]
            internal static extern global::System.IntPtr GetData_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxObjectListNode7SetDataEP8wxObject")]
            internal static extern void SetData_0(global::System.IntPtr instance, global::System.IntPtr data);
        }

        public static new wxObjectListNode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxObjectListNode(native.ToPointer(), skipVTables);
        }

        public static wxObjectListNode __CreateInstance(wxObjectListNode.Internal native, bool skipVTables = false)
        {
            return new wxObjectListNode(native, skipVTables);
        }

        private static void* __CopyValue(wxObjectListNode.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            *(wxObjectListNode.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxObjectListNode(wxObjectListNode.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxObjectListNode(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxObjectListNode(wxListBase list, wxObjectListNode previous, wxObjectListNode next, wxObject data, wxListKey key)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = ReferenceEquals(list, null) ? global::System.IntPtr.Zero : list.__Instance;
            var arg1 = ReferenceEquals(previous, null) ? global::System.IntPtr.Zero : previous.__Instance;
            var arg2 = ReferenceEquals(next, null) ? global::System.IntPtr.Zero : next.__Instance;
            var arg3 = ReferenceEquals(data, null) ? global::System.IntPtr.Zero : data.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg4 = key.__Instance;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3, arg4);
            SetupVTables(GetType().FullName == "wxSharp.wxObjectListNode");
        }

        public wxObjectListNode GetNext()
        {
            var __ret = Internal.GetNext_0((__Instance + __PointerAdjustment));
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode GetPrevious()
        {
            var __ret = Internal.GetPrevious_0((__Instance + __PointerAdjustment));
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObject GetData()
        {
            var __ret = Internal.GetData_0((__Instance + __PointerAdjustment));
            wxObject __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObject.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObject) wxObject.NativeToManagedMap[__ret];
            else wxObject.NativeToManagedMap[__ret] = __result0 = (wxObject) wxObject.__CreateInstance(__ret);
            return __result0;
        }

        public void SetData(wxObject data)
        {
            var arg0 = ReferenceEquals(data, null) ? global::System.IntPtr.Zero : data.__Instance;
            Internal.SetData_0((__Instance + __PointerAdjustment), arg0);
        }

        protected override void DeleteData()
        {
            base.DeleteData();
        }

        #region Virtual table interop

        // wxObjectListNode
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxObjectListNode) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Action_IntPtr _DeleteData_0DelegateInstance;

        private static void _DeleteData_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxObjectListNode) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.DeleteData();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _DeleteData_0DelegateInstance += _DeleteData_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_DeleteData_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxObjectList : wxListBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public uint m_count;

            [FieldOffset(8)]
            public byte m_destroy;

            [FieldOffset(12)]
            public global::System.IntPtr m_nodeFirst;

            [FieldOffset(16)]
            public global::System.IntPtr m_nodeLast;

            [FieldOffset(20)]
            public wxKeyType m_keyType;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectListC2E9wxKeyType")]
            internal static extern void ctor_0(global::System.IntPtr instance, wxKeyType keyType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectListC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectListC2EmRKP8wxObject")]
            internal static extern void ctor_3(global::System.IntPtr instance, uint n, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectListC2ERKNS_14const_iteratorES2_")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxObjectList8GetFirstEv")]
            internal static extern global::System.IntPtr GetFirst_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxObjectList7GetLastEv")]
            internal static extern global::System.IntPtr GetLast_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxObjectList4ItemEm")]
            internal static extern global::System.IntPtr Item_0(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6AppendEP8wxObject")]
            internal static extern global::System.IntPtr Append_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6InsertEP8wxObject")]
            internal static extern global::System.IntPtr Insert_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6InsertEmP8wxObject")]
            internal static extern global::System.IntPtr Insert_1(global::System.IntPtr instance, uint pos, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6InsertEP16wxObjectListNodeP8wxObject")]
            internal static extern global::System.IntPtr Insert_2(global::System.IntPtr instance, global::System.IntPtr prev, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6AppendElPv")]
            internal static extern global::System.IntPtr Append_1(global::System.IntPtr instance, int key, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6AppendEPKwPv")]
            internal static extern global::System.IntPtr Append_2(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList10DetachNodeEP16wxObjectListNode")]
            internal static extern global::System.IntPtr DetachNode_0(global::System.IntPtr instance, global::System.IntPtr node);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList10DeleteNodeEP16wxObjectListNode")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteNode_0(global::System.IntPtr instance, global::System.IntPtr node);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList12DeleteObjectEP8wxObject")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteObject_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList5EraseEP16wxObjectListNode")]
            internal static extern void Erase_0(global::System.IntPtr instance, global::System.IntPtr it);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxObjectList4FindEPK8wxObject")]
            internal static extern global::System.IntPtr Find_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxObjectList6MemberEPK8wxObject")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Member_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxObjectList7IndexOfEP8wxObject")]
            internal static extern int IndexOf_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList4SortEPFiPKvS1_E")]
            internal static extern void Sort_0(global::System.IntPtr instance, global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList4SortEPFiPPK8wxObjectS3_E")]
            internal static extern void Sort_1(global::System.IntPtr instance, global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList5beginEv")]
            internal static extern wxObjectList.iterator.Internal begin_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList3endEv")]
            internal static extern wxObjectList.iterator.Internal end_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6rbeginEv")]
            internal static extern wxObjectList.reverse_iterator.Internal rbegin_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList4rendEv")]
            internal static extern wxObjectList.reverse_iterator.Internal rend_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6resizeEmP8wxObject")]
            internal static extern void resize_0(global::System.IntPtr instance, uint n, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxObjectList4sizeEv")]
            internal static extern uint size_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxObjectList8max_sizeEv")]
            internal static extern uint max_size_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxObjectList5emptyEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool empty_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList5frontEv")]
            internal static extern global::System.IntPtr front_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList4backEv")]
            internal static extern global::System.IntPtr back_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList10push_frontERKP8wxObject")]
            internal static extern void push_front_0(global::System.IntPtr instance, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList9pop_frontEv")]
            internal static extern void pop_front_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList9push_backERKP8wxObject")]
            internal static extern void push_back_0(global::System.IntPtr instance, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList8pop_backEv")]
            internal static extern void pop_back_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6assignENS_14const_iteratorERKS0_")]
            internal static extern void assign_0(global::System.IntPtr instance, wxObjectList.const_iterator.Internal first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6assignEmRKP8wxObject")]
            internal static extern void assign_1(global::System.IntPtr instance, uint n, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6insertERKNS_8iteratorERKP8wxObject")]
            internal static extern wxObjectList.iterator.Internal insert_0(global::System.IntPtr instance, global::System.IntPtr it, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6insertERKNS_8iteratorEmRKP8wxObject")]
            internal static extern void insert_1(global::System.IntPtr instance, global::System.IntPtr it, uint n, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6insertERKNS_8iteratorENS_14const_iteratorERKS3_")]
            internal static extern void insert_2(global::System.IntPtr instance, global::System.IntPtr it, wxObjectList.const_iterator.Internal first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList5eraseERKNS_8iteratorE")]
            internal static extern wxObjectList.iterator.Internal erase_0(global::System.IntPtr instance, global::System.IntPtr it);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList5eraseERKNS_8iteratorES2_")]
            internal static extern wxObjectList.iterator.Internal erase_1(global::System.IntPtr instance, global::System.IntPtr first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList5clearEv")]
            internal static extern void clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6spliceERKNS_8iteratorERS_S2_S2_")]
            internal static extern void splice_0(global::System.IntPtr instance, global::System.IntPtr it, global::System.IntPtr l, global::System.IntPtr first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6spliceERKNS_8iteratorERS_")]
            internal static extern void splice_1(global::System.IntPtr instance, global::System.IntPtr it, global::System.IntPtr l);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6spliceERKNS_8iteratorERS_S2_")]
            internal static extern void splice_2(global::System.IntPtr instance, global::System.IntPtr it, global::System.IntPtr l, global::System.IntPtr first);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList6removeERKP8wxObject")]
            internal static extern void remove_0(global::System.IntPtr instance, global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxObjectList7reverseEv")]
            internal static extern void reverse_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxObjectListixEm")]
            internal static extern global::System.IntPtr OperatorSubscript_0(global::System.IntPtr instance, uint index);
        }

        public class value_type { }

        public class base_value_type { }

        public unsafe partial class compatibility_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_ptr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList22compatibility_iteratorC2EP16wxObjectListNode")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr ptr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList22compatibility_iteratorC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK12wxObjectList22compatibility_iteratorcvP16wxObjectListNodeEv")]
                internal static extern global::System.IntPtr OperatorConversion_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, compatibility_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, compatibility_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static compatibility_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new compatibility_iterator(native.ToPointer(), skipVTables);
            }

            public static compatibility_iterator __CreateInstance(compatibility_iterator.Internal native, bool skipVTables = false)
            {
                return new compatibility_iterator(native, skipVTables);
            }

            private static void* __CopyValue(compatibility_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(4);
                *(compatibility_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private compatibility_iterator(compatibility_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected compatibility_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public compatibility_iterator(wxObjectListNode ptr)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(ptr, null) ? global::System.IntPtr.Zero : ptr.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
            }

            public compatibility_iterator(wxObjectList.compatibility_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((compatibility_iterator.Internal*) __Instance) = *((compatibility_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxObjectList.compatibility_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static implicit operator wxObjectListNode(wxObjectList.compatibility_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorConversion_0(arg0);
                wxObjectListNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
                else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
                return __result0;
            }
        }

        public unsafe partial class iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList8iteratorC2EP16wxObjectListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList8iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList8iteratorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList8iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList8iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK12wxObjectList8iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK12wxObjectList8iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public class value_type { }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new iterator(native.ToPointer(), skipVTables);
            }

            public static iterator __CreateInstance(iterator.Internal native, bool skipVTables = false)
            {
                return new iterator(native, skipVTables);
            }

            private static void* __CopyValue(iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private iterator(iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public iterator(wxObjectListNode node, wxObjectListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public iterator(wxObjectList.iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((iterator.Internal*) __Instance) = *((iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxObjectList.iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxObjectList.iterator operator ++(wxObjectList.iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxObjectList.iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxObjectList.iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxObjectList.iterator) wxObjectList.iterator.NativeToManagedMap[__ret];
                else __result0 = wxObjectList.iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxObjectList.iterator operator --(wxObjectList.iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxObjectList.iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxObjectList.iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxObjectList.iterator) wxObjectList.iterator.NativeToManagedMap[__ret];
                else __result0 = wxObjectList.iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxObjectList.iterator __op, wxObjectList.iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxObjectList.iterator __op, wxObjectList.iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxObjectListNode m_node
            {
                get
                {
                    wxObjectListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxObjectListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxObjectListNode m_init
            {
                get
                {
                    wxObjectListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxObjectListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class const_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList14const_iteratorC2EP16wxObjectListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList14const_iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList14const_iteratorC2ERKNS_8iteratorE")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList14const_iteratorC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList14const_iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList14const_iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK12wxObjectList14const_iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK12wxObjectList14const_iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public class value_type { }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static const_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new const_iterator(native.ToPointer(), skipVTables);
            }

            public static const_iterator __CreateInstance(const_iterator.Internal native, bool skipVTables = false)
            {
                return new const_iterator(native, skipVTables);
            }

            private static void* __CopyValue(const_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(const_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private const_iterator(const_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected const_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public const_iterator(wxObjectListNode node, wxObjectListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public const_iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public const_iterator(wxObjectList.iterator it)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(it, null))
                    throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
                var arg0 = it.__Instance;
                Internal.ctor_2((__Instance + __PointerAdjustment), arg0);
            }

            public const_iterator(wxObjectList.const_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((const_iterator.Internal*) __Instance) = *((const_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxObjectList.const_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxObjectList.const_iterator operator ++(wxObjectList.const_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxObjectList.const_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxObjectList.const_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxObjectList.const_iterator) wxObjectList.const_iterator.NativeToManagedMap[__ret];
                else __result0 = wxObjectList.const_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxObjectList.const_iterator operator --(wxObjectList.const_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxObjectList.const_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxObjectList.const_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxObjectList.const_iterator) wxObjectList.const_iterator.NativeToManagedMap[__ret];
                else __result0 = wxObjectList.const_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxObjectList.const_iterator __op, wxObjectList.const_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxObjectList.const_iterator __op, wxObjectList.const_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as const_iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxObjectListNode m_node
            {
                get
                {
                    wxObjectListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxObjectListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxObjectListNode m_init
            {
                get
                {
                    wxObjectListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxObjectListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class reverse_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList16reverse_iteratorC2EP16wxObjectListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList16reverse_iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList16reverse_iteratorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList16reverse_iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList16reverse_iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK12wxObjectList16reverse_iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK12wxObjectList16reverse_iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public class value_type { }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, reverse_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, reverse_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static reverse_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new reverse_iterator(native.ToPointer(), skipVTables);
            }

            public static reverse_iterator __CreateInstance(reverse_iterator.Internal native, bool skipVTables = false)
            {
                return new reverse_iterator(native, skipVTables);
            }

            private static void* __CopyValue(reverse_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(reverse_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private reverse_iterator(reverse_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected reverse_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public reverse_iterator(wxObjectListNode node, wxObjectListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public reverse_iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public reverse_iterator(wxObjectList.reverse_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((reverse_iterator.Internal*) __Instance) = *((reverse_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxObjectList.reverse_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxObjectList.reverse_iterator operator ++(wxObjectList.reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxObjectList.reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxObjectList.reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxObjectList.reverse_iterator) wxObjectList.reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxObjectList.reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxObjectList.reverse_iterator operator --(wxObjectList.reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxObjectList.reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxObjectList.reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxObjectList.reverse_iterator) wxObjectList.reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxObjectList.reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxObjectList.reverse_iterator __op, wxObjectList.reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxObjectList.reverse_iterator __op, wxObjectList.reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as reverse_iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxObjectListNode m_node
            {
                get
                {
                    wxObjectListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxObjectListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxObjectListNode m_init
            {
                get
                {
                    wxObjectListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxObjectListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class const_reverse_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList22const_reverse_iteratorC2EP16wxObjectListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList22const_reverse_iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList22const_reverse_iteratorC2ERKNS_16reverse_iteratorE")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList22const_reverse_iteratorC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList22const_reverse_iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN12wxObjectList22const_reverse_iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK12wxObjectList22const_reverse_iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK12wxObjectList22const_reverse_iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public class value_type { }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_reverse_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_reverse_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static const_reverse_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new const_reverse_iterator(native.ToPointer(), skipVTables);
            }

            public static const_reverse_iterator __CreateInstance(const_reverse_iterator.Internal native, bool skipVTables = false)
            {
                return new const_reverse_iterator(native, skipVTables);
            }

            private static void* __CopyValue(const_reverse_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(const_reverse_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private const_reverse_iterator(const_reverse_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected const_reverse_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public const_reverse_iterator(wxObjectListNode node, wxObjectListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public const_reverse_iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public const_reverse_iterator(wxObjectList.reverse_iterator it)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(it, null))
                    throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
                var arg0 = it.__Instance;
                Internal.ctor_2((__Instance + __PointerAdjustment), arg0);
            }

            public const_reverse_iterator(wxObjectList.const_reverse_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((const_reverse_iterator.Internal*) __Instance) = *((const_reverse_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxObjectList.const_reverse_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxObjectList.const_reverse_iterator operator ++(wxObjectList.const_reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxObjectList.const_reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxObjectList.const_reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxObjectList.const_reverse_iterator) wxObjectList.const_reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxObjectList.const_reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxObjectList.const_reverse_iterator operator --(wxObjectList.const_reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxObjectList.const_reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxObjectList.const_reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxObjectList.const_reverse_iterator) wxObjectList.const_reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxObjectList.const_reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxObjectList.const_reverse_iterator __op, wxObjectList.const_reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxObjectList.const_reverse_iterator __op, wxObjectList.const_reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as const_reverse_iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxObjectListNode m_node
            {
                get
                {
                    wxObjectListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxObjectListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxObjectListNode m_init
            {
                get
                {
                    wxObjectListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxObjectListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxObjectListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public static new wxObjectList __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxObjectList(native.ToPointer(), skipVTables);
        }

        public static wxObjectList __CreateInstance(wxObjectList.Internal native, bool skipVTables = false)
        {
            return new wxObjectList(native, skipVTables);
        }

        private static void* __CopyValue(wxObjectList.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            wxObjectList.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxObjectList(wxObjectList.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxObjectList(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxObjectList(wxKeyType keyType)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = keyType;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxObjectList");
        }

        public wxObjectList(wxObjectList list)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(list, null))
                throw new global::System.ArgumentNullException("list", "Cannot be null because it is a C++ reference (&).");
            var arg0 = list.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxObjectList");
        }

        public wxObjectList(uint n, wxObject v)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg1 = v.__Instance;
            Internal.ctor_3((__Instance + __PointerAdjustment), n, arg1);
            SetupVTables(GetType().FullName == "wxSharp.wxObjectList");
        }

        public wxObjectList(wxObjectList.const_iterator first, wxObjectList.const_iterator last)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg0 = first.__Instance;
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg1 = last.__Instance;
            Internal.ctor_4((__Instance + __PointerAdjustment), arg0, arg1);
            SetupVTables(GetType().FullName == "wxSharp.wxObjectList");
        }

        public wxObjectListNode GetFirst()
        {
            var __ret = Internal.GetFirst_0((__Instance + __PointerAdjustment));
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode GetLast()
        {
            var __ret = Internal.GetLast_0((__Instance + __PointerAdjustment));
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode Item(uint index)
        {
            var __ret = Internal.Item_0((__Instance + __PointerAdjustment), index);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode Append(wxObject @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Append_0((__Instance + __PointerAdjustment), arg0);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode Insert(wxObject @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Insert_0((__Instance + __PointerAdjustment), arg0);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode Insert(uint pos, wxObject @object)
        {
            var arg1 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Insert_1((__Instance + __PointerAdjustment), pos, arg1);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode Insert(wxObjectListNode prev, wxObject @object)
        {
            var arg0 = ReferenceEquals(prev, null) ? global::System.IntPtr.Zero : prev.__Instance;
            var arg1 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Insert_2((__Instance + __PointerAdjustment), arg0, arg1);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode Append(int key, global::System.IntPtr @object)
        {
            var arg1 = @object;
            var __ret = Internal.Append_1((__Instance + __PointerAdjustment), key, arg1);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode Append(string key, global::System.IntPtr @object)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(key);
            var arg1 = @object;
            var __ret = Internal.Append_2((__Instance + __PointerAdjustment), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode DetachNode(wxObjectListNode node)
        {
            var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
            var __ret = Internal.DetachNode_0((__Instance + __PointerAdjustment), arg0);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public bool DeleteNode(wxObjectListNode node)
        {
            var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
            var __ret = Internal.DeleteNode_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public bool DeleteObject(wxObject @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.DeleteObject_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public void Erase(wxObjectListNode it)
        {
            var arg0 = ReferenceEquals(it, null) ? global::System.IntPtr.Zero : it.__Instance;
            Internal.Erase_0((__Instance + __PointerAdjustment), arg0);
        }

        public wxObjectListNode Find(wxObject @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Find_0((__Instance + __PointerAdjustment), arg0);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public virtual wxObjectListNode Find(wxListKey key)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
            var ___Find_1Delegate = (Delegates.Func_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg0 = key.__Instance;
            var __ret = ___Find_1Delegate((__Instance + __PointerAdjustment), arg0);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public bool Member(wxObject @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.Member_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public int IndexOf(wxObject @object)
        {
            var arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = Internal.IndexOf_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public void Sort(wxSortCompareFunction func)
        {
            var arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            Internal.Sort_0((__Instance + __PointerAdjustment), arg0);
        }

        public void Sort(wxSortFuncFor_wxObjectList func)
        {
            var arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            Internal.Sort_1((__Instance + __PointerAdjustment), arg0);
        }

        protected override wxNodeBase CreateNode(wxNodeBase prev, wxNodeBase next, global::System.IntPtr data, wxListKey key)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___CreateNode_0Delegate = (Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(prev, null) ? global::System.IntPtr.Zero : prev.__Instance;
            var arg1 = ReferenceEquals(next, null) ? global::System.IntPtr.Zero : next.__Instance;
            var arg2 = data;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg3 = key.__Instance;
            var __ret = ___CreateNode_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectList.iterator begin()
        {
            var __ret = Internal.begin_0((__Instance + __PointerAdjustment));
            return wxObjectList.iterator.__CreateInstance(__ret);
        }

        public wxObjectList.iterator end()
        {
            var __ret = Internal.end_0((__Instance + __PointerAdjustment));
            return wxObjectList.iterator.__CreateInstance(__ret);
        }

        public wxObjectList.reverse_iterator rbegin()
        {
            var __ret = Internal.rbegin_0((__Instance + __PointerAdjustment));
            return wxObjectList.reverse_iterator.__CreateInstance(__ret);
        }

        public wxObjectList.reverse_iterator rend()
        {
            var __ret = Internal.rend_0((__Instance + __PointerAdjustment));
            return wxObjectList.reverse_iterator.__CreateInstance(__ret);
        }

        public void resize(uint n, wxObject v)
        {
            var arg1 = ReferenceEquals(v, null) ? global::System.IntPtr.Zero : v.__Instance;
            Internal.resize_0((__Instance + __PointerAdjustment), n, arg1);
        }

        public uint size()
        {
            var __ret = Internal.size_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public uint max_size()
        {
            var __ret = Internal.max_size_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool empty()
        {
            var __ret = Internal.empty_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxObject front()
        {
            var __ret = Internal.front_0((__Instance + __PointerAdjustment));
            wxObject __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObject.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObject) wxObject.NativeToManagedMap[__ret];
            else wxObject.NativeToManagedMap[__ret] = __result0 = (wxObject) wxObject.__CreateInstance(__ret);
            return __result0;
        }

        public wxObject back()
        {
            var __ret = Internal.back_0((__Instance + __PointerAdjustment));
            wxObject __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObject.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObject) wxObject.NativeToManagedMap[__ret];
            else wxObject.NativeToManagedMap[__ret] = __result0 = (wxObject) wxObject.__CreateInstance(__ret);
            return __result0;
        }

        public void push_front(wxObject v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg0 = v.__Instance;
            Internal.push_front_0((__Instance + __PointerAdjustment), arg0);
        }

        public void pop_front()
        {
            Internal.pop_front_0((__Instance + __PointerAdjustment));
        }

        public void push_back(wxObject v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg0 = v.__Instance;
            Internal.push_back_0((__Instance + __PointerAdjustment), arg0);
        }

        public void pop_back()
        {
            Internal.pop_back_0((__Instance + __PointerAdjustment));
        }

        public void assign(wxObjectList.const_iterator first, wxObjectList.const_iterator last)
        {
            var arg0 = ReferenceEquals(first, null) ? new wxObjectList.const_iterator.Internal() : *(wxObjectList.const_iterator.Internal*) (first.__Instance);
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg1 = last.__Instance;
            Internal.assign_0((__Instance + __PointerAdjustment), arg0, arg1);
        }

        public void assign(uint n, wxObject v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg1 = v.__Instance;
            Internal.assign_1((__Instance + __PointerAdjustment), n, arg1);
        }

        public wxObjectList.iterator insert(wxObjectList.iterator it, wxObject v)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg1 = v.__Instance;
            var __ret = Internal.insert_0((__Instance + __PointerAdjustment), arg0, arg1);
            return wxObjectList.iterator.__CreateInstance(__ret);
        }

        public void insert(wxObjectList.iterator it, uint n, wxObject v)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg2 = v.__Instance;
            Internal.insert_1((__Instance + __PointerAdjustment), arg0, n, arg2);
        }

        public void insert(wxObjectList.iterator it, wxObjectList.const_iterator first, wxObjectList.const_iterator last)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            var arg1 = ReferenceEquals(first, null) ? new wxObjectList.const_iterator.Internal() : *(wxObjectList.const_iterator.Internal*) (first.__Instance);
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg2 = last.__Instance;
            Internal.insert_2((__Instance + __PointerAdjustment), arg0, arg1, arg2);
        }

        public wxObjectList.iterator erase(wxObjectList.iterator it)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            var __ret = Internal.erase_0((__Instance + __PointerAdjustment), arg0);
            return wxObjectList.iterator.__CreateInstance(__ret);
        }

        public wxObjectList.iterator erase(wxObjectList.iterator first, wxObjectList.iterator last)
        {
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg0 = first.__Instance;
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg1 = last.__Instance;
            var __ret = Internal.erase_1((__Instance + __PointerAdjustment), arg0, arg1);
            return wxObjectList.iterator.__CreateInstance(__ret);
        }

        public void clear()
        {
            Internal.clear_0((__Instance + __PointerAdjustment));
        }

        public void splice(wxObjectList.iterator it, wxObjectList l, wxObjectList.iterator first, wxObjectList.iterator last)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(l, null))
                throw new global::System.ArgumentNullException("l", "Cannot be null because it is a C++ reference (&).");
            var arg1 = l.__Instance;
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg2 = first.__Instance;
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg3 = last.__Instance;
            Internal.splice_0((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3);
        }

        public void splice(wxObjectList.iterator it, wxObjectList l)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(l, null))
                throw new global::System.ArgumentNullException("l", "Cannot be null because it is a C++ reference (&).");
            var arg1 = l.__Instance;
            Internal.splice_1((__Instance + __PointerAdjustment), arg0, arg1);
        }

        public void splice(wxObjectList.iterator it, wxObjectList l, wxObjectList.iterator first)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(l, null))
                throw new global::System.ArgumentNullException("l", "Cannot be null because it is a C++ reference (&).");
            var arg1 = l.__Instance;
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg2 = first.__Instance;
            Internal.splice_2((__Instance + __PointerAdjustment), arg0, arg1, arg2);
        }

        public void remove(wxObject v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is a C++ reference (&).");
            var arg0 = v.__Instance;
            Internal.remove_0((__Instance + __PointerAdjustment), arg0);
        }

        public void reverse()
        {
            Internal.reverse_0((__Instance + __PointerAdjustment));
        }

        public wxObject this[uint index]
        {
            get
            {
                var __ret = Internal.OperatorSubscript_0((__Instance + __PointerAdjustment), index);
                wxObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxObject) wxObject.NativeToManagedMap[__ret];
                else wxObject.NativeToManagedMap[__ret] = __result0 = (wxObject) wxObject.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                *(wxObject.Internal*) Internal.OperatorSubscript_0((__Instance + __PointerAdjustment), index) = *(wxObject.Internal*) value.__Instance;
            }
        }

        #region Virtual table interop

        // wxObjectList
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxObjectList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _CreateNode_0DelegateInstance;

        private static global::System.IntPtr _CreateNode_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr prev, global::System.IntPtr next, global::System.IntPtr data, global::System.IntPtr key)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxObjectList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxNodeBase __result0;
            if (prev == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(prev))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[prev];
            else __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(prev, skipVTables: true);
            wxNodeBase __result1;
            if (next == IntPtr.Zero) __result1 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(next))
                __result1 = (wxNodeBase) wxNodeBase.NativeToManagedMap[next];
            else __result1 = (wxNodeBase) wxNodeBase.__CreateInstance(next, skipVTables: true);
            wxListKey __result3;
            if (key == IntPtr.Zero) __result3 = null;
            else if (wxListKey.NativeToManagedMap.ContainsKey(key))
                __result3 = (wxListKey) wxListKey.NativeToManagedMap[key];
            else __result3 = wxListKey.__CreateInstance(key);
            var __ret = __target.CreateNode(__result0, __result1, data, __result3);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // 
        private static Delegates.Func_IntPtr_IntPtr_IntPtr _Find_1DelegateInstance;

        private static global::System.IntPtr _Find_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr key)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxObjectList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxListKey __result0;
            if (key == IntPtr.Zero) __result0 = null;
            else if (wxListKey.NativeToManagedMap.ContainsKey(key))
                __result0 = (wxListKey) wxListKey.NativeToManagedMap[key];
            else __result0 = wxListKey.__CreateInstance(key);
            var __ret = __target.Find(__result0);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _CreateNode_0DelegateInstance += _CreateNode_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CreateNode_0DelegateInstance).ToPointer();
                _Find_1DelegateInstance += _Find_1DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Find_1DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxList : wxObjectList, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public uint m_count;

            [FieldOffset(8)]
            public byte m_destroy;

            [FieldOffset(12)]
            public global::System.IntPtr m_nodeFirst;

            [FieldOffset(16)]
            public global::System.IntPtr m_nodeLast;

            [FieldOffset(20)]
            public wxKeyType m_keyType;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6wxListC2Ei")]
            internal static extern void ctor_0(global::System.IntPtr instance, int key_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6wxListC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN6wxList4SortEPFiPKvS1_E")]
            internal static extern void Sort_0(global::System.IntPtr instance, global::System.IntPtr compfunc);
        }

        public static new wxList __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxList(native.ToPointer(), skipVTables);
        }

        public static wxList __CreateInstance(wxList.Internal native, bool skipVTables = false)
        {
            return new wxList(native, skipVTables);
        }

        private static void* __CopyValue(wxList.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            wxList.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxList(wxList.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxList(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxList(int key_type)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment), key_type);
            SetupVTables(GetType().FullName == "wxSharp.wxList");
        }

        public wxList(wxList _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxList");
        }

        public void Sort(wxSortCompareFunction compfunc)
        {
            var arg0 = compfunc == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(compfunc);
            Internal.Sort_0((__Instance + __PointerAdjustment), arg0);
        }

        #region Virtual table interop

        // ~wxList()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _CreateNode_0DelegateInstance;

        private static global::System.IntPtr _CreateNode_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr prev, global::System.IntPtr next, global::System.IntPtr data, global::System.IntPtr key)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxNodeBase __result0;
            if (prev == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(prev))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[prev];
            else __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(prev, skipVTables: true);
            wxNodeBase __result1;
            if (next == IntPtr.Zero) __result1 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(next))
                __result1 = (wxNodeBase) wxNodeBase.NativeToManagedMap[next];
            else __result1 = (wxNodeBase) wxNodeBase.__CreateInstance(next, skipVTables: true);
            wxListKey __result3;
            if (key == IntPtr.Zero) __result3 = null;
            else if (wxListKey.NativeToManagedMap.ContainsKey(key))
                __result3 = (wxListKey) wxListKey.NativeToManagedMap[key];
            else __result3 = wxListKey.__CreateInstance(key);
            var __ret = __target.CreateNode(__result0, __result1, data, __result3);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // 
        private static Delegates.Func_IntPtr_IntPtr_IntPtr _Find_1DelegateInstance;

        private static global::System.IntPtr _Find_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr key)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxListKey __result0;
            if (key == IntPtr.Zero) __result0 = null;
            else if (wxListKey.NativeToManagedMap.ContainsKey(key))
                __result0 = (wxListKey) wxListKey.NativeToManagedMap[key];
            else __result0 = wxListKey.__CreateInstance(key);
            var __ret = __target.Find(__result0);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _CreateNode_0DelegateInstance += _CreateNode_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CreateNode_0DelegateInstance).ToPointer();
                _Find_1DelegateInstance += _Find_1DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Find_1DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxStringListNode : wxNodeBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public wxListKeyValue.Internal m_key;

            [FieldOffset(8)]
            public global::System.IntPtr m_data;

            [FieldOffset(12)]
            public global::System.IntPtr m_next;

            [FieldOffset(16)]
            public global::System.IntPtr m_previous;

            [FieldOffset(20)]
            public global::System.IntPtr m_list;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListNodeC2EP10wxListBasePS_S2_PwRK9wxListKey")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr list, global::System.IntPtr previous, global::System.IntPtr next, char* data, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListNode7GetNextEv")]
            internal static extern global::System.IntPtr GetNext_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListNode11GetPreviousEv")]
            internal static extern global::System.IntPtr GetPrevious_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListNode7GetDataEv")]
            internal static extern char* GetData_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListNode7SetDataEPw")]
            internal static extern void SetData_0(global::System.IntPtr instance, char* data);
        }

        public static new wxStringListNode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxStringListNode(native.ToPointer(), skipVTables);
        }

        public static wxStringListNode __CreateInstance(wxStringListNode.Internal native, bool skipVTables = false)
        {
            return new wxStringListNode(native, skipVTables);
        }

        private static void* __CopyValue(wxStringListNode.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            *(wxStringListNode.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxStringListNode(wxStringListNode.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxStringListNode(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxStringListNode(wxListBase list, wxStringListNode previous, wxStringListNode next, char* data, wxListKey key)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = ReferenceEquals(list, null) ? global::System.IntPtr.Zero : list.__Instance;
            var arg1 = ReferenceEquals(previous, null) ? global::System.IntPtr.Zero : previous.__Instance;
            var arg2 = ReferenceEquals(next, null) ? global::System.IntPtr.Zero : next.__Instance;
            var arg3 = data;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg4 = key.__Instance;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3, arg4);
            SetupVTables(GetType().FullName == "wxSharp.wxStringListNode");
        }

        public wxStringListNode GetNext()
        {
            var __ret = Internal.GetNext_0((__Instance + __PointerAdjustment));
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxStringListNode GetPrevious()
        {
            var __ret = Internal.GetPrevious_0((__Instance + __PointerAdjustment));
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public char* GetData()
        {
            var __ret = Internal.GetData_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void SetData(char* data)
        {
            var arg0 = data;
            Internal.SetData_0((__Instance + __PointerAdjustment), arg0);
        }

        protected override void DeleteData()
        {
            base.DeleteData();
        }

        #region Virtual table interop

        // wxStringListNode
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxStringListNode) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Action_IntPtr _DeleteData_0DelegateInstance;

        private static void _DeleteData_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxStringListNode) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.DeleteData();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _DeleteData_0DelegateInstance += _DeleteData_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_DeleteData_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxStringListBase : wxListBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public uint m_count;

            [FieldOffset(8)]
            public byte m_destroy;

            [FieldOffset(12)]
            public global::System.IntPtr m_nodeFirst;

            [FieldOffset(16)]
            public global::System.IntPtr m_nodeLast;

            [FieldOffset(20)]
            public wxKeyType m_keyType;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBaseC2E9wxKeyType")]
            internal static extern void ctor_0(global::System.IntPtr instance, wxKeyType keyType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBaseC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBaseC2EmRKPw")]
            internal static extern void ctor_3(global::System.IntPtr instance, uint n, char* v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBaseC2ERKNS_14const_iteratorES2_")]
            internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListBase8GetFirstEv")]
            internal static extern global::System.IntPtr GetFirst_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListBase7GetLastEv")]
            internal static extern global::System.IntPtr GetLast_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListBase4ItemEm")]
            internal static extern global::System.IntPtr Item_0(global::System.IntPtr instance, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6AppendEPw")]
            internal static extern global::System.IntPtr Append_0(global::System.IntPtr instance, char* @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6InsertEPw")]
            internal static extern global::System.IntPtr Insert_0(global::System.IntPtr instance, char* @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6InsertEmPw")]
            internal static extern global::System.IntPtr Insert_1(global::System.IntPtr instance, uint pos, char* @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6InsertEP16wxStringListNodePw")]
            internal static extern global::System.IntPtr Insert_2(global::System.IntPtr instance, global::System.IntPtr prev, char* @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6AppendElPv")]
            internal static extern global::System.IntPtr Append_1(global::System.IntPtr instance, int key, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6AppendEPKwPv")]
            internal static extern global::System.IntPtr Append_2(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase10DetachNodeEP16wxStringListNode")]
            internal static extern global::System.IntPtr DetachNode_0(global::System.IntPtr instance, global::System.IntPtr node);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase10DeleteNodeEP16wxStringListNode")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteNode_0(global::System.IntPtr instance, global::System.IntPtr node);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase12DeleteObjectEPw")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool DeleteObject_0(global::System.IntPtr instance, char* @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase5EraseEP16wxStringListNode")]
            internal static extern void Erase_0(global::System.IntPtr instance, global::System.IntPtr it);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListBase4FindEPKw")]
            internal static extern global::System.IntPtr Find_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListBase6MemberEPKw")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Member_0(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListBase7IndexOfEPw")]
            internal static extern int IndexOf_0(global::System.IntPtr instance, char* @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase4SortEPFiPKvS1_E")]
            internal static extern void Sort_0(global::System.IntPtr instance, global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase4SortEPFiPPKwS2_E")]
            internal static extern void Sort_1(global::System.IntPtr instance, global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase5beginEv")]
            internal static extern wxStringListBase.iterator.Internal begin_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase3endEv")]
            internal static extern wxStringListBase.iterator.Internal end_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6rbeginEv")]
            internal static extern wxStringListBase.reverse_iterator.Internal rbegin_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase4rendEv")]
            internal static extern wxStringListBase.reverse_iterator.Internal rend_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6resizeEmPw")]
            internal static extern void resize_0(global::System.IntPtr instance, uint n, char* v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListBase4sizeEv")]
            internal static extern uint size_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListBase8max_sizeEv")]
            internal static extern uint max_size_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListBase5emptyEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool empty_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase5frontEv")]
            internal static extern char* front_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase4backEv")]
            internal static extern char* back_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase10push_frontERKPw")]
            internal static extern void push_front_0(global::System.IntPtr instance, char* v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase9pop_frontEv")]
            internal static extern void pop_front_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase9push_backERKPw")]
            internal static extern void push_back_0(global::System.IntPtr instance, char* v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase8pop_backEv")]
            internal static extern void pop_back_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6assignENS_14const_iteratorERKS0_")]
            internal static extern void assign_0(global::System.IntPtr instance, wxStringListBase.const_iterator.Internal first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6assignEmRKPw")]
            internal static extern void assign_1(global::System.IntPtr instance, uint n, char* v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6insertERKNS_8iteratorERKPw")]
            internal static extern wxStringListBase.iterator.Internal insert_0(global::System.IntPtr instance, global::System.IntPtr it, char* v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6insertERKNS_8iteratorEmRKPw")]
            internal static extern void insert_1(global::System.IntPtr instance, global::System.IntPtr it, uint n, char* v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6insertERKNS_8iteratorENS_14const_iteratorERKS3_")]
            internal static extern void insert_2(global::System.IntPtr instance, global::System.IntPtr it, wxStringListBase.const_iterator.Internal first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase5eraseERKNS_8iteratorE")]
            internal static extern wxStringListBase.iterator.Internal erase_0(global::System.IntPtr instance, global::System.IntPtr it);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase5eraseERKNS_8iteratorES2_")]
            internal static extern wxStringListBase.iterator.Internal erase_1(global::System.IntPtr instance, global::System.IntPtr first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase5clearEv")]
            internal static extern void clear_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6spliceERKNS_8iteratorERS_S2_S2_")]
            internal static extern void splice_0(global::System.IntPtr instance, global::System.IntPtr it, global::System.IntPtr l, global::System.IntPtr first, global::System.IntPtr last);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6spliceERKNS_8iteratorERS_")]
            internal static extern void splice_1(global::System.IntPtr instance, global::System.IntPtr it, global::System.IntPtr l);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6spliceERKNS_8iteratorERS_S2_")]
            internal static extern void splice_2(global::System.IntPtr instance, global::System.IntPtr it, global::System.IntPtr l, global::System.IntPtr first);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase6removeERKPw")]
            internal static extern void remove_0(global::System.IntPtr instance, char* v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxStringListBase7reverseEv")]
            internal static extern void reverse_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK16wxStringListBaseixEm")]
            internal static extern char* OperatorSubscript_0(global::System.IntPtr instance, uint index);
        }

        public unsafe partial class compatibility_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_ptr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase22compatibility_iteratorC2EP16wxStringListNode")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr ptr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase22compatibility_iteratorC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK16wxStringListBase22compatibility_iteratorcvP16wxStringListNodeEv")]
                internal static extern global::System.IntPtr OperatorConversion_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, compatibility_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, compatibility_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static compatibility_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new compatibility_iterator(native.ToPointer(), skipVTables);
            }

            public static compatibility_iterator __CreateInstance(compatibility_iterator.Internal native, bool skipVTables = false)
            {
                return new compatibility_iterator(native, skipVTables);
            }

            private static void* __CopyValue(compatibility_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(4);
                *(compatibility_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private compatibility_iterator(compatibility_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected compatibility_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public compatibility_iterator(wxStringListNode ptr)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(ptr, null) ? global::System.IntPtr.Zero : ptr.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
            }

            public compatibility_iterator(wxStringListBase.compatibility_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((compatibility_iterator.Internal*) __Instance) = *((compatibility_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxStringListBase.compatibility_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static implicit operator wxStringListNode(wxStringListBase.compatibility_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorConversion_0(arg0);
                wxStringListNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
                else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
                return __result0;
            }
        }

        public unsafe partial class iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase8iteratorC2EP16wxStringListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase8iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase8iteratorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase8iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase8iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK16wxStringListBase8iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK16wxStringListBase8iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new iterator(native.ToPointer(), skipVTables);
            }

            public static iterator __CreateInstance(iterator.Internal native, bool skipVTables = false)
            {
                return new iterator(native, skipVTables);
            }

            private static void* __CopyValue(iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private iterator(iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public iterator(wxStringListNode node, wxStringListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public iterator(wxStringListBase.iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((iterator.Internal*) __Instance) = *((iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxStringListBase.iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxStringListBase.iterator operator ++(wxStringListBase.iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxStringListBase.iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxStringListBase.iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxStringListBase.iterator) wxStringListBase.iterator.NativeToManagedMap[__ret];
                else __result0 = wxStringListBase.iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxStringListBase.iterator operator --(wxStringListBase.iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxStringListBase.iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxStringListBase.iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxStringListBase.iterator) wxStringListBase.iterator.NativeToManagedMap[__ret];
                else __result0 = wxStringListBase.iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxStringListBase.iterator __op, wxStringListBase.iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxStringListBase.iterator __op, wxStringListBase.iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxStringListNode m_node
            {
                get
                {
                    wxStringListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxStringListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxStringListNode m_init
            {
                get
                {
                    wxStringListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxStringListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class const_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase14const_iteratorC2EP16wxStringListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase14const_iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase14const_iteratorC2ERKNS_8iteratorE")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase14const_iteratorC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase14const_iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase14const_iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK16wxStringListBase14const_iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK16wxStringListBase14const_iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static const_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new const_iterator(native.ToPointer(), skipVTables);
            }

            public static const_iterator __CreateInstance(const_iterator.Internal native, bool skipVTables = false)
            {
                return new const_iterator(native, skipVTables);
            }

            private static void* __CopyValue(const_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(const_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private const_iterator(const_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected const_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public const_iterator(wxStringListNode node, wxStringListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public const_iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public const_iterator(wxStringListBase.iterator it)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(it, null))
                    throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
                var arg0 = it.__Instance;
                Internal.ctor_2((__Instance + __PointerAdjustment), arg0);
            }

            public const_iterator(wxStringListBase.const_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((const_iterator.Internal*) __Instance) = *((const_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxStringListBase.const_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxStringListBase.const_iterator operator ++(wxStringListBase.const_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxStringListBase.const_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxStringListBase.const_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxStringListBase.const_iterator) wxStringListBase.const_iterator.NativeToManagedMap[__ret];
                else __result0 = wxStringListBase.const_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxStringListBase.const_iterator operator --(wxStringListBase.const_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxStringListBase.const_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxStringListBase.const_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxStringListBase.const_iterator) wxStringListBase.const_iterator.NativeToManagedMap[__ret];
                else __result0 = wxStringListBase.const_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxStringListBase.const_iterator __op, wxStringListBase.const_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxStringListBase.const_iterator __op, wxStringListBase.const_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as const_iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxStringListNode m_node
            {
                get
                {
                    wxStringListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxStringListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxStringListNode m_init
            {
                get
                {
                    wxStringListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxStringListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class reverse_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase16reverse_iteratorC2EP16wxStringListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase16reverse_iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase16reverse_iteratorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase16reverse_iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase16reverse_iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK16wxStringListBase16reverse_iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK16wxStringListBase16reverse_iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, reverse_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, reverse_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static reverse_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new reverse_iterator(native.ToPointer(), skipVTables);
            }

            public static reverse_iterator __CreateInstance(reverse_iterator.Internal native, bool skipVTables = false)
            {
                return new reverse_iterator(native, skipVTables);
            }

            private static void* __CopyValue(reverse_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(reverse_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private reverse_iterator(reverse_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected reverse_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public reverse_iterator(wxStringListNode node, wxStringListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public reverse_iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public reverse_iterator(wxStringListBase.reverse_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((reverse_iterator.Internal*) __Instance) = *((reverse_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxStringListBase.reverse_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxStringListBase.reverse_iterator operator ++(wxStringListBase.reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxStringListBase.reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxStringListBase.reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxStringListBase.reverse_iterator) wxStringListBase.reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxStringListBase.reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxStringListBase.reverse_iterator operator --(wxStringListBase.reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxStringListBase.reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxStringListBase.reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxStringListBase.reverse_iterator) wxStringListBase.reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxStringListBase.reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxStringListBase.reverse_iterator __op, wxStringListBase.reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxStringListBase.reverse_iterator __op, wxStringListBase.reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as reverse_iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxStringListNode m_node
            {
                get
                {
                    wxStringListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxStringListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxStringListNode m_init
            {
                get
                {
                    wxStringListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxStringListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class const_reverse_iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr m_node;

                [FieldOffset(4)]
                public global::System.IntPtr m_init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase22const_reverse_iteratorC2EP16wxStringListNodeS2_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase22const_reverse_iteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase22const_reverse_iteratorC2ERKNS_16reverse_iteratorE")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase22const_reverse_iteratorC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase22const_reverse_iteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN16wxStringListBase22const_reverse_iteratormmEv")]
                internal static extern global::System.IntPtr OperatorMinusMinus_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK16wxStringListBase22const_reverse_iteratorneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr it);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK16wxStringListBase22const_reverse_iteratoreqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr it);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_reverse_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, const_reverse_iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static const_reverse_iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new const_reverse_iterator(native.ToPointer(), skipVTables);
            }

            public static const_reverse_iterator __CreateInstance(const_reverse_iterator.Internal native, bool skipVTables = false)
            {
                return new const_reverse_iterator(native, skipVTables);
            }

            private static void* __CopyValue(const_reverse_iterator.Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(const_reverse_iterator.Internal*) ret = native;
                return ret.ToPointer();
            }

            private const_reverse_iterator(const_reverse_iterator.Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected const_reverse_iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public const_reverse_iterator(wxStringListNode node, wxStringListNode init)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var arg1 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            }

            public const_reverse_iterator()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            public const_reverse_iterator(wxStringListBase.reverse_iterator it)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(it, null))
                    throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
                var arg0 = it.__Instance;
                Internal.ctor_2((__Instance + __PointerAdjustment), arg0);
            }

            public const_reverse_iterator(wxStringListBase.const_reverse_iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((const_reverse_iterator.Internal*) __Instance) = *((const_reverse_iterator.Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                wxStringListBase.const_reverse_iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static wxStringListBase.const_reverse_iterator operator ++(wxStringListBase.const_reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                wxStringListBase.const_reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxStringListBase.const_reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxStringListBase.const_reverse_iterator) wxStringListBase.const_reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxStringListBase.const_reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static wxStringListBase.const_reverse_iterator operator --(wxStringListBase.const_reverse_iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var arg0 = __op.__Instance;
                var __ret = Internal.OperatorMinusMinus_0(arg0);
                wxStringListBase.const_reverse_iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (wxStringListBase.const_reverse_iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (wxStringListBase.const_reverse_iterator) wxStringListBase.const_reverse_iterator.NativeToManagedMap[__ret];
                else __result0 = wxStringListBase.const_reverse_iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator !=(wxStringListBase.const_reverse_iterator __op, wxStringListBase.const_reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return !(__opNull && itNull);
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator ==(wxStringListBase.const_reverse_iterator __op, wxStringListBase.const_reverse_iterator it)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool itNull = ReferenceEquals(it, null);
                if (__opNull || itNull)
                    return __opNull && itNull;
                var arg0 = __op.__Instance;
                var arg1 = it.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as const_reverse_iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(Internal*) __Instance).GetHashCode();
            }

            public wxStringListNode m_node
            {
                get
                {
                    wxStringListNode __result0;
                    if (((Internal*) __Instance)->m_node == IntPtr.Zero) __result0 = null;
                    else if (wxStringListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_node))
                        __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_node];
                    else wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_node] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(((Internal*) __Instance)->m_node);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_node = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public wxStringListNode m_init
            {
                get
                {
                    wxStringListNode __result0;
                    if (((Internal*) __Instance)->m_init == IntPtr.Zero) __result0 = null;
                    else if (wxStringListNode.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_init))
                        __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_init];
                    else wxStringListNode.NativeToManagedMap[((Internal*) __Instance)->m_init] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(((Internal*) __Instance)->m_init);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->m_init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public static new wxStringListBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxStringListBase(native.ToPointer(), skipVTables);
        }

        public static wxStringListBase __CreateInstance(wxStringListBase.Internal native, bool skipVTables = false)
        {
            return new wxStringListBase(native, skipVTables);
        }

        private static void* __CopyValue(wxStringListBase.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            wxStringListBase.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxStringListBase(wxStringListBase.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxStringListBase(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxStringListBase(wxKeyType keyType)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = keyType;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxStringListBase");
        }

        public wxStringListBase(wxStringListBase list)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(list, null))
                throw new global::System.ArgumentNullException("list", "Cannot be null because it is a C++ reference (&).");
            var arg0 = list.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxStringListBase");
        }

        public wxStringListBase(uint n, char* v)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg1 = v;
            Internal.ctor_3((__Instance + __PointerAdjustment), n, arg1);
            SetupVTables(GetType().FullName == "wxSharp.wxStringListBase");
        }

        public wxStringListBase(wxStringListBase.const_iterator first, wxStringListBase.const_iterator last)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg0 = first.__Instance;
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg1 = last.__Instance;
            Internal.ctor_4((__Instance + __PointerAdjustment), arg0, arg1);
            SetupVTables(GetType().FullName == "wxSharp.wxStringListBase");
        }

        public wxStringListNode GetFirst()
        {
            var __ret = Internal.GetFirst_0((__Instance + __PointerAdjustment));
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxStringListNode GetLast()
        {
            var __ret = Internal.GetLast_0((__Instance + __PointerAdjustment));
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxStringListNode Item(uint index)
        {
            var __ret = Internal.Item_0((__Instance + __PointerAdjustment), index);
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxStringListNode Append(char* @object)
        {
            var arg0 = @object;
            var __ret = Internal.Append_0((__Instance + __PointerAdjustment), arg0);
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxStringListNode Insert(char* @object)
        {
            var arg0 = @object;
            var __ret = Internal.Insert_0((__Instance + __PointerAdjustment), arg0);
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxStringListNode Insert(uint pos, char* @object)
        {
            var arg1 = @object;
            var __ret = Internal.Insert_1((__Instance + __PointerAdjustment), pos, arg1);
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxStringListNode Insert(wxStringListNode prev, char* @object)
        {
            var arg0 = ReferenceEquals(prev, null) ? global::System.IntPtr.Zero : prev.__Instance;
            var arg1 = @object;
            var __ret = Internal.Insert_2((__Instance + __PointerAdjustment), arg0, arg1);
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxStringListNode Append(int key, global::System.IntPtr @object)
        {
            var arg1 = @object;
            var __ret = Internal.Append_1((__Instance + __PointerAdjustment), key, arg1);
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxStringListNode Append(string key, global::System.IntPtr @object)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(key);
            var arg1 = @object;
            var __ret = Internal.Append_2((__Instance + __PointerAdjustment), arg0, arg1);
            Marshal.FreeHGlobal(arg0);
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxStringListNode DetachNode(wxStringListNode node)
        {
            var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
            var __ret = Internal.DetachNode_0((__Instance + __PointerAdjustment), arg0);
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public bool DeleteNode(wxStringListNode node)
        {
            var arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
            var __ret = Internal.DeleteNode_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public bool DeleteObject(char* @object)
        {
            var arg0 = @object;
            var __ret = Internal.DeleteObject_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public void Erase(wxStringListNode it)
        {
            var arg0 = ReferenceEquals(it, null) ? global::System.IntPtr.Zero : it.__Instance;
            Internal.Erase_0((__Instance + __PointerAdjustment), arg0);
        }

        public wxStringListNode Find(string @object)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(@object);
            var __ret = Internal.Find_0((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public virtual wxStringListNode Find(wxListKey key)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
            var ___Find_1Delegate = (Delegates.Func_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg0 = key.__Instance;
            var __ret = ___Find_1Delegate((__Instance + __PointerAdjustment), arg0);
            wxStringListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxStringListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxStringListNode) wxStringListNode.NativeToManagedMap[__ret];
            else wxStringListNode.NativeToManagedMap[__ret] = __result0 = (wxStringListNode) wxStringListNode.__CreateInstance(__ret);
            return __result0;
        }

        public bool Member(string @object)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(@object);
            var __ret = Internal.Member_0((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public int IndexOf(char* @object)
        {
            var arg0 = @object;
            var __ret = Internal.IndexOf_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public void Sort(wxSortCompareFunction func)
        {
            var arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            Internal.Sort_0((__Instance + __PointerAdjustment), arg0);
        }

        public void Sort(wxSortFuncFor_wxStringListBase func)
        {
            var arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            Internal.Sort_1((__Instance + __PointerAdjustment), arg0);
        }

        protected override wxNodeBase CreateNode(wxNodeBase prev, wxNodeBase next, global::System.IntPtr data, wxListKey key)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___CreateNode_0Delegate = (Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(prev, null) ? global::System.IntPtr.Zero : prev.__Instance;
            var arg1 = ReferenceEquals(next, null) ? global::System.IntPtr.Zero : next.__Instance;
            var arg2 = data;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg3 = key.__Instance;
            var __ret = ___CreateNode_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }

        public wxStringListBase.iterator begin()
        {
            var __ret = Internal.begin_0((__Instance + __PointerAdjustment));
            return wxStringListBase.iterator.__CreateInstance(__ret);
        }

        public wxStringListBase.iterator end()
        {
            var __ret = Internal.end_0((__Instance + __PointerAdjustment));
            return wxStringListBase.iterator.__CreateInstance(__ret);
        }

        public wxStringListBase.reverse_iterator rbegin()
        {
            var __ret = Internal.rbegin_0((__Instance + __PointerAdjustment));
            return wxStringListBase.reverse_iterator.__CreateInstance(__ret);
        }

        public wxStringListBase.reverse_iterator rend()
        {
            var __ret = Internal.rend_0((__Instance + __PointerAdjustment));
            return wxStringListBase.reverse_iterator.__CreateInstance(__ret);
        }

        public void resize(uint n, char* v)
        {
            var arg1 = v;
            Internal.resize_0((__Instance + __PointerAdjustment), n, arg1);
        }

        public uint size()
        {
            var __ret = Internal.size_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public uint max_size()
        {
            var __ret = Internal.max_size_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool empty()
        {
            var __ret = Internal.empty_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public char* front()
        {
            var __ret = Internal.front_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public char* back()
        {
            var __ret = Internal.back_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void push_front(char* v)
        {
            var arg0 = v;
            Internal.push_front_0((__Instance + __PointerAdjustment), arg0);
        }

        public void pop_front()
        {
            Internal.pop_front_0((__Instance + __PointerAdjustment));
        }

        public void push_back(char* v)
        {
            var arg0 = v;
            Internal.push_back_0((__Instance + __PointerAdjustment), arg0);
        }

        public void pop_back()
        {
            Internal.pop_back_0((__Instance + __PointerAdjustment));
        }

        public void assign(wxStringListBase.const_iterator first, wxStringListBase.const_iterator last)
        {
            var arg0 = ReferenceEquals(first, null) ? new wxStringListBase.const_iterator.Internal() : *(wxStringListBase.const_iterator.Internal*) (first.__Instance);
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg1 = last.__Instance;
            Internal.assign_0((__Instance + __PointerAdjustment), arg0, arg1);
        }

        public void assign(uint n, char* v)
        {
            var arg1 = v;
            Internal.assign_1((__Instance + __PointerAdjustment), n, arg1);
        }

        public wxStringListBase.iterator insert(wxStringListBase.iterator it, char* v)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            var arg1 = v;
            var __ret = Internal.insert_0((__Instance + __PointerAdjustment), arg0, arg1);
            return wxStringListBase.iterator.__CreateInstance(__ret);
        }

        public void insert(wxStringListBase.iterator it, uint n, char* v)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            var arg2 = v;
            Internal.insert_1((__Instance + __PointerAdjustment), arg0, n, arg2);
        }

        public void insert(wxStringListBase.iterator it, wxStringListBase.const_iterator first, wxStringListBase.const_iterator last)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            var arg1 = ReferenceEquals(first, null) ? new wxStringListBase.const_iterator.Internal() : *(wxStringListBase.const_iterator.Internal*) (first.__Instance);
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg2 = last.__Instance;
            Internal.insert_2((__Instance + __PointerAdjustment), arg0, arg1, arg2);
        }

        public wxStringListBase.iterator erase(wxStringListBase.iterator it)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            var __ret = Internal.erase_0((__Instance + __PointerAdjustment), arg0);
            return wxStringListBase.iterator.__CreateInstance(__ret);
        }

        public wxStringListBase.iterator erase(wxStringListBase.iterator first, wxStringListBase.iterator last)
        {
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg0 = first.__Instance;
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg1 = last.__Instance;
            var __ret = Internal.erase_1((__Instance + __PointerAdjustment), arg0, arg1);
            return wxStringListBase.iterator.__CreateInstance(__ret);
        }

        public void clear()
        {
            Internal.clear_0((__Instance + __PointerAdjustment));
        }

        public void splice(wxStringListBase.iterator it, wxStringListBase l, wxStringListBase.iterator first, wxStringListBase.iterator last)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(l, null))
                throw new global::System.ArgumentNullException("l", "Cannot be null because it is a C++ reference (&).");
            var arg1 = l.__Instance;
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg2 = first.__Instance;
            if (ReferenceEquals(last, null))
                throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
            var arg3 = last.__Instance;
            Internal.splice_0((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3);
        }

        public void splice(wxStringListBase.iterator it, wxStringListBase l)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(l, null))
                throw new global::System.ArgumentNullException("l", "Cannot be null because it is a C++ reference (&).");
            var arg1 = l.__Instance;
            Internal.splice_1((__Instance + __PointerAdjustment), arg0, arg1);
        }

        public void splice(wxStringListBase.iterator it, wxStringListBase l, wxStringListBase.iterator first)
        {
            if (ReferenceEquals(it, null))
                throw new global::System.ArgumentNullException("it", "Cannot be null because it is a C++ reference (&).");
            var arg0 = it.__Instance;
            if (ReferenceEquals(l, null))
                throw new global::System.ArgumentNullException("l", "Cannot be null because it is a C++ reference (&).");
            var arg1 = l.__Instance;
            if (ReferenceEquals(first, null))
                throw new global::System.ArgumentNullException("first", "Cannot be null because it is a C++ reference (&).");
            var arg2 = first.__Instance;
            Internal.splice_2((__Instance + __PointerAdjustment), arg0, arg1, arg2);
        }

        public void remove(char* v)
        {
            var arg0 = v;
            Internal.remove_0((__Instance + __PointerAdjustment), arg0);
        }

        public void reverse()
        {
            Internal.reverse_0((__Instance + __PointerAdjustment));
        }

        public char this[uint index]
        {
            get
            {
                var __ret = Internal.OperatorSubscript_0((__Instance + __PointerAdjustment), index);
                return *__ret;
            }

            set
            {
                *Internal.OperatorSubscript_0((__Instance + __PointerAdjustment), index) = value;
            }
        }

        #region Virtual table interop

        // wxStringListBase
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxStringListBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _CreateNode_0DelegateInstance;

        private static global::System.IntPtr _CreateNode_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr prev, global::System.IntPtr next, global::System.IntPtr data, global::System.IntPtr key)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxStringListBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxNodeBase __result0;
            if (prev == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(prev))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[prev];
            else __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(prev, skipVTables: true);
            wxNodeBase __result1;
            if (next == IntPtr.Zero) __result1 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(next))
                __result1 = (wxNodeBase) wxNodeBase.NativeToManagedMap[next];
            else __result1 = (wxNodeBase) wxNodeBase.__CreateInstance(next, skipVTables: true);
            wxListKey __result3;
            if (key == IntPtr.Zero) __result3 = null;
            else if (wxListKey.NativeToManagedMap.ContainsKey(key))
                __result3 = (wxListKey) wxListKey.NativeToManagedMap[key];
            else __result3 = wxListKey.__CreateInstance(key);
            var __ret = __target.CreateNode(__result0, __result1, data, __result3);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // 
        private static Delegates.Func_IntPtr_IntPtr_IntPtr _Find_1DelegateInstance;

        private static global::System.IntPtr _Find_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr key)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxStringListBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxListKey __result0;
            if (key == IntPtr.Zero) __result0 = null;
            else if (wxListKey.NativeToManagedMap.ContainsKey(key))
                __result0 = (wxListKey) wxListKey.NativeToManagedMap[key];
            else __result0 = wxListKey.__CreateInstance(key);
            var __ret = __target.Find(__result0);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _CreateNode_0DelegateInstance += _CreateNode_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CreateNode_0DelegateInstance).ToPointer();
                _Find_1DelegateInstance += _Find_1DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Find_1DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxStringList : wxStringListBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public uint m_count;

            [FieldOffset(8)]
            public byte m_destroy;

            [FieldOffset(12)]
            public global::System.IntPtr m_nodeFirst;

            [FieldOffset(16)]
            public global::System.IntPtr m_nodeLast;

            [FieldOffset(20)]
            public wxKeyType m_keyType;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxStringListC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxStringListC2EPKwz")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr first);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxStringListC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxStringList3AddEPKw")]
            internal static extern global::System.IntPtr Add_0(global::System.IntPtr instance, global::System.IntPtr s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxStringList7PrependEPKw")]
            internal static extern global::System.IntPtr Prepend_0(global::System.IntPtr instance, global::System.IntPtr s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxStringList6DeleteEPKw")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Delete_0(global::System.IntPtr instance, global::System.IntPtr s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxStringList11ListToArrayEb")]
            internal static extern char** ListToArray_0(global::System.IntPtr instance, bool new_copies);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK12wxStringList6MemberEPKw")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool Member_0(global::System.IntPtr instance, global::System.IntPtr s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN12wxStringList4SortEv")]
            internal static extern void Sort_0(global::System.IntPtr instance);
        }

        public static new wxStringList __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxStringList(native.ToPointer(), skipVTables);
        }

        public static wxStringList __CreateInstance(wxStringList.Internal native, bool skipVTables = false)
        {
            return new wxStringList(native, skipVTables);
        }

        private static void* __CopyValue(wxStringList.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            wxStringList.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxStringList(wxStringList.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxStringList(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxStringList()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxStringList");
        }

        public wxStringList(string first)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = Marshal.StringToHGlobalAnsi(first);
            Internal.ctor_1((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxStringList");
        }

        public wxStringList(wxStringList other)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(24);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var arg0 = other.__Instance;
            Internal.cctor_2((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxStringList");
        }

        public wxObjectListNode Add(string s)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(s);
            var __ret = Internal.Add_0((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public wxObjectListNode Prepend(string s)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(s);
            var __ret = Internal.Prepend_0((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            wxObjectListNode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxObjectListNode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxObjectListNode) wxObjectListNode.NativeToManagedMap[__ret];
            else wxObjectListNode.NativeToManagedMap[__ret] = __result0 = (wxObjectListNode) wxObjectListNode.__CreateInstance(__ret);
            return __result0;
        }

        public bool Delete(string s)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(s);
            var __ret = Internal.Delete_0((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public char** ListToArray(bool new_copies)
        {
            var __ret = Internal.ListToArray_0((__Instance + __PointerAdjustment), new_copies);
            return __ret;
        }

        public bool Member(string s)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(s);
            var __ret = Internal.Member_0((__Instance + __PointerAdjustment), arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        public void Sort()
        {
            Internal.Sort_0((__Instance + __PointerAdjustment));
        }

        #region Virtual table interop

        // wxStringList
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxStringList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // 
        private static Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _CreateNode_0DelegateInstance;

        private static global::System.IntPtr _CreateNode_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr prev, global::System.IntPtr next, global::System.IntPtr data, global::System.IntPtr key)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxStringList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxNodeBase __result0;
            if (prev == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(prev))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[prev];
            else __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(prev, skipVTables: true);
            wxNodeBase __result1;
            if (next == IntPtr.Zero) __result1 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(next))
                __result1 = (wxNodeBase) wxNodeBase.NativeToManagedMap[next];
            else __result1 = (wxNodeBase) wxNodeBase.__CreateInstance(next, skipVTables: true);
            wxListKey __result3;
            if (key == IntPtr.Zero) __result3 = null;
            else if (wxListKey.NativeToManagedMap.ContainsKey(key))
                __result3 = (wxListKey) wxListKey.NativeToManagedMap[key];
            else __result3 = wxListKey.__CreateInstance(key);
            var __ret = __target.CreateNode(__result0, __result1, data, __result3);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // 
        private static Delegates.Func_IntPtr_IntPtr_IntPtr _Find_1DelegateInstance;

        private static global::System.IntPtr _Find_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr key)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxStringList) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxListKey __result0;
            if (key == IntPtr.Zero) __result0 = null;
            else if (wxListKey.NativeToManagedMap.ContainsKey(key))
                __result0 = (wxListKey) wxListKey.NativeToManagedMap[key];
            else __result0 = wxListKey.__CreateInstance(key);
            var __ret = __target.Find(__result0);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _CreateNode_0DelegateInstance += _CreateNode_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CreateNode_0DelegateInstance).ToPointer();
                _Find_1DelegateInstance += _Find_1DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Find_1DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    internal unsafe partial class wxListBaseInternal : wxListBase, IDisposable
    {
        private static void* __CopyValue(wxListBase.Internal native)
        {
            var ret = Marshal.AllocHGlobal(24);
            *(wxListBase.Internal*) ret = native;
            return ret.ToPointer();
        }

        internal wxListBaseInternal(wxListBase.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal wxListBaseInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
        }

        protected override wxNodeBase CreateNode(wxNodeBase prev, wxNodeBase next, global::System.IntPtr data, wxListKey key)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___CreateNode_0Delegate = (Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
            var arg0 = ReferenceEquals(prev, null) ? global::System.IntPtr.Zero : prev.__Instance;
            var arg1 = ReferenceEquals(next, null) ? global::System.IntPtr.Zero : next.__Instance;
            var arg2 = data;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg3 = key.__Instance;
            var __ret = ___CreateNode_0Delegate((__Instance + __PointerAdjustment), arg0, arg1, arg2, arg3);
            wxNodeBase __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxNodeBase.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxNodeBase) wxNodeBase.NativeToManagedMap[__ret];
            else wxNodeBase.NativeToManagedMap[__ret] = __result0 = (wxNodeBase) wxNodeBase.__CreateInstance(__ret);
            return __result0;
        }
    }
}
