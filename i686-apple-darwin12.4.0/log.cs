//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace wxSharp
{
    public enum wxLogLevelValues : uint
    {
        wxLOG_FatalError = 0,
        wxLOG_Error = 1,
        wxLOG_Warning = 2,
        wxLOG_Message = 3,
        wxLOG_Status = 4,
        wxLOG_Info = 5,
        wxLOG_Debug = 6,
        wxLOG_Trace = 7,
        wxLOG_Progress = 8,
        wxLOG_User = 100,
        wxLOG_Max = 10000
    }

    public unsafe partial class wxLogRecordInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr filename;

            [FieldOffset(4)]
            public int line;

            [FieldOffset(8)]
            public global::System.IntPtr func;

            [FieldOffset(12)]
            public global::System.IntPtr component;

            [FieldOffset(16)]
            public int timestamp;

            [FieldOffset(20)]
            public uint threadId;

            [FieldOffset(24)]
            public global::System.IntPtr m_data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15wxLogRecordInfoC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15wxLogRecordInfoC2EPKciS1_S1_")]
            internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr filename_, int line_, global::System.IntPtr func_, global::System.IntPtr component_);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15wxLogRecordInfoC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15wxLogRecordInfoD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15wxLogRecordInfo10StoreValueERK8wxStringm")]
            internal static extern void StoreValue_0(global::System.IntPtr instance, global::System.IntPtr key, uint val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15wxLogRecordInfo10StoreValueERK8wxStringS2_")]
            internal static extern void StoreValue_1(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK15wxLogRecordInfo11GetNumValueERK8wxStringPm")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetNumValue_0(global::System.IntPtr instance, global::System.IntPtr key, uint* val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK15wxLogRecordInfo11GetStrValueERK8wxStringPS0_")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetStrValue_0(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr val);
        }

        internal unsafe partial class ExtraData
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public wxStringToNumHashMap.Internal numValues;

                [FieldOffset(16)]
                public wxStringToStringHashMap.Internal strValues;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLogRecordInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLogRecordInfo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxLogRecordInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLogRecordInfo(native.ToPointer(), skipVTables);
        }

        public static wxLogRecordInfo __CreateInstance(wxLogRecordInfo.Internal native, bool skipVTables = false)
        {
            return new wxLogRecordInfo(native, skipVTables);
        }

        private static void* __CopyValue(wxLogRecordInfo.Internal native)
        {
            var ret = Marshal.AllocHGlobal(28);
            wxLogRecordInfo.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxLogRecordInfo(wxLogRecordInfo.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLogRecordInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxLogRecordInfo()
        {
            __Instance = Marshal.AllocHGlobal(28);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public wxLogRecordInfo(string filename_, int line_, string func_, string component_)
        {
            __Instance = Marshal.AllocHGlobal(28);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = Marshal.StringToHGlobalAnsi(filename_);
            var arg2 = Marshal.StringToHGlobalAnsi(func_);
            var arg3 = Marshal.StringToHGlobalAnsi(component_);
            Internal.ctor_1((__Instance + __PointerAdjustment), arg0, line_, arg2, arg3);
            Marshal.FreeHGlobal(arg0);
            Marshal.FreeHGlobal(arg2);
            Marshal.FreeHGlobal(arg3);
        }

        public wxLogRecordInfo(wxLogRecordInfo other)
        {
            __Instance = Marshal.AllocHGlobal(28);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var arg0 = other.__Instance;
            Internal.cctor_2((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxLogRecordInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void StoreValue(wxString key, uint val)
        {
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg0 = key.__Instance;
            Internal.StoreValue_0((__Instance + __PointerAdjustment), arg0, val);
        }

        public void StoreValue(wxString key, wxString val)
        {
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg0 = key.__Instance;
            if (ReferenceEquals(val, null))
                throw new global::System.ArgumentNullException("val", "Cannot be null because it is a C++ reference (&).");
            var arg1 = val.__Instance;
            Internal.StoreValue_1((__Instance + __PointerAdjustment), arg0, arg1);
        }

        public bool GetNumValue(wxString key, ref uint val)
        {
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg0 = key.__Instance;
            fixed (uint* __refParamPtr1 = &val)
            {
                var arg1 = __refParamPtr1;
                var __ret = Internal.GetNumValue_0((__Instance + __PointerAdjustment), arg0, arg1);
                return __ret;
            }
        }

        public bool GetStrValue(wxString key, wxString val)
        {
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg0 = key.__Instance;
            var arg1 = ReferenceEquals(val, null) ? global::System.IntPtr.Zero : val.__Instance;
            var __ret = Internal.GetStrValue_0((__Instance + __PointerAdjustment), arg0, arg1);
            return __ret;
        }

        public string filename
        {
            get
            {
                return Marshal.PtrToStringAnsi(((Internal*) __Instance)->filename);
            }

            set
            {
                ((Internal*) __Instance)->filename = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public int line
        {
            get
            {
                return ((Internal*) __Instance)->line;
            }

            set
            {
                ((Internal*) __Instance)->line = value;
            }
        }

        public string func
        {
            get
            {
                return Marshal.PtrToStringAnsi(((Internal*) __Instance)->func);
            }

            set
            {
                ((Internal*) __Instance)->func = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string component
        {
            get
            {
                return Marshal.PtrToStringAnsi(((Internal*) __Instance)->component);
            }

            set
            {
                ((Internal*) __Instance)->component = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public int timestamp
        {
            get
            {
                return ((Internal*) __Instance)->timestamp;
            }

            set
            {
                ((Internal*) __Instance)->timestamp = value;
            }
        }

        public uint threadId
        {
            get
            {
                return ((Internal*) __Instance)->threadId;
            }

            set
            {
                ((Internal*) __Instance)->threadId = value;
            }
        }
    }

    public unsafe partial class wxLogRecord : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 52)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public uint level;

            [FieldOffset(4)]
            public wxString.Internal msg;

            [FieldOffset(24)]
            public wxLogRecordInfo.Internal info;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxLogRecordC2EmRK8wxStringRK15wxLogRecordInfo")]
            internal static extern void ctor_0(global::System.IntPtr instance, uint level_, global::System.IntPtr msg_, global::System.IntPtr info_);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxLogRecordC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxLogRecordD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLogRecord> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLogRecord>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxLogRecord __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLogRecord(native.ToPointer(), skipVTables);
        }

        public static wxLogRecord __CreateInstance(wxLogRecord.Internal native, bool skipVTables = false)
        {
            return new wxLogRecord(native, skipVTables);
        }

        private static void* __CopyValue(wxLogRecord.Internal native)
        {
            var ret = Marshal.AllocHGlobal(52);
            wxLogRecord.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxLogRecord(wxLogRecord.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLogRecord(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxLogRecord(uint level_, wxString msg_, wxLogRecordInfo info_)
        {
            __Instance = Marshal.AllocHGlobal(52);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(msg_, null))
                throw new global::System.ArgumentNullException("msg_", "Cannot be null because it is a C++ reference (&).");
            var arg1 = msg_.__Instance;
            if (ReferenceEquals(info_, null))
                throw new global::System.ArgumentNullException("info_", "Cannot be null because it is a C++ reference (&).");
            var arg2 = info_.__Instance;
            Internal.ctor_0((__Instance + __PointerAdjustment), level_, arg1, arg2);
        }

        public wxLogRecord(wxLogRecord _0)
        {
            __Instance = Marshal.AllocHGlobal(52);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_2((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxLogRecord __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public uint level
        {
            get
            {
                return ((Internal*) __Instance)->level;
            }

            set
            {
                ((Internal*) __Instance)->level = value;
            }
        }

        public wxString msg
        {
            get
            {
                return wxString.__CreateInstance(((Internal*) __Instance)->msg);
            }

            set
            {
                ((Internal*) __Instance)->msg = ReferenceEquals(value, null) ? new wxString.Internal() : *(wxString.Internal*) (value.__Instance);
            }
        }

        public wxLogRecordInfo info
        {
            get
            {
                return wxLogRecordInfo.__CreateInstance(((Internal*) __Instance)->info);
            }

            set
            {
                ((Internal*) __Instance)->info = ReferenceEquals(value, null) ? new wxLogRecordInfo.Internal() : *(wxLogRecordInfo.Internal*) (value.__Instance);
            }
        }
    }

    public unsafe partial class wxLogFormatter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14wxLogFormatterC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14wxLogFormatterC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLogFormatter> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLogFormatter>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxLogFormatter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLogFormatter(native.ToPointer(), skipVTables);
        }

        public static wxLogFormatter __CreateInstance(wxLogFormatter.Internal native, bool skipVTables = false)
        {
            return new wxLogFormatter(native, skipVTables);
        }

        private static void* __CopyValue(wxLogFormatter.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            wxLogFormatter.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxLogFormatter(wxLogFormatter.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLogFormatter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxLogFormatter()
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxLogFormatter");
        }

        public wxLogFormatter(wxLogFormatter _0)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxLogFormatter");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxLogFormatter __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___dtor_0Delegate((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual wxString Format(uint level, wxString msg, wxLogRecordInfo info)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___Format_0Delegate = (Delegates.Action_IntPtr_IntPtr_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_IntPtr_uint_IntPtr_IntPtr));
            if (ReferenceEquals(msg, null))
                throw new global::System.ArgumentNullException("msg", "Cannot be null because it is a C++ reference (&).");
            var arg1 = msg.__Instance;
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var arg2 = info.__Instance;
            var __ret = new wxString.Internal();
            ___Format_0Delegate(new IntPtr(&__ret), (__Instance + __PointerAdjustment), level, arg1, arg2);
            return wxString.__CreateInstance(__ret);
        }

        protected virtual wxString FormatTime(int t)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
            var ___FormatTime_0Delegate = (Delegates.Action_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_IntPtr_int));
            var __ret = new wxString.Internal();
            ___FormatTime_0Delegate(new IntPtr(&__ret), (__Instance + __PointerAdjustment), t);
            return wxString.__CreateInstance(__ret);
        }

        #region Virtual table interop

        // virtual ~wxLogFormatter()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogFormatter) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // wxString Format(wxLogLevel level, const wxString& msg, const wxLogRecordInfo& info) const
        private static Delegates.Action_IntPtr_IntPtr_uint_IntPtr_IntPtr _Format_0DelegateInstance;

        private static void _Format_0DelegateHook(global::System.IntPtr @return, global::System.IntPtr instance, uint level, global::System.IntPtr msg, global::System.IntPtr info)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogFormatter) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result2;
            if (msg == IntPtr.Zero) __result2 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result2 = (wxString) wxString.NativeToManagedMap[msg];
            else __result2 = wxString.__CreateInstance(msg);
            wxLogRecordInfo __result3;
            if (info == IntPtr.Zero) __result3 = null;
            else if (wxLogRecordInfo.NativeToManagedMap.ContainsKey(info))
                __result3 = (wxLogRecordInfo) wxLogRecordInfo.NativeToManagedMap[info];
            else __result3 = wxLogRecordInfo.__CreateInstance(info);
            var __ret = __target.Format(level, __result2, __result3);
            *(wxString.Internal*) @return = ReferenceEquals(__ret, null) ? new wxString.Internal() : *(wxString.Internal*) (__ret.__Instance);
        }

        // wxString FormatTime(time_t t) const
        private static Delegates.Action_IntPtr_IntPtr_int _FormatTime_0DelegateInstance;

        private static void _FormatTime_0DelegateHook(global::System.IntPtr @return, global::System.IntPtr instance, int t)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogFormatter) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.FormatTime(t);
            *(wxString.Internal*) @return = ReferenceEquals(__ret, null) ? new wxString.Internal() : *(wxString.Internal*) (__ret.__Instance);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Format_0DelegateInstance += _Format_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Format_0DelegateInstance).ToPointer();
                _FormatTime_0DelegateInstance += _FormatTime_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_FormatTime_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(6 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxLog : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr m_formatter;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLogC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLogC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog9IsEnabledEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsEnabled_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog13EnableLoggingEb")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool EnableLogging_0(bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog11GetLogLevelEv")]
            internal static extern uint GetLogLevel_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog11SetLogLevelEm")]
            internal static extern void SetLogLevel_0(uint logLevel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog17SetComponentLevelERK8wxStringm")]
            internal static extern void SetComponentLevel_0(global::System.IntPtr component, uint level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog17GetComponentLevelE8wxString")]
            internal static extern uint GetComponentLevel_0(wxString.Internal component);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog14IsLevelEnabledEm8wxString")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsLevelEnabled_0(uint level, wxString.Internal component);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog10SetVerboseEb")]
            internal static extern void SetVerbose_0(bool bVerbose);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog10GetVerboseEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetVerbose_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog11FlushActiveEv")]
            internal static extern void FlushActive_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog15GetActiveTargetEv")]
            internal static extern global::System.IntPtr GetActiveTarget_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog15SetActiveTargetEPS_")]
            internal static extern global::System.IntPtr SetActiveTarget_0(global::System.IntPtr logger);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog21SetThreadActiveTargetEPS_")]
            internal static extern global::System.IntPtr SetThreadActiveTarget_0(global::System.IntPtr logger);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog7SuspendEv")]
            internal static extern void Suspend_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog6ResumeEv")]
            internal static extern void Resume_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog18DontCreateOnDemandEv")]
            internal static extern void DontCreateOnDemand_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog16DoCreateOnDemandEv")]
            internal static extern void DoCreateOnDemand_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog21SetRepetitionCountingEb")]
            internal static extern void SetRepetitionCounting_0(bool bRepetCounting);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog21GetRepetitionCountingEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool GetRepetitionCounting_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog12AddTraceMaskERK8wxString")]
            internal static extern void AddTraceMask_0(global::System.IntPtr str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog15RemoveTraceMaskERK8wxString")]
            internal static extern void RemoveTraceMask_0(global::System.IntPtr str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog15ClearTraceMasksEv")]
            internal static extern void ClearTraceMasks_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog13GetTraceMasksEv")]
            internal static extern global::System.IntPtr GetTraceMasks_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog18IsAllowedTraceMaskERK8wxString")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsAllowedTraceMask_0(global::System.IntPtr mask);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog12SetFormatterEP14wxLogFormatter")]
            internal static extern global::System.IntPtr SetFormatter_0(global::System.IntPtr instance, global::System.IntPtr formatter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog12SetTimestampERK8wxString")]
            internal static extern void SetTimestamp_0(global::System.IntPtr ts);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog16DisableTimestampEv")]
            internal static extern void DisableTimestamp_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog12GetTimestampEv")]
            internal static extern global::System.IntPtr GetTimestamp_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog9TimeStampEP8wxString")]
            internal static extern void TimeStamp_0(global::System.IntPtr str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog9TimeStampEP8wxStringl")]
            internal static extern void TimeStamp_1(global::System.IntPtr str, int t);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog9LogRecordEmRK8wxStringRK15wxLogRecordInfo")]
            internal static extern void LogRecord_0(global::System.IntPtr instance, uint level, global::System.IntPtr msg, global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog14LogTextAtLevelEmRK8wxString")]
            internal static extern void LogTextAtLevel_0(global::System.IntPtr instance, uint level, global::System.IntPtr msg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog7LogTextERK8wxString")]
            internal static extern void LogText_0(global::System.IntPtr instance, global::System.IntPtr msg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog5OnLogEmRK8wxStringRK15wxLogRecordInfo")]
            internal static extern void OnLog_0(uint level, global::System.IntPtr msg, global::System.IntPtr info);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog5OnLogEmRK8wxStringl")]
            internal static extern void OnLog_1(uint level, global::System.IntPtr msg, int t);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog5OnLogEmRK8wxString")]
            internal static extern void OnLog_2(uint level, global::System.IntPtr msg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK5wxLog18HasPendingMessagesEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool HasPendingMessages_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN5wxLog21LogLastRepeatIfNeededEv")]
            internal static extern uint LogLastRepeatIfNeeded_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLog> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLog>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxLog __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLog(native.ToPointer(), skipVTables);
        }

        public static wxLog __CreateInstance(wxLog.Internal native, bool skipVTables = false)
        {
            return new wxLog(native, skipVTables);
        }

        private static void* __CopyValue(wxLog.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            wxLog.Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxLog(wxLog.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLog(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxLog()
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxLog");
        }

        public wxLog(wxLog _0)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxLog");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxLog __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___dtor_0Delegate((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual void Flush()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___Flush_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___Flush_0Delegate((__Instance + __PointerAdjustment));
        }

        public wxLogFormatter SetFormatter(wxLogFormatter formatter)
        {
            var arg0 = ReferenceEquals(formatter, null) ? global::System.IntPtr.Zero : formatter.__Instance;
            var __ret = Internal.SetFormatter_0((__Instance + __PointerAdjustment), arg0);
            wxLogFormatter __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxLogFormatter.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxLogFormatter) wxLogFormatter.NativeToManagedMap[__ret];
            else wxLogFormatter.NativeToManagedMap[__ret] = __result0 = (wxLogFormatter) wxLogFormatter.__CreateInstance(__ret);
            return __result0;
        }

        public void LogRecord(uint level, wxString msg, wxLogRecordInfo info)
        {
            if (ReferenceEquals(msg, null))
                throw new global::System.ArgumentNullException("msg", "Cannot be null because it is a C++ reference (&).");
            var arg1 = msg.__Instance;
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var arg2 = info.__Instance;
            Internal.LogRecord_0((__Instance + __PointerAdjustment), level, arg1, arg2);
        }

        public void LogTextAtLevel(uint level, wxString msg)
        {
            if (ReferenceEquals(msg, null))
                throw new global::System.ArgumentNullException("msg", "Cannot be null because it is a C++ reference (&).");
            var arg1 = msg.__Instance;
            Internal.LogTextAtLevel_0((__Instance + __PointerAdjustment), level, arg1);
        }

        public void LogText(wxString msg)
        {
            if (ReferenceEquals(msg, null))
                throw new global::System.ArgumentNullException("msg", "Cannot be null because it is a C++ reference (&).");
            var arg0 = msg.__Instance;
            Internal.LogText_0((__Instance + __PointerAdjustment), arg0);
        }

        public bool HasPendingMessages()
        {
            var __ret = Internal.HasPendingMessages_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        protected virtual void DoLogRecord(uint level, wxString msg, wxLogRecordInfo info)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
            var ___DoLogRecord_0Delegate = (Delegates.Action_IntPtr_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_uint_IntPtr_IntPtr));
            if (ReferenceEquals(msg, null))
                throw new global::System.ArgumentNullException("msg", "Cannot be null because it is a C++ reference (&).");
            var arg1 = msg.__Instance;
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var arg2 = info.__Instance;
            ___DoLogRecord_0Delegate((__Instance + __PointerAdjustment), level, arg1, arg2);
        }

        protected virtual void DoLogTextAtLevel(uint level, wxString msg)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 4);
            var ___DoLogTextAtLevel_0Delegate = (Delegates.Action_IntPtr_uint_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_uint_IntPtr));
            if (ReferenceEquals(msg, null))
                throw new global::System.ArgumentNullException("msg", "Cannot be null because it is a C++ reference (&).");
            var arg1 = msg.__Instance;
            ___DoLogTextAtLevel_0Delegate((__Instance + __PointerAdjustment), level, arg1);
        }

        protected virtual void DoLogText(wxString msg)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
            var ___DoLogText_0Delegate = (Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(msg, null))
                throw new global::System.ArgumentNullException("msg", "Cannot be null because it is a C++ reference (&).");
            var arg0 = msg.__Instance;
            ___DoLogText_0Delegate((__Instance + __PointerAdjustment), arg0);
        }

        protected uint LogLastRepeatIfNeeded()
        {
            var __ret = Internal.LogLastRepeatIfNeeded_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public static bool IsEnabled()
        {
            var __ret = Internal.IsEnabled_0();
            return __ret;
        }

        public static bool EnableLogging(bool enable)
        {
            var __ret = Internal.EnableLogging_0(enable);
            return __ret;
        }

        public static uint GetLogLevel()
        {
            var __ret = Internal.GetLogLevel_0();
            return __ret;
        }

        public static void SetLogLevel(uint logLevel)
        {
            Internal.SetLogLevel_0(logLevel);
        }

        public static void SetComponentLevel(wxString component, uint level)
        {
            if (ReferenceEquals(component, null))
                throw new global::System.ArgumentNullException("component", "Cannot be null because it is a C++ reference (&).");
            var arg0 = component.__Instance;
            Internal.SetComponentLevel_0(arg0, level);
        }

        public static uint GetComponentLevel(wxString component)
        {
            var arg0 = ReferenceEquals(component, null) ? new wxString.Internal() : *(wxString.Internal*) (component.__Instance);
            var __ret = Internal.GetComponentLevel_0(arg0);
            return __ret;
        }

        public static bool IsLevelEnabled(uint level, wxString component)
        {
            var arg1 = ReferenceEquals(component, null) ? new wxString.Internal() : *(wxString.Internal*) (component.__Instance);
            var __ret = Internal.IsLevelEnabled_0(level, arg1);
            return __ret;
        }

        public static void SetVerbose(bool bVerbose)
        {
            Internal.SetVerbose_0(bVerbose);
        }

        public static bool GetVerbose()
        {
            var __ret = Internal.GetVerbose_0();
            return __ret;
        }

        public static void FlushActive()
        {
            Internal.FlushActive_0();
        }

        public static wxLog GetActiveTarget()
        {
            var __ret = Internal.GetActiveTarget_0();
            wxLog __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxLog.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxLog) wxLog.NativeToManagedMap[__ret];
            else wxLog.NativeToManagedMap[__ret] = __result0 = (wxLog) wxLog.__CreateInstance(__ret);
            return __result0;
        }

        public static wxLog SetActiveTarget(wxLog logger)
        {
            var arg0 = ReferenceEquals(logger, null) ? global::System.IntPtr.Zero : logger.__Instance;
            var __ret = Internal.SetActiveTarget_0(arg0);
            wxLog __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxLog.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxLog) wxLog.NativeToManagedMap[__ret];
            else wxLog.NativeToManagedMap[__ret] = __result0 = (wxLog) wxLog.__CreateInstance(__ret);
            return __result0;
        }

        public static wxLog SetThreadActiveTarget(wxLog logger)
        {
            var arg0 = ReferenceEquals(logger, null) ? global::System.IntPtr.Zero : logger.__Instance;
            var __ret = Internal.SetThreadActiveTarget_0(arg0);
            wxLog __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxLog.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxLog) wxLog.NativeToManagedMap[__ret];
            else wxLog.NativeToManagedMap[__ret] = __result0 = (wxLog) wxLog.__CreateInstance(__ret);
            return __result0;
        }

        public static void Suspend()
        {
            Internal.Suspend_0();
        }

        public static void Resume()
        {
            Internal.Resume_0();
        }

        public static void DontCreateOnDemand()
        {
            Internal.DontCreateOnDemand_0();
        }

        public static void DoCreateOnDemand()
        {
            Internal.DoCreateOnDemand_0();
        }

        public static void SetRepetitionCounting(bool bRepetCounting)
        {
            Internal.SetRepetitionCounting_0(bRepetCounting);
        }

        public static bool GetRepetitionCounting()
        {
            var __ret = Internal.GetRepetitionCounting_0();
            return __ret;
        }

        public static void AddTraceMask(wxString str)
        {
            if (ReferenceEquals(str, null))
                throw new global::System.ArgumentNullException("str", "Cannot be null because it is a C++ reference (&).");
            var arg0 = str.__Instance;
            Internal.AddTraceMask_0(arg0);
        }

        public static void RemoveTraceMask(wxString str)
        {
            if (ReferenceEquals(str, null))
                throw new global::System.ArgumentNullException("str", "Cannot be null because it is a C++ reference (&).");
            var arg0 = str.__Instance;
            Internal.RemoveTraceMask_0(arg0);
        }

        public static void ClearTraceMasks()
        {
            Internal.ClearTraceMasks_0();
        }

        public static wxArrayString GetTraceMasks()
        {
            var __ret = Internal.GetTraceMasks_0();
            wxArrayString __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxArrayString.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxArrayString) wxArrayString.NativeToManagedMap[__ret];
            else __result0 = wxArrayString.__CreateInstance(__ret);
            return __result0;
        }

        public static bool IsAllowedTraceMask(wxString mask)
        {
            if (ReferenceEquals(mask, null))
                throw new global::System.ArgumentNullException("mask", "Cannot be null because it is a C++ reference (&).");
            var arg0 = mask.__Instance;
            var __ret = Internal.IsAllowedTraceMask_0(arg0);
            return __ret;
        }

        public static void SetTimestamp(wxString ts)
        {
            if (ReferenceEquals(ts, null))
                throw new global::System.ArgumentNullException("ts", "Cannot be null because it is a C++ reference (&).");
            var arg0 = ts.__Instance;
            Internal.SetTimestamp_0(arg0);
        }

        public static void DisableTimestamp()
        {
            Internal.DisableTimestamp_0();
        }

        public static wxString GetTimestamp()
        {
            var __ret = Internal.GetTimestamp_0();
            wxString __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxString) wxString.NativeToManagedMap[__ret];
            else __result0 = wxString.__CreateInstance(__ret);
            return __result0;
        }

        public static void TimeStamp(wxString str)
        {
            var arg0 = ReferenceEquals(str, null) ? global::System.IntPtr.Zero : str.__Instance;
            Internal.TimeStamp_0(arg0);
        }

        public static void TimeStamp(wxString str, int t)
        {
            var arg0 = ReferenceEquals(str, null) ? global::System.IntPtr.Zero : str.__Instance;
            Internal.TimeStamp_1(arg0, t);
        }

        public static void OnLog(uint level, wxString msg, wxLogRecordInfo info)
        {
            if (ReferenceEquals(msg, null))
                throw new global::System.ArgumentNullException("msg", "Cannot be null because it is a C++ reference (&).");
            var arg1 = msg.__Instance;
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
            var arg2 = info.__Instance;
            Internal.OnLog_0(level, arg1, arg2);
        }

        public static void OnLog(uint level, wxString msg, int t)
        {
            if (ReferenceEquals(msg, null))
                throw new global::System.ArgumentNullException("msg", "Cannot be null because it is a C++ reference (&).");
            var arg1 = msg.__Instance;
            Internal.OnLog_1(level, arg1, t);
        }

        public static void OnLog(uint level, wxString msg)
        {
            if (ReferenceEquals(msg, null))
                throw new global::System.ArgumentNullException("msg", "Cannot be null because it is a C++ reference (&).");
            var arg1 = msg.__Instance;
            Internal.OnLog_2(level, arg1);
        }

        #region Virtual table interop

        // virtual ~wxLog()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLog) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // void Flush()
        private static Delegates.Action_IntPtr _Flush_0DelegateInstance;

        private static void _Flush_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLog) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Flush();
        }

        // void DoLogRecord(wxLogLevel level, const wxString& msg, const wxLogRecordInfo& info)
        private static Delegates.Action_IntPtr_uint_IntPtr_IntPtr _DoLogRecord_0DelegateInstance;

        private static void _DoLogRecord_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg, global::System.IntPtr info)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLog) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            wxLogRecordInfo __result2;
            if (info == IntPtr.Zero) __result2 = null;
            else if (wxLogRecordInfo.NativeToManagedMap.ContainsKey(info))
                __result2 = (wxLogRecordInfo) wxLogRecordInfo.NativeToManagedMap[info];
            else __result2 = wxLogRecordInfo.__CreateInstance(info);
            __target.DoLogRecord(level, __result1, __result2);
        }

        // void DoLogTextAtLevel(wxLogLevel level, const wxString& msg)
        private static Delegates.Action_IntPtr_uint_IntPtr _DoLogTextAtLevel_0DelegateInstance;

        private static void _DoLogTextAtLevel_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLog) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            __target.DoLogTextAtLevel(level, __result1);
        }

        // void DoLogText(const wxString& msg)
        private static Delegates.Action_IntPtr_IntPtr _DoLogText_0DelegateInstance;

        private static void _DoLogText_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLog) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result0;
            if (msg == IntPtr.Zero) __result0 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result0 = (wxString) wxString.NativeToManagedMap[msg];
            else __result0 = wxString.__CreateInstance(msg);
            __target.DoLogText(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Flush_0DelegateInstance += _Flush_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Flush_0DelegateInstance).ToPointer();
                _DoLogRecord_0DelegateInstance += _DoLogRecord_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DoLogRecord_0DelegateInstance).ToPointer();
                _DoLogTextAtLevel_0DelegateInstance += _DoLogTextAtLevel_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_DoLogTextAtLevel_0DelegateInstance).ToPointer();
                _DoLogText_0DelegateInstance += _DoLogText_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_DoLogText_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxLogBuffer : wxLog, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr m_formatter;

            [FieldOffset(8)]
            public wxString.Internal m_str;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxLogBufferC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK11wxLogBuffer9GetBufferEv")]
            internal static extern global::System.IntPtr GetBuffer_0(global::System.IntPtr instance);
        }

        public static new wxLogBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLogBuffer(native.ToPointer(), skipVTables);
        }

        public static wxLogBuffer __CreateInstance(wxLogBuffer.Internal native, bool skipVTables = false)
        {
            return new wxLogBuffer(native, skipVTables);
        }

        private static void* __CopyValue(wxLogBuffer.Internal native)
        {
            var ret = Marshal.AllocHGlobal(28);
            *(wxLogBuffer.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxLogBuffer(wxLogBuffer.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLogBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxLogBuffer()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(28);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxLogBuffer");
        }

        public wxString GetBuffer()
        {
            var __ret = Internal.GetBuffer_0((__Instance + __PointerAdjustment));
            wxString __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxString) wxString.NativeToManagedMap[__ret];
            else __result0 = wxString.__CreateInstance(__ret);
            return __result0;
        }

        public override void Flush()
        {
            base.Flush();
        }

        protected override void DoLogTextAtLevel(uint level, wxString msg)
        {
            base.DoLogTextAtLevel(level, msg);
        }

        #region Virtual table interop

        // wxLogBuffer
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // void Flush() wxOVERRIDE
        private static Delegates.Action_IntPtr _Flush_0DelegateInstance;

        private static void _Flush_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Flush();
        }

        // void DoLogRecord(wxLogLevel level, const wxString& msg, const wxLogRecordInfo& info)
        private static Delegates.Action_IntPtr_uint_IntPtr_IntPtr _DoLogRecord_0DelegateInstance;

        private static void _DoLogRecord_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg, global::System.IntPtr info)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            wxLogRecordInfo __result2;
            if (info == IntPtr.Zero) __result2 = null;
            else if (wxLogRecordInfo.NativeToManagedMap.ContainsKey(info))
                __result2 = (wxLogRecordInfo) wxLogRecordInfo.NativeToManagedMap[info];
            else __result2 = wxLogRecordInfo.__CreateInstance(info);
            __target.DoLogRecord(level, __result1, __result2);
        }

        // void DoLogTextAtLevel(wxLogLevel level, const wxString& msg) wxOVERRIDE
        private static Delegates.Action_IntPtr_uint_IntPtr _DoLogTextAtLevel_0DelegateInstance;

        private static void _DoLogTextAtLevel_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            __target.DoLogTextAtLevel(level, __result1);
        }

        // void DoLogText(const wxString& msg)
        private static Delegates.Action_IntPtr_IntPtr _DoLogText_0DelegateInstance;

        private static void _DoLogText_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result0;
            if (msg == IntPtr.Zero) __result0 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result0 = (wxString) wxString.NativeToManagedMap[msg];
            else __result0 = wxString.__CreateInstance(msg);
            __target.DoLogText(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Flush_0DelegateInstance += _Flush_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Flush_0DelegateInstance).ToPointer();
                _DoLogRecord_0DelegateInstance += _DoLogRecord_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DoLogRecord_0DelegateInstance).ToPointer();
                _DoLogTextAtLevel_0DelegateInstance += _DoLogTextAtLevel_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_DoLogTextAtLevel_0DelegateInstance).ToPointer();
                _DoLogText_0DelegateInstance += _DoLogText_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_DoLogText_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxLogStderr : wxLog, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr m_formatter;

            [FieldOffset(8)]
            public global::System.IntPtr m_fp;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxLogStderrC2EP7__sFILE")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr fp);
        }

        public static new wxLogStderr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLogStderr(native.ToPointer(), skipVTables);
        }

        public static wxLogStderr __CreateInstance(wxLogStderr.Internal native, bool skipVTables = false)
        {
            return new wxLogStderr(native, skipVTables);
        }

        private static void* __CopyValue(wxLogStderr.Internal native)
        {
            var ret = Marshal.AllocHGlobal(12);
            *(wxLogStderr.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxLogStderr(wxLogStderr.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLogStderr(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxLogStderr(global::System.IntPtr fp)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = fp;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxLogStderr");
        }

        protected override void DoLogText(wxString msg)
        {
            base.DoLogText(msg);
        }

        protected global::System.IntPtr m_fp
        {
            get
            {
                return ((Internal*) __Instance)->m_fp;
            }

            set
            {
                ((Internal*) __Instance)->m_fp = value;
            }
        }

        #region Virtual table interop

        // wxLogStderr
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogStderr) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // void Flush()
        private static Delegates.Action_IntPtr _Flush_0DelegateInstance;

        private static void _Flush_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogStderr) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Flush();
        }

        // void DoLogRecord(wxLogLevel level, const wxString& msg, const wxLogRecordInfo& info)
        private static Delegates.Action_IntPtr_uint_IntPtr_IntPtr _DoLogRecord_0DelegateInstance;

        private static void _DoLogRecord_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg, global::System.IntPtr info)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogStderr) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            wxLogRecordInfo __result2;
            if (info == IntPtr.Zero) __result2 = null;
            else if (wxLogRecordInfo.NativeToManagedMap.ContainsKey(info))
                __result2 = (wxLogRecordInfo) wxLogRecordInfo.NativeToManagedMap[info];
            else __result2 = wxLogRecordInfo.__CreateInstance(info);
            __target.DoLogRecord(level, __result1, __result2);
        }

        // void DoLogTextAtLevel(wxLogLevel level, const wxString& msg)
        private static Delegates.Action_IntPtr_uint_IntPtr _DoLogTextAtLevel_0DelegateInstance;

        private static void _DoLogTextAtLevel_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogStderr) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            __target.DoLogTextAtLevel(level, __result1);
        }

        // void DoLogText(const wxString& msg) wxOVERRIDE
        private static Delegates.Action_IntPtr_IntPtr _DoLogText_0DelegateInstance;

        private static void _DoLogText_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogStderr) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result0;
            if (msg == IntPtr.Zero) __result0 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result0 = (wxString) wxString.NativeToManagedMap[msg];
            else __result0 = wxString.__CreateInstance(msg);
            __target.DoLogText(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Flush_0DelegateInstance += _Flush_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Flush_0DelegateInstance).ToPointer();
                _DoLogRecord_0DelegateInstance += _DoLogRecord_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DoLogRecord_0DelegateInstance).ToPointer();
                _DoLogTextAtLevel_0DelegateInstance += _DoLogTextAtLevel_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_DoLogTextAtLevel_0DelegateInstance).ToPointer();
                _DoLogText_0DelegateInstance += _DoLogText_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_DoLogText_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxLogStream : wxLog, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr m_formatter;

            [FieldOffset(8)]
            public global::System.IntPtr m_ostr;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxLogStreamC2ERKS_")]
            internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public static new wxLogStream __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLogStream(native.ToPointer(), skipVTables);
        }

        public static wxLogStream __CreateInstance(wxLogStream.Internal native, bool skipVTables = false)
        {
            return new wxLogStream(native, skipVTables);
        }

        private static void* __CopyValue(wxLogStream.Internal native)
        {
            var ret = Marshal.AllocHGlobal(12);
            wxLogStream.Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private wxLogStream(wxLogStream.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLogStream(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxLogStream(wxLogStream _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(12);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_2((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxLogStream");
        }

        protected override void DoLogText(wxString msg)
        {
            base.DoLogText(msg);
        }

        #region Virtual table interop

        // wxLogStream
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogStream) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // void Flush()
        private static Delegates.Action_IntPtr _Flush_0DelegateInstance;

        private static void _Flush_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogStream) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Flush();
        }

        // void DoLogRecord(wxLogLevel level, const wxString& msg, const wxLogRecordInfo& info)
        private static Delegates.Action_IntPtr_uint_IntPtr_IntPtr _DoLogRecord_0DelegateInstance;

        private static void _DoLogRecord_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg, global::System.IntPtr info)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogStream) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            wxLogRecordInfo __result2;
            if (info == IntPtr.Zero) __result2 = null;
            else if (wxLogRecordInfo.NativeToManagedMap.ContainsKey(info))
                __result2 = (wxLogRecordInfo) wxLogRecordInfo.NativeToManagedMap[info];
            else __result2 = wxLogRecordInfo.__CreateInstance(info);
            __target.DoLogRecord(level, __result1, __result2);
        }

        // void DoLogTextAtLevel(wxLogLevel level, const wxString& msg)
        private static Delegates.Action_IntPtr_uint_IntPtr _DoLogTextAtLevel_0DelegateInstance;

        private static void _DoLogTextAtLevel_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogStream) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            __target.DoLogTextAtLevel(level, __result1);
        }

        // void DoLogText(const wxString& msg) wxOVERRIDE
        private static Delegates.Action_IntPtr_IntPtr _DoLogText_0DelegateInstance;

        private static void _DoLogText_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogStream) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result0;
            if (msg == IntPtr.Zero) __result0 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result0 = (wxString) wxString.NativeToManagedMap[msg];
            else __result0 = wxString.__CreateInstance(msg);
            __target.DoLogText(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Flush_0DelegateInstance += _Flush_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Flush_0DelegateInstance).ToPointer();
                _DoLogRecord_0DelegateInstance += _DoLogRecord_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DoLogRecord_0DelegateInstance).ToPointer();
                _DoLogTextAtLevel_0DelegateInstance += _DoLogTextAtLevel_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_DoLogTextAtLevel_0DelegateInstance).ToPointer();
                _DoLogText_0DelegateInstance += _DoLogText_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_DoLogText_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxLogNull : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public byte m_flagOld;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxLogNullC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxLogNullC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9wxLogNullD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLogNull> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLogNull>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxLogNull __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLogNull(native.ToPointer(), skipVTables);
        }

        public static wxLogNull __CreateInstance(wxLogNull.Internal native, bool skipVTables = false)
        {
            return new wxLogNull(native, skipVTables);
        }

        private static void* __CopyValue(wxLogNull.Internal native)
        {
            var ret = Marshal.AllocHGlobal(1);
            *(wxLogNull.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxLogNull(wxLogNull.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLogNull(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxLogNull()
        {
            __Instance = Marshal.AllocHGlobal(1);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public wxLogNull(wxLogNull _0)
        {
            __Instance = Marshal.AllocHGlobal(1);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((wxLogNull.Internal*) __Instance) = *((wxLogNull.Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxLogNull __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class wxLogChain : wxLog, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr m_formatter;

            [FieldOffset(8)]
            public global::System.IntPtr m_logNew;

            [FieldOffset(12)]
            public global::System.IntPtr m_logOld;

            [FieldOffset(16)]
            public byte m_bPassMessages;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxLogChainC2EP5wxLog")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr logger);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxLogChain6SetLogEP5wxLog")]
            internal static extern void SetLog_0(global::System.IntPtr instance, global::System.IntPtr logger);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxLogChain12PassMessagesEb")]
            internal static extern void PassMessages_0(global::System.IntPtr instance, bool bDoPass);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxLogChain17IsPassingMessagesEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsPassingMessages_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK10wxLogChain9GetOldLogEv")]
            internal static extern global::System.IntPtr GetOldLog_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN10wxLogChain12DetachOldLogEv")]
            internal static extern void DetachOldLog_0(global::System.IntPtr instance);
        }

        public static new wxLogChain __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLogChain(native.ToPointer(), skipVTables);
        }

        public static wxLogChain __CreateInstance(wxLogChain.Internal native, bool skipVTables = false)
        {
            return new wxLogChain(native, skipVTables);
        }

        private static void* __CopyValue(wxLogChain.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            *(wxLogChain.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxLogChain(wxLogChain.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLogChain(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxLogChain(wxLog logger)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(20);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = ReferenceEquals(logger, null) ? global::System.IntPtr.Zero : logger.__Instance;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxLogChain");
        }

        public void SetLog(wxLog logger)
        {
            var arg0 = ReferenceEquals(logger, null) ? global::System.IntPtr.Zero : logger.__Instance;
            Internal.SetLog_0((__Instance + __PointerAdjustment), arg0);
        }

        public void PassMessages(bool bDoPass)
        {
            Internal.PassMessages_0((__Instance + __PointerAdjustment), bDoPass);
        }

        public bool IsPassingMessages()
        {
            var __ret = Internal.IsPassingMessages_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxLog GetOldLog()
        {
            var __ret = Internal.GetOldLog_0((__Instance + __PointerAdjustment));
            wxLog __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxLog.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxLog) wxLog.NativeToManagedMap[__ret];
            else wxLog.NativeToManagedMap[__ret] = __result0 = (wxLog) wxLog.__CreateInstance(__ret);
            return __result0;
        }

        public override void Flush()
        {
            base.Flush();
        }

        public void DetachOldLog()
        {
            Internal.DetachOldLog_0((__Instance + __PointerAdjustment));
        }

        protected override void DoLogRecord(uint level, wxString msg, wxLogRecordInfo info)
        {
            base.DoLogRecord(level, msg, info);
        }

        #region Virtual table interop

        // virtual ~wxLogChain()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogChain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // void Flush() wxOVERRIDE
        private static Delegates.Action_IntPtr _Flush_0DelegateInstance;

        private static void _Flush_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogChain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Flush();
        }

        // void DoLogRecord(wxLogLevel level, const wxString& msg, const wxLogRecordInfo& info) wxOVERRIDE
        private static Delegates.Action_IntPtr_uint_IntPtr_IntPtr _DoLogRecord_0DelegateInstance;

        private static void _DoLogRecord_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg, global::System.IntPtr info)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogChain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            wxLogRecordInfo __result2;
            if (info == IntPtr.Zero) __result2 = null;
            else if (wxLogRecordInfo.NativeToManagedMap.ContainsKey(info))
                __result2 = (wxLogRecordInfo) wxLogRecordInfo.NativeToManagedMap[info];
            else __result2 = wxLogRecordInfo.__CreateInstance(info);
            __target.DoLogRecord(level, __result1, __result2);
        }

        // void DoLogTextAtLevel(wxLogLevel level, const wxString& msg)
        private static Delegates.Action_IntPtr_uint_IntPtr _DoLogTextAtLevel_0DelegateInstance;

        private static void _DoLogTextAtLevel_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogChain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            __target.DoLogTextAtLevel(level, __result1);
        }

        // void DoLogText(const wxString& msg)
        private static Delegates.Action_IntPtr_IntPtr _DoLogText_0DelegateInstance;

        private static void _DoLogText_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogChain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result0;
            if (msg == IntPtr.Zero) __result0 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result0 = (wxString) wxString.NativeToManagedMap[msg];
            else __result0 = wxString.__CreateInstance(msg);
            __target.DoLogText(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Flush_0DelegateInstance += _Flush_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Flush_0DelegateInstance).ToPointer();
                _DoLogRecord_0DelegateInstance += _DoLogRecord_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DoLogRecord_0DelegateInstance).ToPointer();
                _DoLogTextAtLevel_0DelegateInstance += _DoLogTextAtLevel_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_DoLogTextAtLevel_0DelegateInstance).ToPointer();
                _DoLogText_0DelegateInstance += _DoLogText_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_DoLogText_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxLogInterposer : wxLogChain, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr m_formatter;

            [FieldOffset(8)]
            public global::System.IntPtr m_logNew;

            [FieldOffset(12)]
            public global::System.IntPtr m_logOld;

            [FieldOffset(16)]
            public byte m_bPassMessages;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN15wxLogInterposerC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);
        }

        public static new wxLogInterposer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLogInterposer(native.ToPointer(), skipVTables);
        }

        public static wxLogInterposer __CreateInstance(wxLogInterposer.Internal native, bool skipVTables = false)
        {
            return new wxLogInterposer(native, skipVTables);
        }

        private static void* __CopyValue(wxLogInterposer.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            *(wxLogInterposer.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxLogInterposer(wxLogInterposer.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLogInterposer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxLogInterposer()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(20);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxLogInterposer");
        }

        #region Virtual table interop

        // wxLogInterposer
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogInterposer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // void Flush() wxOVERRIDE
        private static Delegates.Action_IntPtr _Flush_0DelegateInstance;

        private static void _Flush_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogInterposer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Flush();
        }

        // void DoLogRecord(wxLogLevel level, const wxString& msg, const wxLogRecordInfo& info) wxOVERRIDE
        private static Delegates.Action_IntPtr_uint_IntPtr_IntPtr _DoLogRecord_0DelegateInstance;

        private static void _DoLogRecord_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg, global::System.IntPtr info)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogInterposer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            wxLogRecordInfo __result2;
            if (info == IntPtr.Zero) __result2 = null;
            else if (wxLogRecordInfo.NativeToManagedMap.ContainsKey(info))
                __result2 = (wxLogRecordInfo) wxLogRecordInfo.NativeToManagedMap[info];
            else __result2 = wxLogRecordInfo.__CreateInstance(info);
            __target.DoLogRecord(level, __result1, __result2);
        }

        // void DoLogTextAtLevel(wxLogLevel level, const wxString& msg)
        private static Delegates.Action_IntPtr_uint_IntPtr _DoLogTextAtLevel_0DelegateInstance;

        private static void _DoLogTextAtLevel_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogInterposer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            __target.DoLogTextAtLevel(level, __result1);
        }

        // void DoLogText(const wxString& msg)
        private static Delegates.Action_IntPtr_IntPtr _DoLogText_0DelegateInstance;

        private static void _DoLogText_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogInterposer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result0;
            if (msg == IntPtr.Zero) __result0 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result0 = (wxString) wxString.NativeToManagedMap[msg];
            else __result0 = wxString.__CreateInstance(msg);
            __target.DoLogText(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Flush_0DelegateInstance += _Flush_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Flush_0DelegateInstance).ToPointer();
                _DoLogRecord_0DelegateInstance += _DoLogRecord_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DoLogRecord_0DelegateInstance).ToPointer();
                _DoLogTextAtLevel_0DelegateInstance += _DoLogTextAtLevel_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_DoLogTextAtLevel_0DelegateInstance).ToPointer();
                _DoLogText_0DelegateInstance += _DoLogText_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_DoLogText_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxLogInterposerTemp : wxLogChain, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr m_formatter;

            [FieldOffset(8)]
            public global::System.IntPtr m_logNew;

            [FieldOffset(12)]
            public global::System.IntPtr m_logOld;

            [FieldOffset(16)]
            public byte m_bPassMessages;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN19wxLogInterposerTempC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);
        }

        public static new wxLogInterposerTemp __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLogInterposerTemp(native.ToPointer(), skipVTables);
        }

        public static wxLogInterposerTemp __CreateInstance(wxLogInterposerTemp.Internal native, bool skipVTables = false)
        {
            return new wxLogInterposerTemp(native, skipVTables);
        }

        private static void* __CopyValue(wxLogInterposerTemp.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            *(wxLogInterposerTemp.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxLogInterposerTemp(wxLogInterposerTemp.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLogInterposerTemp(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxLogInterposerTemp()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(20);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "wxSharp.wxLogInterposerTemp");
        }

        #region Virtual table interop

        // wxLogInterposerTemp
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogInterposerTemp) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // void Flush() wxOVERRIDE
        private static Delegates.Action_IntPtr _Flush_0DelegateInstance;

        private static void _Flush_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogInterposerTemp) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Flush();
        }

        // void DoLogRecord(wxLogLevel level, const wxString& msg, const wxLogRecordInfo& info) wxOVERRIDE
        private static Delegates.Action_IntPtr_uint_IntPtr_IntPtr _DoLogRecord_0DelegateInstance;

        private static void _DoLogRecord_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg, global::System.IntPtr info)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogInterposerTemp) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            wxLogRecordInfo __result2;
            if (info == IntPtr.Zero) __result2 = null;
            else if (wxLogRecordInfo.NativeToManagedMap.ContainsKey(info))
                __result2 = (wxLogRecordInfo) wxLogRecordInfo.NativeToManagedMap[info];
            else __result2 = wxLogRecordInfo.__CreateInstance(info);
            __target.DoLogRecord(level, __result1, __result2);
        }

        // void DoLogTextAtLevel(wxLogLevel level, const wxString& msg)
        private static Delegates.Action_IntPtr_uint_IntPtr _DoLogTextAtLevel_0DelegateInstance;

        private static void _DoLogTextAtLevel_0DelegateHook(global::System.IntPtr instance, uint level, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogInterposerTemp) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result1;
            if (msg == IntPtr.Zero) __result1 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result1 = (wxString) wxString.NativeToManagedMap[msg];
            else __result1 = wxString.__CreateInstance(msg);
            __target.DoLogTextAtLevel(level, __result1);
        }

        // void DoLogText(const wxString& msg)
        private static Delegates.Action_IntPtr_IntPtr _DoLogText_0DelegateInstance;

        private static void _DoLogText_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr msg)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxLogInterposerTemp) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            wxString __result0;
            if (msg == IntPtr.Zero) __result0 = null;
            else if (wxString.NativeToManagedMap.ContainsKey(msg))
                __result0 = (wxString) wxString.NativeToManagedMap[msg];
            else __result0 = wxString.__CreateInstance(msg);
            __target.DoLogText(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Flush_0DelegateInstance += _Flush_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Flush_0DelegateInstance).ToPointer();
                _DoLogRecord_0DelegateInstance += _DoLogRecord_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DoLogRecord_0DelegateInstance).ToPointer();
                _DoLogTextAtLevel_0DelegateInstance += _DoLogTextAtLevel_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_DoLogTextAtLevel_0DelegateInstance).ToPointer();
                _DoLogText_0DelegateInstance += _DoLogText_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_DoLogText_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(8 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxLogger : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 52)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public uint m_level;

            [FieldOffset(4)]
            public wxLogRecordInfo.Internal m_info;

            [FieldOffset(32)]
            public wxString.Internal m_optKey;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxLoggerC2EmPKciS1_S1_")]
            internal static extern void ctor_0(global::System.IntPtr instance, uint level, global::System.IntPtr filename, int line, global::System.IntPtr func, global::System.IntPtr component);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxLoggerD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxLogger10MaybeStoreERK8wxStringm")]
            internal static extern global::System.IntPtr MaybeStore_0(global::System.IntPtr instance, global::System.IntPtr key, uint value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxLogger3LogERK14wxFormatString")]
            internal static extern void Log_0(global::System.IntPtr instance, global::System.IntPtr f1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxLogger3LogElRK14wxFormatString")]
            internal static extern void Log_31(global::System.IntPtr instance, int f1, global::System.IntPtr f2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxLogger3LogEP8wxObjectRK14wxFormatString")]
            internal static extern void Log_62(global::System.IntPtr instance, global::System.IntPtr f1, global::System.IntPtr f2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxLogger10LogAtLevelEmRK14wxFormatString")]
            internal static extern void LogAtLevel_0(global::System.IntPtr instance, uint f1, global::System.IntPtr f2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxLogger8LogTraceERK8wxStringRK14wxFormatString")]
            internal static extern void LogTrace_0(global::System.IntPtr instance, global::System.IntPtr f1, global::System.IntPtr f2);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLogger> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxLogger>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxLogger __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxLogger(native.ToPointer(), skipVTables);
        }

        public static wxLogger __CreateInstance(wxLogger.Internal native, bool skipVTables = false)
        {
            return new wxLogger(native, skipVTables);
        }

        private static void* __CopyValue(wxLogger.Internal native)
        {
            var ret = Marshal.AllocHGlobal(52);
            *(wxLogger.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxLogger(wxLogger.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxLogger(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxLogger(uint level, string filename, int line, string func, string component)
        {
            __Instance = Marshal.AllocHGlobal(52);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg1 = Marshal.StringToHGlobalAnsi(filename);
            var arg3 = Marshal.StringToHGlobalAnsi(func);
            var arg4 = Marshal.StringToHGlobalAnsi(component);
            Internal.ctor_0((__Instance + __PointerAdjustment), level, arg1, line, arg3, arg4);
            Marshal.FreeHGlobal(arg1);
            Marshal.FreeHGlobal(arg3);
            Marshal.FreeHGlobal(arg4);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxLogger __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public wxLogger MaybeStore(wxString key, uint value)
        {
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is a C++ reference (&).");
            var arg0 = key.__Instance;
            var __ret = Internal.MaybeStore_0((__Instance + __PointerAdjustment), arg0, value);
            wxLogger __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxLogger.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxLogger) wxLogger.NativeToManagedMap[__ret];
            else __result0 = wxLogger.__CreateInstance(__ret);
            return __result0;
        }

        public void Log(wxFormatString f1)
        {
            if (ReferenceEquals(f1, null))
                throw new global::System.ArgumentNullException("f1", "Cannot be null because it is a C++ reference (&).");
            var arg0 = f1.__Instance;
            Internal.Log_0((__Instance + __PointerAdjustment), arg0);
        }

        public void Log(int f1, wxFormatString f2)
        {
            if (ReferenceEquals(f2, null))
                throw new global::System.ArgumentNullException("f2", "Cannot be null because it is a C++ reference (&).");
            var arg1 = f2.__Instance;
            Internal.Log_31((__Instance + __PointerAdjustment), f1, arg1);
        }

        public void Log(wxObject f1, wxFormatString f2)
        {
            var arg0 = ReferenceEquals(f1, null) ? global::System.IntPtr.Zero : f1.__Instance;
            if (ReferenceEquals(f2, null))
                throw new global::System.ArgumentNullException("f2", "Cannot be null because it is a C++ reference (&).");
            var arg1 = f2.__Instance;
            Internal.Log_62((__Instance + __PointerAdjustment), arg0, arg1);
        }

        public void LogAtLevel(uint f1, wxFormatString f2)
        {
            if (ReferenceEquals(f2, null))
                throw new global::System.ArgumentNullException("f2", "Cannot be null because it is a C++ reference (&).");
            var arg1 = f2.__Instance;
            Internal.LogAtLevel_0((__Instance + __PointerAdjustment), f1, arg1);
        }

        public void LogTrace(wxString f1, wxFormatString f2)
        {
            if (ReferenceEquals(f1, null))
                throw new global::System.ArgumentNullException("f1", "Cannot be null because it is a C++ reference (&).");
            var arg0 = f1.__Instance;
            if (ReferenceEquals(f2, null))
                throw new global::System.ArgumentNullException("f2", "Cannot be null because it is a C++ reference (&).");
            var arg1 = f2.__Instance;
            Internal.LogTrace_0((__Instance + __PointerAdjustment), arg0, arg1);
        }
    }

    public unsafe partial class log
    {
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z14wxSysErrorCodev")]
            internal static extern uint wxSysErrorCode_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z13wxSysErrorMsgm")]
            internal static extern global::System.IntPtr wxSysErrorMsg_0(uint nErrCode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z8wxLogNopv")]
            internal static extern void wxLogNop_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z17wxSafeShowMessageRK8wxStringS1_")]
            internal static extern void wxSafeShowMessage_0(global::System.IntPtr title, global::System.IntPtr text);
        }

        public static uint wxSysErrorCode()
        {
            var __ret = Internal.wxSysErrorCode_0();
            return __ret;
        }

        public static string wxSysErrorMsg(uint nErrCode)
        {
            var __ret = Internal.wxSysErrorMsg_0(nErrCode);
            return CppSharp.Runtime.Helpers.MarshalEncodedString(__ret, System.Text.Encoding.UTF32);
        }

        public static void wxLogNop()
        {
            Internal.wxLogNop_0();
        }

        public static void wxSafeShowMessage(wxString title, wxString text)
        {
            if (ReferenceEquals(title, null))
                throw new global::System.ArgumentNullException("title", "Cannot be null because it is a C++ reference (&).");
            var arg0 = title.__Instance;
            if (ReferenceEquals(text, null))
                throw new global::System.ArgumentNullException("text", "Cannot be null because it is a C++ reference (&).");
            var arg1 = text.__Instance;
            Internal.wxSafeShowMessage_0(arg0, arg1);
        }
    }
}
