//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace wxSharp
{
    public enum wxMutexError : uint
    {
        wxMUTEX_NO_ERROR = 0,
        wxMUTEX_INVALID = 1,
        wxMUTEX_DEAD_LOCK = 2,
        wxMUTEX_BUSY = 3,
        wxMUTEX_UNLOCKED = 4,
        wxMUTEX_TIMEOUT = 5,
        wxMUTEX_MISC_ERROR = 6
    }

    public enum wxCondError : uint
    {
        wxCOND_NO_ERROR = 0,
        wxCOND_INVALID = 1,
        wxCOND_TIMEOUT = 2,
        wxCOND_MISC_ERROR = 3
    }

    public enum wxSemaError : uint
    {
        wxSEMA_NO_ERROR = 0,
        wxSEMA_INVALID = 1,
        wxSEMA_BUSY = 2,
        wxSEMA_TIMEOUT = 3,
        wxSEMA_OVERFLOW = 4,
        wxSEMA_MISC_ERROR = 5
    }

    public enum wxThreadError : uint
    {
        wxTHREAD_NO_ERROR = 0,
        wxTHREAD_NO_RESOURCE = 1,
        wxTHREAD_RUNNING = 2,
        wxTHREAD_NOT_RUNNING = 3,
        wxTHREAD_KILLED = 4,
        wxTHREAD_MISC_ERROR = 5
    }

    public enum wxThreadKind : uint
    {
        wxTHREAD_DETACHED = 0,
        wxTHREAD_JOINABLE = 1
    }

    public enum wxThreadWait : uint
    {
        wxTHREAD_WAIT_BLOCK = 0,
        wxTHREAD_WAIT_YIELD = 1,
        wxTHREAD_WAIT_DEFAULT = 0
    }

    public enum WXTHREAD : uint
    {
        WXTHREAD_MIN_PRIORITY = 0,
        WXTHREAD_DEFAULT_PRIORITY = 50,
        WXTHREAD_MAX_PRIORITY = 100
    }

    public enum wxMutexType : uint
    {
        wxMUTEX_DEFAULT = 0,
        wxMUTEX_RECURSIVE = 1
    }

    public enum wxCriticalSectionType : uint
    {
        wxCRITSEC_DEFAULT = 0,
        wxCRITSEC_NON_RECURSIVE = 1
    }

    public unsafe partial class wxMutex : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr m_internal;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN7wxMutexC2E11wxMutexType")]
            internal static extern void ctor_0(global::System.IntPtr instance, wxMutexType mutexType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN7wxMutexD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK7wxMutex4IsOkEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsOk_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN7wxMutex4LockEv")]
            internal static extern wxMutexError Lock_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN7wxMutex11LockTimeoutEm")]
            internal static extern wxMutexError LockTimeout_0(global::System.IntPtr instance, uint ms);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN7wxMutex7TryLockEv")]
            internal static extern wxMutexError TryLock_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN7wxMutex6UnlockEv")]
            internal static extern wxMutexError Unlock_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxMutex> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxMutex>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxMutex __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxMutex(native.ToPointer(), skipVTables);
        }

        public static wxMutex __CreateInstance(wxMutex.Internal native, bool skipVTables = false)
        {
            return new wxMutex(native, skipVTables);
        }

        private static void* __CopyValue(wxMutex.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            *(wxMutex.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxMutex(wxMutex.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxMutex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxMutex(wxMutexType mutexType)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = mutexType;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxMutex __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool IsOk()
        {
            var __ret = Internal.IsOk_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxMutexError Lock()
        {
            var __ret = Internal.Lock_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxMutexError LockTimeout(uint ms)
        {
            var __ret = Internal.LockTimeout_0((__Instance + __PointerAdjustment), ms);
            return __ret;
        }

        public wxMutexError TryLock()
        {
            var __ret = Internal.TryLock_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxMutexError Unlock()
        {
            var __ret = Internal.Unlock_0((__Instance + __PointerAdjustment));
            return __ret;
        }
    }

    public unsafe partial class wxMutexLocker : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public byte m_isOk;

            [FieldOffset(4)]
            public global::System.IntPtr m_mutex;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13wxMutexLockerC2ER7wxMutex")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr mutex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13wxMutexLockerD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK13wxMutexLocker4IsOkEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsOk_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxMutexLocker> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxMutexLocker>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxMutexLocker __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxMutexLocker(native.ToPointer(), skipVTables);
        }

        public static wxMutexLocker __CreateInstance(wxMutexLocker.Internal native, bool skipVTables = false)
        {
            return new wxMutexLocker(native, skipVTables);
        }

        private static void* __CopyValue(wxMutexLocker.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            *(wxMutexLocker.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxMutexLocker(wxMutexLocker.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxMutexLocker(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxMutexLocker(wxMutex mutex)
        {
            __Instance = Marshal.AllocHGlobal(8);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(mutex, null))
                throw new global::System.ArgumentNullException("mutex", "Cannot be null because it is a C++ reference (&).");
            var arg0 = mutex.__Instance;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxMutexLocker __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool IsOk()
        {
            var __ret = Internal.IsOk_0((__Instance + __PointerAdjustment));
            return __ret;
        }
    }

    public unsafe partial class wxCriticalSection : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public wxMutex.Internal m_mutex;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN17wxCriticalSectionC2E21wxCriticalSectionType")]
            internal static extern void ctor_0(global::System.IntPtr instance, wxCriticalSectionType critSecType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN17wxCriticalSectionD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN17wxCriticalSection5EnterEv")]
            internal static extern void Enter_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN17wxCriticalSection8TryEnterEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool TryEnter_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN17wxCriticalSection5LeaveEv")]
            internal static extern void Leave_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxCriticalSection> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxCriticalSection>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxCriticalSection __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxCriticalSection(native.ToPointer(), skipVTables);
        }

        public static wxCriticalSection __CreateInstance(wxCriticalSection.Internal native, bool skipVTables = false)
        {
            return new wxCriticalSection(native, skipVTables);
        }

        private static void* __CopyValue(wxCriticalSection.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            *(wxCriticalSection.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxCriticalSection(wxCriticalSection.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxCriticalSection(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxCriticalSection(wxCriticalSectionType critSecType)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = critSecType;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxCriticalSection __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void Enter()
        {
            Internal.Enter_0((__Instance + __PointerAdjustment));
        }

        public bool TryEnter()
        {
            var __ret = Internal.TryEnter_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void Leave()
        {
            Internal.Leave_0((__Instance + __PointerAdjustment));
        }
    }

    public unsafe partial class wxCriticalSectionLocker : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr m_critsect;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN23wxCriticalSectionLockerC2ER17wxCriticalSection")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr cs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN23wxCriticalSectionLockerD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxCriticalSectionLocker> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxCriticalSectionLocker>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxCriticalSectionLocker __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxCriticalSectionLocker(native.ToPointer(), skipVTables);
        }

        public static wxCriticalSectionLocker __CreateInstance(wxCriticalSectionLocker.Internal native, bool skipVTables = false)
        {
            return new wxCriticalSectionLocker(native, skipVTables);
        }

        private static void* __CopyValue(wxCriticalSectionLocker.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            *(wxCriticalSectionLocker.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxCriticalSectionLocker(wxCriticalSectionLocker.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxCriticalSectionLocker(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxCriticalSectionLocker(wxCriticalSection cs)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(cs, null))
                throw new global::System.ArgumentNullException("cs", "Cannot be null because it is a C++ reference (&).");
            var arg0 = cs.__Instance;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxCriticalSectionLocker __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class wxCondition : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr m_internal;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxConditionC2ER7wxMutex")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr mutex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxConditionD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK11wxCondition4IsOkEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsOk_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxCondition4WaitEv")]
            internal static extern wxCondError Wait_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxCondition11WaitTimeoutEm")]
            internal static extern wxCondError WaitTimeout_0(global::System.IntPtr instance, uint milliseconds);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxCondition6SignalEv")]
            internal static extern wxCondError Signal_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxCondition9BroadcastEv")]
            internal static extern wxCondError Broadcast_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxCondition> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxCondition>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxCondition __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxCondition(native.ToPointer(), skipVTables);
        }

        public static wxCondition __CreateInstance(wxCondition.Internal native, bool skipVTables = false)
        {
            return new wxCondition(native, skipVTables);
        }

        private static void* __CopyValue(wxCondition.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            *(wxCondition.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxCondition(wxCondition.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxCondition(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxCondition(wxMutex mutex)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(mutex, null))
                throw new global::System.ArgumentNullException("mutex", "Cannot be null because it is a C++ reference (&).");
            var arg0 = mutex.__Instance;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxCondition __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool IsOk()
        {
            var __ret = Internal.IsOk_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxCondError Wait()
        {
            var __ret = Internal.Wait_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxCondError WaitTimeout(uint milliseconds)
        {
            var __ret = Internal.WaitTimeout_0((__Instance + __PointerAdjustment), milliseconds);
            return __ret;
        }

        public wxCondError Signal()
        {
            var __ret = Internal.Signal_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxCondError Broadcast()
        {
            var __ret = Internal.Broadcast_0((__Instance + __PointerAdjustment));
            return __ret;
        }
    }

    public unsafe partial class wxSemaphore : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr m_internal;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxSemaphoreC2Eii")]
            internal static extern void ctor_0(global::System.IntPtr instance, int initialcount, int maxcount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxSemaphoreD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK11wxSemaphore4IsOkEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsOk_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxSemaphore4WaitEv")]
            internal static extern wxSemaError Wait_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxSemaphore7TryWaitEv")]
            internal static extern wxSemaError TryWait_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxSemaphore11WaitTimeoutEm")]
            internal static extern wxSemaError WaitTimeout_0(global::System.IntPtr instance, uint milliseconds);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN11wxSemaphore4PostEv")]
            internal static extern wxSemaError Post_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxSemaphore> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxSemaphore>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxSemaphore __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxSemaphore(native.ToPointer(), skipVTables);
        }

        public static wxSemaphore __CreateInstance(wxSemaphore.Internal native, bool skipVTables = false)
        {
            return new wxSemaphore(native, skipVTables);
        }

        private static void* __CopyValue(wxSemaphore.Internal native)
        {
            var ret = Marshal.AllocHGlobal(4);
            *(wxSemaphore.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxSemaphore(wxSemaphore.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxSemaphore(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxSemaphore(int initialcount, int maxcount)
        {
            __Instance = Marshal.AllocHGlobal(4);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment), initialcount, maxcount);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxSemaphore __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool IsOk()
        {
            var __ret = Internal.IsOk_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxSemaError Wait()
        {
            var __ret = Internal.Wait_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxSemaError TryWait()
        {
            var __ret = Internal.TryWait_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxSemaError WaitTimeout(uint milliseconds)
        {
            var __ret = Internal.WaitTimeout_0((__Instance + __PointerAdjustment), milliseconds);
            return __ret;
        }

        public wxSemaError Post()
        {
            var __ret = Internal.Post_0((__Instance + __PointerAdjustment));
            return __ret;
        }
    }

    public unsafe abstract partial class wxThread : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr m_internal;

            [FieldOffset(8)]
            public wxCriticalSection.Internal m_critsect;

            [FieldOffset(12)]
            public byte m_isDetached;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThreadC2E12wxThreadKind")]
            internal static extern void ctor_0(global::System.IntPtr instance, wxThreadKind kind);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThreadD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread4ThisEv")]
            internal static extern global::System.IntPtr This_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread6IsMainEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsMain_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread9GetMainIdEv")]
            internal static extern uint GetMainId_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread5YieldEv")]
            internal static extern void Yield_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread5SleepEm")]
            internal static extern void Sleep_0(uint milliseconds);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread11GetCPUCountEv")]
            internal static extern int GetCPUCount_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread12GetCurrentIdEv")]
            internal static extern uint GetCurrentId_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread14SetConcurrencyEm")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool SetConcurrency_0(uint level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread6CreateEj")]
            internal static extern wxThreadError Create_0(global::System.IntPtr instance, uint stackSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread3RunEv")]
            internal static extern wxThreadError Run_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread6DeleteEPPv12wxThreadWait")]
            internal static extern wxThreadError Delete_0(global::System.IntPtr instance, global::System.IntPtr rc, wxThreadWait waitMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread4WaitE12wxThreadWait")]
            internal static extern global::System.IntPtr Wait_0(global::System.IntPtr instance, wxThreadWait waitMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread4KillEv")]
            internal static extern wxThreadError Kill_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread5PauseEv")]
            internal static extern wxThreadError Pause_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread6ResumeEv")]
            internal static extern wxThreadError Resume_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread11SetPriorityEj")]
            internal static extern void SetPriority_0(global::System.IntPtr instance, uint prio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK8wxThread11GetPriorityEv")]
            internal static extern uint GetPriority_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK8wxThread7IsAliveEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsAlive_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK8wxThread9IsRunningEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsRunning_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK8wxThread8IsPausedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsPaused_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK8wxThread10IsDetachedEv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool IsDetached_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK8wxThread5GetIdEv")]
            internal static extern uint GetId_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK8wxThread7GetKindEv")]
            internal static extern wxThreadKind GetKind_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread4ExitEPv")]
            internal static extern void Exit_0(global::System.IntPtr instance, global::System.IntPtr exitcode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8wxThread9CallEntryEv")]
            internal static extern global::System.IntPtr CallEntry_0(global::System.IntPtr instance);
        }

        public class ExitCode { }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxThread> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxThread>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxThread __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxThreadInternal(native.ToPointer(), skipVTables);
        }

        public static wxThread __CreateInstance(wxThread.Internal native, bool skipVTables = false)
        {
            return new wxThreadInternal(native, skipVTables);
        }

        protected wxThread(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        protected wxThread(wxThreadKind kind)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = kind;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxThread");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxThread __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
            if (__slot != null)
            {
                var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
                ___dtor_0Delegate((__Instance + __PointerAdjustment));
            }
            else
                Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public wxThreadError Create(uint stackSize)
        {
            var __ret = Internal.Create_0((__Instance + __PointerAdjustment), stackSize);
            return __ret;
        }

        public wxThreadError Run()
        {
            var __ret = Internal.Run_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxThreadError Delete(global::System.IntPtr rc, wxThreadWait waitMode)
        {
            var arg0 = rc;
            var arg1 = waitMode;
            var __ret = Internal.Delete_0((__Instance + __PointerAdjustment), arg0, arg1);
            return __ret;
        }

        public global::System.IntPtr Wait(wxThreadWait waitMode)
        {
            var arg0 = waitMode;
            var __ret = Internal.Wait_0((__Instance + __PointerAdjustment), arg0);
            return __ret;
        }

        public wxThreadError Kill()
        {
            var __ret = Internal.Kill_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxThreadError Pause()
        {
            var __ret = Internal.Pause_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxThreadError Resume()
        {
            var __ret = Internal.Resume_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void SetPriority(uint prio)
        {
            Internal.SetPriority_0((__Instance + __PointerAdjustment), prio);
        }

        public uint GetPriority()
        {
            var __ret = Internal.GetPriority_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool IsAlive()
        {
            var __ret = Internal.IsAlive_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool IsRunning()
        {
            var __ret = Internal.IsRunning_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool IsPaused()
        {
            var __ret = Internal.IsPaused_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool IsDetached()
        {
            var __ret = Internal.IsDetached_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public uint GetId()
        {
            var __ret = Internal.GetId_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public wxThreadKind GetKind()
        {
            var __ret = Internal.GetKind_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public virtual bool TestDestroy()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___TestDestroy_0Delegate = (Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr));
            var __ret = ___TestDestroy_0Delegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        protected void Exit(global::System.IntPtr exitcode)
        {
            var arg0 = exitcode;
            Internal.Exit_0((__Instance + __PointerAdjustment), arg0);
        }

        protected abstract global::System.IntPtr Entry();

        protected global::System.IntPtr CallEntry()
        {
            var __ret = Internal.CallEntry_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        protected virtual void OnDelete()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 4);
            var ___OnDelete_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___OnDelete_0Delegate((__Instance + __PointerAdjustment));
        }

        protected virtual void OnKill()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
            var ___OnKill_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
            ___OnKill_0Delegate((__Instance + __PointerAdjustment));
        }

        public static wxThread This()
        {
            var __ret = Internal.This_0();
            wxThread __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxThread.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxThread) wxThread.NativeToManagedMap[__ret];
            else wxThread.NativeToManagedMap[__ret] = __result0 = (wxThread) wxThread.__CreateInstance(__ret);
            return __result0;
        }

        public static bool IsMain()
        {
            var __ret = Internal.IsMain_0();
            return __ret;
        }

        public static uint GetMainId()
        {
            var __ret = Internal.GetMainId_0();
            return __ret;
        }

        public static void Yield()
        {
            Internal.Yield_0();
        }

        public static void Sleep(uint milliseconds)
        {
            Internal.Sleep_0(milliseconds);
        }

        public static int GetCPUCount()
        {
            var __ret = Internal.GetCPUCount_0();
            return __ret;
        }

        public static uint GetCurrentId()
        {
            var __ret = Internal.GetCurrentId_0();
            return __ret;
        }

        public static bool SetConcurrency(uint level)
        {
            var __ret = Internal.SetConcurrency_0(level);
            return __ret;
        }

        #region Virtual table interop

        // bool TestDestroy()
        private static Delegates.Func_bool_IntPtr _TestDestroy_0DelegateInstance;

        private static bool _TestDestroy_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThread) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.TestDestroy();
            return __ret;
        }

        // virtual ~wxThread()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThread) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // void *Entry() = 0
        private static Delegates.Func_IntPtr_IntPtr _Entry_0DelegateInstance;

        private static global::System.IntPtr _Entry_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThread) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Entry();
            return __ret;
        }

        // void OnDelete()
        private static Delegates.Action_IntPtr _OnDelete_0DelegateInstance;

        private static void _OnDelete_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThread) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnDelete();
        }

        // void OnKill()
        private static Delegates.Action_IntPtr _OnKill_0DelegateInstance;

        private static void _OnKill_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThread) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnKill();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _TestDestroy_0DelegateInstance += _TestDestroy_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_TestDestroy_0DelegateInstance).ToPointer();
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Entry_0DelegateInstance += _Entry_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Entry_0DelegateInstance).ToPointer();
                _OnDelete_0DelegateInstance += _OnDelete_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_OnDelete_0DelegateInstance).ToPointer();
                _OnKill_0DelegateInstance += _OnKill_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_OnKill_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(9 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                    *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(9 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = _Thunks[0];
                    *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                    *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxThreadHelperThread : wxThread, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public new partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr m_internal;

            [FieldOffset(8)]
            public wxCriticalSection.Internal m_critsect;

            [FieldOffset(12)]
            public byte m_isDetached;

            [FieldOffset(16)]
            public global::System.IntPtr m_owner;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN20wxThreadHelperThreadC2ER14wxThreadHelper12wxThreadKind")]
            internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr owner, wxThreadKind kind);
        }

        public static new wxThreadHelperThread __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxThreadHelperThread(native.ToPointer(), skipVTables);
        }

        public static wxThreadHelperThread __CreateInstance(wxThreadHelperThread.Internal native, bool skipVTables = false)
        {
            return new wxThreadHelperThread(native, skipVTables);
        }

        private static void* __CopyValue(wxThreadHelperThread.Internal native)
        {
            var ret = Marshal.AllocHGlobal(20);
            *(wxThreadHelperThread.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxThreadHelperThread(wxThreadHelperThread.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxThreadHelperThread(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        public wxThreadHelperThread(wxThreadHelper owner, wxThreadKind kind)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(20);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(owner, null))
                throw new global::System.ArgumentNullException("owner", "Cannot be null because it is a C++ reference (&).");
            var arg0 = owner.__Instance;
            var arg1 = kind;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0, arg1);
            SetupVTables(GetType().FullName == "wxSharp.wxThreadHelperThread");
        }

        protected override global::System.IntPtr Entry()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
            var ___Entry_0Delegate = (Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_IntPtr_IntPtr));
            var __ret = ___Entry_0Delegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        #region Virtual table interop

        // bool TestDestroy()
        private static Delegates.Func_bool_IntPtr _TestDestroy_0DelegateInstance;

        private static bool _TestDestroy_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThreadHelperThread) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.TestDestroy();
            return __ret;
        }

        // wxThreadHelperThread
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThreadHelperThread) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // void *Entry() wxOVERRIDE
        private static Delegates.Func_IntPtr_IntPtr _Entry_0DelegateInstance;

        private static global::System.IntPtr _Entry_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThreadHelperThread) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Entry();
            return __ret;
        }

        // void OnDelete()
        private static Delegates.Action_IntPtr _OnDelete_0DelegateInstance;

        private static void _OnDelete_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThreadHelperThread) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnDelete();
        }

        // void OnKill()
        private static Delegates.Action_IntPtr _OnKill_0DelegateInstance;

        private static void _OnKill_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThreadHelperThread) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnKill();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _TestDestroy_0DelegateInstance += _TestDestroy_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_TestDestroy_0DelegateInstance).ToPointer();
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Entry_0DelegateInstance += _Entry_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Entry_0DelegateInstance).ToPointer();
                _OnDelete_0DelegateInstance += _OnDelete_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_OnDelete_0DelegateInstance).ToPointer();
                _OnKill_0DelegateInstance += _OnKill_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_OnKill_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(9 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = *(void**)(native->vfptr0 + 12);
                    *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                    *(void**)(vfptr0 + 20) = *(void**)(native->vfptr0 + 20);
                    *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(9 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = _Thunks[0];
                    *(void**)(vfptr0 + 4) = *(void**)(native->vfptr0 + 4);
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                    *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe abstract partial class wxThreadHelper : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct Internal
        {
            [FieldOffset(4)]
            public global::System.IntPtr m_thread;

            [FieldOffset(8)]
            public wxThreadKind m_kind;

            [FieldOffset(12)]
            public wxCriticalSection.Internal m_critSection;

            [FieldOffset(0)]
            public global::System.IntPtr vfptr0;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14wxThreadHelperC2E12wxThreadKind")]
            internal static extern void ctor_0(global::System.IntPtr instance, wxThreadKind kind);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14wxThreadHelperC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14wxThreadHelperD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14wxThreadHelper12CreateThreadE12wxThreadKindj")]
            internal static extern wxThreadError CreateThread_0(global::System.IntPtr instance, wxThreadKind kind, uint stackSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK14wxThreadHelper9GetThreadEv")]
            internal static extern global::System.IntPtr GetThread_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxThreadHelper> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxThreadHelper>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxThreadHelper __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxThreadHelperInternal(native.ToPointer(), skipVTables);
        }

        public static wxThreadHelper __CreateInstance(wxThreadHelper.Internal native, bool skipVTables = false)
        {
            return new wxThreadHelperInternal(native, skipVTables);
        }

        protected wxThreadHelper(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
            else
                SetupVTables(true);
        }

        protected wxThreadHelper(wxThreadKind kind)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var arg0 = kind;
            Internal.ctor_0((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxThreadHelper");
        }

        protected wxThreadHelper(wxThreadHelper _0)
        {
            __Instance = Marshal.AllocHGlobal(16);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var arg0 = _0.__Instance;
            Internal.cctor_1((__Instance + __PointerAdjustment), arg0);
            SetupVTables(GetType().FullName == "wxSharp.wxThreadHelper");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxThreadHelper __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((Internal*) __Instance)->vfptr0 = new global::System.IntPtr(__OriginalVTables[0]);
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            if (__slot != null)
            {
                var ___dtor_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
                ___dtor_0Delegate((__Instance + __PointerAdjustment));
            }
            else
                Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public wxThreadError CreateThread(wxThreadKind kind, uint stackSize)
        {
            var arg0 = kind;
            var __ret = Internal.CreateThread_0((__Instance + __PointerAdjustment), arg0, stackSize);
            return __ret;
        }

        public abstract global::System.IntPtr Entry();

        public wxThread GetThread()
        {
            var __ret = Internal.GetThread_0((__Instance + __PointerAdjustment));
            wxThread __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (wxThread.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (wxThread) wxThread.NativeToManagedMap[__ret];
            else wxThread.NativeToManagedMap[__ret] = __result0 = (wxThread) wxThread.__CreateInstance(__ret);
            return __result0;
        }

        protected wxThread m_thread
        {
            get
            {
                wxThread __result0;
                if (((Internal*) __Instance)->m_thread == IntPtr.Zero) __result0 = null;
                else if (wxThread.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->m_thread))
                    __result0 = (wxThread) wxThread.NativeToManagedMap[((Internal*) __Instance)->m_thread];
                else wxThread.NativeToManagedMap[((Internal*) __Instance)->m_thread] = __result0 = (wxThread) wxThread.__CreateInstance(((Internal*) __Instance)->m_thread);
                return __result0;
            }

            set
            {
                ((Internal*) __Instance)->m_thread = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        protected wxThreadKind m_kind
        {
            get
            {
                return ((Internal*) __Instance)->m_kind;
            }

            set
            {
                ((Internal*) __Instance)->m_kind = value;
            }
        }

        protected wxCriticalSection m_critSection
        {
            get
            {
                return wxCriticalSection.__CreateInstance(((Internal*) __Instance)->m_critSection);
            }

            set
            {
                ((Internal*) __Instance)->m_critSection = ReferenceEquals(value, null) ? new wxCriticalSection.Internal() : *(wxCriticalSection.Internal*) (value.__Instance);
            }
        }

        #region Virtual table interop

        // virtual ~wxThreadHelper()
        private static Delegates.Action_IntPtr _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThreadHelper) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(false);
        }

        // void *Entry() = 0
        private static Delegates.Func_IntPtr_IntPtr _Entry_0DelegateInstance;

        private static global::System.IntPtr _Entry_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (wxThreadHelper) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Entry();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            var native = (Internal*) __Instance.ToPointer();

            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Entry_0DelegateInstance += _Entry_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Entry_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = *(void**)(native->vfptr0 + 8);
                }

                native->vfptr0 = new IntPtr(__ManagedVTablesDtorOnly[0]);
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 4);
                    var vfptr0 = vtptr + 2 * 4;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + -8) = *(void**)(native->vfptr0 + -8);
                    *(void**)(vfptr0 + -4) = *(void**)(native->vfptr0 + -4);
                    *(void**)(vfptr0 + 0) = *(void**)(native->vfptr0 + 0);
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                }

                native->vfptr0 = new IntPtr(__ManagedVTables[0]);
            }
        }

        #endregion
    }

    public unsafe partial class wxMutexGuiLocker : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxMutexGuiLockerC2Ev")]
            internal static extern void ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxMutexGuiLockerC2ERKS_")]
            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN16wxMutexGuiLockerD2Ev")]
            internal static extern void dtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxMutexGuiLocker> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, wxMutexGuiLocker>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static wxMutexGuiLocker __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new wxMutexGuiLocker(native.ToPointer(), skipVTables);
        }

        public static wxMutexGuiLocker __CreateInstance(wxMutexGuiLocker.Internal native, bool skipVTables = false)
        {
            return new wxMutexGuiLocker(native, skipVTables);
        }

        private static void* __CopyValue(wxMutexGuiLocker.Internal native)
        {
            var ret = Marshal.AllocHGlobal(0);
            *(wxMutexGuiLocker.Internal*) ret = native;
            return ret.ToPointer();
        }

        private wxMutexGuiLocker(wxMutexGuiLocker.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected wxMutexGuiLocker(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public wxMutexGuiLocker()
        {
            __Instance = Marshal.AllocHGlobal(0);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public wxMutexGuiLocker(wxMutexGuiLocker _0)
        {
            __Instance = Marshal.AllocHGlobal(0);
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((wxMutexGuiLocker.Internal*) __Instance) = *((wxMutexGuiLocker.Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            wxMutexGuiLocker __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            Internal.dtor_0((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    internal unsafe partial class wxThreadInternal : wxThread, IDisposable
    {
        private static void* __CopyValue(wxThread.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            *(wxThread.Internal*) ret = native;
            return ret.ToPointer();
        }

        internal wxThreadInternal(wxThread.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal wxThreadInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
        }

        protected override global::System.IntPtr Entry()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
            var ___Entry_0Delegate = (Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_IntPtr_IntPtr));
            var __ret = ___Entry_0Delegate((__Instance + __PointerAdjustment));
            return __ret;
        }
    }

    internal unsafe partial class wxThreadHelperInternal : wxThreadHelper, IDisposable
    {
        private static void* __CopyValue(wxThreadHelper.Internal native)
        {
            var ret = Marshal.AllocHGlobal(16);
            *(wxThreadHelper.Internal*) ret = native;
            return ret.ToPointer();
        }

        internal wxThreadHelperInternal(wxThreadHelper.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal wxThreadHelperInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { ((Internal*) native)->vfptr0.ToPointer() };
        }

        public override global::System.IntPtr Entry()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___Entry_0Delegate = (Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_IntPtr_IntPtr));
            var __ret = ___Entry_0Delegate((__Instance + __PointerAdjustment));
            return __ret;
        }
    }

    public unsafe partial class thread
    {
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z15wxMutexGuiEnterv")]
            internal static extern void wxMutexGuiEnter_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z15wxMutexGuiLeavev")]
            internal static extern void wxMutexGuiLeave_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z14wxIsMainThreadv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool wxIsMainThread_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z22wxMutexGuiLeaveOrEnterv")]
            internal static extern void wxMutexGuiLeaveOrEnter_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z22wxGuiOwnedByMainThreadv")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool wxGuiOwnedByMainThread_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("wxSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_Z18wxWakeUpMainThreadv")]
            internal static extern void wxWakeUpMainThread_0();
        }

        public static void wxMutexGuiEnter()
        {
            Internal.wxMutexGuiEnter_0();
        }

        public static void wxMutexGuiLeave()
        {
            Internal.wxMutexGuiLeave_0();
        }

        public static bool wxIsMainThread()
        {
            var __ret = Internal.wxIsMainThread_0();
            return __ret;
        }

        public static void wxMutexGuiLeaveOrEnter()
        {
            Internal.wxMutexGuiLeaveOrEnter_0();
        }

        public static bool wxGuiOwnedByMainThread()
        {
            var __ret = Internal.wxGuiOwnedByMainThread_0();
            return __ret;
        }

        public static void wxWakeUpMainThread()
        {
            Internal.wxWakeUpMainThread_0();
        }
    }
}
